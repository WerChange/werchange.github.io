[{"content":"\n一句话题解\r不能什么题都随便写写就过了，留点印象好一点。一直更新。\n顺便看看 CSP（10.26） 到 NOIP（11.30） 这段时间能刷多少题。\n如果想看某道题的题解可以 Ctrl + F 搜索关键字，也可以在目录里找。\n关于题目难度评级：\nEasy：完全独立切掉。 Medium：看了题解茅塞顿开并切掉。 Hard：看了题解磨了好久才切掉。 2024.10.29\rABC290F\rMedium\n组合数数。满足树的形态要有 $\\sum deg_i=2n-2$。考虑目前有 $k$ 个儿子节点，直径最大肯定是 $n-k$ 个非儿子点串一条长度为 $n-k+1$ 的链，然后再挂儿子节点。总度数 $2n-2$，给 $n-k$ 个非儿子节点支配的还剩 $2n-2-k$，易得插板：$\\binom{(2n-2-k)-2(n-k)+(n-k)-1}{(2n-2-k)-2(n-k)}=\\binom{n-3}{k-2}$。答案即为：$\\sum\\limits_{k=1}^n \\binom{n}{k}\\binom{n-3}{k-2}(n-k+1)$。\n根据吸收恒等式（$k\\binom{n}{k}=n\\binom{n-1}{k-1}$）和范德蒙德卷积（$\\sum\\limits_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}$）可以化简成 $O(1)$：$Ans=(n-1)\\binom{2n-3}{n-1}-(n-3)\\binom{2n-4}{n-1}$。\nARC156C\rMedium\n构造。观察可得价值最小无论如何都是 $1$。方向转为构造排列。观察树是链的情况，排列直接为序号翻转过来。考虑树普通情况，每次取两个叶子节点交换序号即可。类似拓扑地，可以处理至原树变成一条链。\n正确性证明：一条 $u\\to v$ 的简单路径，路上的编号大概形如 $v\\to u$ 的路径的编号。刚好是完全相反的，满足了 LCS 为 $1$。\n2024.10.30\rLuogu P5749 [IOI2019] 排列鞋子\rMedium\n贪心。对于每种大小用 vector 存鞋的位置，从后往前遍历，每次可配对鞋一定在 vector 最后一个最优。贪心显然成立。可以用树状数组优化求区间 $1$（交换次数）操作。\nABC285E\rMedium\nDP。可设 $S_i$ 表示一周 $i+1$ 天只有一天休息日的贡献。易得 $S_i=2\\sum\\limits_{j=1}^{\\lfloor\\frac{i}{2}\\rfloor}a_j+[i\\bmod 2=1]a_{\\lceil\\frac{i}{2}\\rceil}$。设 $F_i$ 表示一周有 $i$ 天的贡献，初始状态有 $F_i=S_{i-1}$。可以枚举休息日的个数：$F_i=\\max\\limits_{j=2}^{i-2} F_j+F_{i-j}$。答案为 $F_n$。\nCF79D\rMedium\n状压 DP + 差分 + 图论建模。对区间翻转的操作，可以把序列转为差分序列后单点修改。设让 $(i,j)$ 两位同时翻转的代价为 $w(i,j)$，再设已清零状态为 $ste$ 的最小代价为 $f_{ste}$。可得：$f_{ste}=\\min\\limits_{i,j} f_{ste-2^i-2^j}+w(i,j)$。对于 $w(i,j)$ 我们采用图论建模：若 $|u-v|=l_i$，则 $u,v$ 之间有边权为 $1$ 的边。那么可由 $v$ 再拓展到其他边，这样对于每个起点 $s$ 求出来的最短路 $dis_i$ 即为两点同时翻转的最小操作次数。所以跑 $n$ 轮 SPFA 即可得到 $w(i,j)$。\nCF1109E\rMedium\n线段树。除数如果和模数互质，那么转换为乘逆元的操作，非常好做。注意到模数不同的质因子不超 $9$ 个，现在把模数唯一分解，对于操作除数可以先把含有的模数因子剔除出来，剩下的数就可以乘逆元。是因子的数我们存他的指数，除到了他们就是指数减减。要计算权值的时候跑个快速幂把他们乘起来。\nCF853C\rMedium\n二维数点。算相交不好算，就算不相交的。显然在矩形的某一边的一侧或角落上，减去四边上的后多减了一次四角，所以要再加回来。由于可以旋转坐标系，所以我们只考虑左下角。我们把矩形按左下角横坐标排序，双指针维护点横坐标始终小于等于矩形左端，左边的不相交矩形个数是 $\\binom{i-1}{2}=\\frac{(i-2)(i-1)}{2}$，左下角的矩形个数是 $\\binom{k}{2}=\\frac{k(k-1)}{2}$。$k$ 表示横纵坐标都小于当前矩形左下角横纵坐标的点数。如何求 $k$？二维偏序，可以树状数组维护。\nLuogu P2757 [国家集训队] 等差子序列\rMedium\n线段树 + 哈希。题意容易转换为找排列中有没有长度为 $3$ 的等差序列。这类题可以想到遍历中间那个数，如果 $a_i-k$ 已遍历（在左边）、$a_i+k$ 未遍历（在右边）就合法，当然大小顺序倒过来也一样。考虑优化掉 $k$ 的枚举。假设我们现在用一个长为 $n$ 的 01 数组来表示下标为 $i$ 的数是否访问过。我们考虑对一个值为 $1$ 的地方将整个数组折叠，如果重合的地方只有其中一个为 $1$ 那么我们就找到了长为 $3$ 的等差序列。这一步可以用两个哈希比较，分别是从左到右的哈希和从右到左的哈希，如果哈希相同，证明找到了等差序列。这一步可以用线段树实现区间哈希。\nCF1083C\rMedium\n线段树 + ST 表。查 mex 就是查一段最大前缀 $1,2,\\dots,k$ 使得这权值为 $1,2,\\dots,k$ 的 $k$ 个点都在一条链上。考虑对每个 $i$ 维护点权等于 $i$ 的点在树上的编号，用线段树维护 $[l,r]$ 是否都在一条链上。考虑区间信息的合并：如果任意一个区间内的点都不构成链，必然合起来也不构成链。否则考虑两条链的端点 $a,b,c,d$，任选两个作新链的端点，总共有 $\\binom{2}{4}=6$ 种可能，枚举即可，同时判断另外两个点是否在这条链上。\n如何判断一个点是否在一条链上：$dis(x,u)+dis(x,v)=dis(u,v)$ 是 $x$ 在路径 $(u,v)$ 上的充要条件。用欧拉序 +ST 表 $O(n\\log n)\\sim O(1)$ 求 LCA 即可。\nCF830D\rMedium\nDP。设 $f_{i,j}$ 表示 $i$ 层的树能选出多少组不相交的 $j$ 条路径。可以由两棵 $i-1$ 层的树合并成 $i$ 层的树。共有 $4$ 种转移：1. 直接转。 2. 增加一条路径，即根节点自己。 3. 将根节点和一条路径合并。 4. 将根节点和两条路径合并。转移方程分别为（$t=f_{i-1,j}\\times f_{i-1,k}$）：\n$f_{i,j+k}=t$ $f_{i,j+k+1}=t$ $f_{i,j+k}=2t(j+k)$ $f_{i,j+k-1}=2t\\binom{j+k}{2}$ 目标状态为 $f_{n,1}$。\n2024.10.31\rCF513E2 \u0026amp; E1\rHard\nDP。这个做法可以过 E1。遇绝对值拆绝对值，我们发现真正有贡献的段是比相邻都大或都小的段。抽象成折线图，“峰”可以贡献 $+2s_i$,“谷”可以贡献 $-2s_i$，其余（“升”、“降”）的贡献均为 $0$。当然 $s_1$、$s_k$ 的贡献另说。根据发现，可设 $f_{i,j,0/1/2/3}$ 表示第 $i$ 个数属于第 $j$ 段、当前这一段状态是“谷”、“升”、“峰”、“降”四种状态之一的最大答案。考虑方程：\n对于“谷”的转移：\n把 $a_i$ 融入这一段，仍然是谷。 $a_i$ 新开一段，上一段可能是降或峰。 所以 $f_{i,j,0}=-2a_i+\\max{f_{i-1,j,0},f_{i-1,j-1,3},f_{i-1,j-1,2} }$。 对于“升”的转移：\n把 $a_i$ 融入这一段，仍然是升。 $a_i$ 新开一段，上一段可能是谷或升。 所以 $f_{i,j,1}=\\max{f_{i-1,j-1,0},f_{i-1,j-1,1},f_{i-1,j,1} }$。 后面两种情况类比上面的两种情况。初始状态为 $f_{i,0,0/1/2/3}=0$，其余为无穷小。目标状态是 $f_{i,k,0/2}$。发现 $i$ 总是由 $i-1$ 转移而来，所以可以滚动压掉一维。\nLuogu P9128 [USACO23FEB] Fertilizing Pastures G\rMedium\n贪心。不用走回根节点的情况显然把深度最大的一条链留到最后再走。设 $sum_u$ 表示子树 $u$ 的点权和，$sz_u$ 表示子树大小。设 $f_u$ 表示零时刻在 $u$ 的最小代价。我们考虑访问子树的顺序使得 $f_u$ 最小。若 $u$ 的儿子为 $p_{1,\\dots,k}$，代价为：$\\sum\\limits_{i=1}^kf_{p_i}+sum_{p_i}+\\sum\\limits_{i=1}^k 2sum_{p_i}\\sum\\limits_{j\u0026lt;i} sz_{p_j}$。前面的 $\\sum$ 是确定的，后面的 $\\sum$ 取决于 $p$ 的顺序。我们考虑 $p_i$ 与 $p_{i+1}$ 交换是否更优。我们钦定排在前面的更优，那么有 $sum_{p_{i+1}}\\times sz_{p_i}\u0026lt;sum_{p_i}\\times sz_{p_{i+1}}$。按 $\\frac{sum_i}{sz_i}$ 降序排序得到的 $p$ 最优。\n对于可以不用回到根节点的询问，把有最长链的儿子放到最后，考虑变化量。\nLuogu P2737 [USACO4.1] 麦香牛块Beef McNuggets\rEasy\nDP。学到了一个 trick：在我们无法证明或不确定其正确性的时候，我们就大胆乱搞，程序能跑多少就跑多少，如果这个结论刚好被猜中，效益是很大的！解法：布尔完全背包。\nLuogu P2727 [USACO3.2] 01串 Stringsobits\rEasy\nDP。首先杨辉三角预处理出组合数，那么从高位枚举可不可以放 $1$，充要条件是 $\\sum\\limits_{j=0}^L \\binom{i-1}{j}\u0026gt;k$。边做边输出。\nLuogu P2732 [USACO3.3] 商店购物 Shopping Offers\rEasy\nDP。一定要相信自己的 idea！注意到商品数量极少，所以是五维完全背包 DP。如果不买这么多，可以看成是买 $0$ 个对应物品。\nLuogu P1930 [USACO3.3] 亚瑟王的宫殿\rEasy\nbfs。枚举汇集点，bfs 出每个马的最短步数。再枚举每个骑士 bfs 出国王在哪个点和骑士汇集。\n2024.11.1\r11 月了啊。\nLuogu P6100 [USACO19FEB] Painting the Barn G\rMedium\n差分 + DP。差分可以把区修变单修。再通过前缀和和起来得到原数组，对于 $k$ 和 $k-1$，前者覆盖后贡献为 $-1$，后者为 $1$。设 $h_{l,r}$ 为 $\\max\\limits_{i}s[i][l,r]$，设 $w_{l,r}$ 为 $\\max\\limits_{i}s[l,r][i]$（$s$ 是求和数组）。前者是限定了列，后者是限定了行。答案即为 $cnt+\\max\\limits_i{h_{1,i}+h_{i+1,200},w_{1,i}+w_{i+1,200} }$，$cnt$ 为原矩阵本来就等于 $k$ 的数量。\n2024.11.3\rLuogu P5839 [USACO19DEC] Moortal Cowmbat G\rMedium\nDP + 前缀和/前缀 $\\text{min}$ 优化。先跑一边 floyd 求最短路。设 $f_i$ 表示以 $i$ 结尾的连续段的最小代价。DP 方程易得：$f_i=\\min{ f_j+\\text{get}(j+1,i)}$，$\\text{get}$ 表示这一段都换成同一种颜色的最小代价。这里可以预处理前缀和 $O(1)$ 查询。设 $mn_j$ 表示颜色改为 $j$ 的最小代价（前缀 $\\text{min}$），可以 $O(1)$ 转移：$mn_j=\\min{mn_j+dis_{i,j},f_{i-k}+\\text{get}(i-k+1,i,j)}$，这里的 $\\text{get}$ 多传了颜色参数。\nLuogu P7054 [NWRRC2015] Graph\rMedium\n拓扑排序变种。要求字典序小相当于在用小根堆做拓扑。考虑当前入度为 $0$ 的点是否能被别的点连接，用大根堆存可以被连接的点。能被连接，充分条件是有一个比他大的节点且比他的访问顺序先（访问顺序后的节点再连会构成环）。以此来把当前入度为 $0$ 的点纳入可被连接的范畴。如果有剩，优先输出剩的；否则输出可被连接的。连边可以按拓扑序上一个连有向边，正确性显然的。\n2024.11.4\rLuogu P8990 [北大集训 2021] 小明的树\rHard\n线段树。视亮灯点为白点，不亮点为黑点。白点不好做，就考虑黑点。因为根节点始终为黑点，所以当满足限制时，黑点只构成一个连通块。怎么判断黑点只构成一个连通块？黑点数减“黑黑边”数就是黑连通块数。白连通块的数量本质上是“黑白边”的数量。有了这个结论，单次询问可以 $O(n)$ 维护“黑黑边”数、“黑白边”数和黑点数并得到结果。现在带修，一次修改查询只能在 $O(\\log)$ 内完成。自然想到对于每个时刻维护以上三值。先考虑一条边的断/连会对以上三值有什么影响（只考虑连的情况，断是等价的）。\n设 $t_x$ 表示点 $x$ 点亮的时刻，以下钦定一条边 $(x,y)$ 中 $t_x\u0026lt;t_y$。显然对于黑点数不会有影响。对于“黑黑边”数在 $[1,t_x-1]$ 会增一。对于“黑白边”数在 $[t_x,t_y-1]$ 会增一。由于维护黑点数和“黑黑边”数是为了得到黑连通块数，而其中一值不变，干脆直接维护黑连通块数与白连通块数。前者在 $[t_x,n-1]$ 会增一，后者在 $[t_x,t_y-1]$ 会增一。发现这两个东西都是区间维护，可以上线段树。具体地，维护黑连通块最小时大小、存在了几个时刻、以及当前区间黑连通块最小时的答案。\nLuogu P7124 [Ynoi2008] stcm\rMedium\n分治。先得到每个点的 dfn 序，那么一个点及其子树内的节点的编号是连续的。他的子树补就是 $[1,dfn_u-1]\\cup [dfn_u+sz_u,n]$。可以分治。对于当前分治区间 $[l,r]$，处理被 $mid$ 分开子树区间的点 $u$。暴力逼近点 $u$ 的子树区间，这个过程输出操作 1 的答案。然后再撤销以上操作 1，暴力将右端点逼近至 $mid-1$，然后递归分治左区间，同样输出，同样撤销；右区间同理。\n2024.11.6\rLuogu P2739 [USACO4.4] 棋盘游戏Shuttle Puzzle\rEasy\ndfs。注意不要写宽搜！剪枝是平凡的“深度大于等于最优答案”就回溯。对于优先级的问题搜索顺序调整一下即可。\n2024.11.11\r前面一周 3 天打了 5 场模拟赛把人打傻了，今天终于来刷题了。\nLuogu P6653 [YsOI2020] 造林\rMedium\n树型 DP + 哈希。“最大子树大小”可以自然想到找出整棵树的重心。以重心为根往下树型 DP。若在当前点 $u$ 下面接一个新的叶子节点，会发现只有当前点到根节点路径上的点的贡献没有加一。可以用一个哈希刻画所有节点贡献的情况，每次修改这个哈希来刻画当前状态。我们可以以不同贡献的数量来设计哈希。直白点就是用桶装贡献，然后把桶放进哈希里面。\nLuogu P7393 「TOCO Round 1」Eternal Star\rMedium\n构造。设最大值为根。若该节点点值为 $u$，那么他的儿子的点值分别为 $1,2,\\dots,u-1$。为了保证该点为 $u$，点值为 $i$ 的儿子的数量至少是 $u-i+1$。但是节点数有点过于多了，我们发现 $k$ 有两个值为 $k-1$ 的儿子。如果只保留一个，并把 $k-1$ 的子树构造成和根节点（值为 $k$）一模一样，那么即使 $k$ 和 $k-1$ 交换了树的形态本质相同。显然这样节点数变少了。\n2024.11.21\r前些天有的题为了赶业绩就没写复盘，所以一拖拖到 10 天才来写复盘。感觉刷题留痕很重要啊，距离 NOIP 也不到两周，业绩什么的先放一边，提升自己实力最为重要。谁知道 NOIP 后我是不是就直接 AFO 了。\n这几天重看了一下前面的复盘，一开始刷的题难度在蓝紫以上，中间也刷了一点绿蓝题。鉴别他们的最好办法就是看题解长度，长的就是比较难的，短的就是简单得一批。\nLuogu P1514 [NOIP2010 提高组] 引水入城\rEasy\nbfs + DP。沙漠点显然给峰顶供水即可，所以蓄水点能供给的沙漠点一定是一段区间（有解情况下）。可以通过 bfs 得到每个蓄水点供给沙漠点的个数。然后 DP 选最少的蓄水点使得区间覆盖所有沙漠点。平凡的 $f_{i,j}$ 表示考虑到第 $i$ 个蓄水点、最大右端点覆盖到 $j$ 的最小方案数。简单转移。\nLuogu P1967 [NOIP2013 提高组] 货车运输\rEasy\nKruskal 重构树 + 倍增 LCA。重构树有个性质就是所有叶子节点才是原图的点，其余的点都代表左右两棵子树的合并权值，所以两个叶子节点的 LCA 代表的权值就是这两个点在生成树上路径的瓶颈。所以可以快速解决此题。\nLuogu P1966 [NOIP2013 提高组] 火柴排队\rEasy\n树状数组。首先贪心的想最优匹配肯定是两个数组都从小到大排序后两两配对，那么可以得到 $c_i$ 表示 $a_i$ 与 $b_{c_i}$ 匹配（这里的 $a$，$b$ 数组均为排序前的数组）。题目要求邻项交换，直觉地想到求 $c_i$ 逆序对数量，套个树状数组就做完了。\n2024.11.22\rLuogu P5022 [NOIP2018 提高组] 旅行\rEasy\n模拟 + 贪心。观察数据范围发现图只有可能是树或基环树。树的情况直接贪心跑 dfs，因为树上到达一个点有且仅有一条路径，所以这样显然是对的。对于基环树我们可以对环考虑，边跑边考虑几个事情：\n要不要往当前节点的若干儿子的子树跑一跑 dfs。 要不要掉头换个方向跑环。 要注意，在掉头回去的时候要把路径上没跑过的儿子的子树全部跑完。因此选择掉头与否取决于下一个环上的点是否大于环起点另一方向的邻点与回溯时第一个要跑的儿子点。这种题没有什么思维含量，但是细节要考虑很多，稍不留神就会错一些情况。码量 3k，还好。时间复杂度 $O(n)$，可以过加强版，等价于切紫好耶。\n【NOIP 模拟 T1】\rMedium\n大意：有 $n$ 个人（$n$ 为偶数），要把他们分成人数相同的两组，人 $i$ 对该组的贡献为 $\\sum\\limits_{j\\in \\text{Team}} w_{i,j}$。（$i,j$ 是无序对）求两组可能的最大差距。（$n\\leq 10^3$）\n贪心。设当前分组为 $\\text{TA}$ 与 $\\text{TB}$，分组的值为 $A$、$B$，钦定 $A\u0026gt;B$。若交换不同组的 $x,y$ 两人，则答案由 $A-B$ 变为 $(A-\\sum\\limits_{i\\in \\text{TA}}w_{x,i}+\\sum\\limits_{i\\in \\text{TA}} w_{y,i})-(B-\\sum\\limits_{i\\in \\text{TB}}w_{y,i}+\\sum\\limits_{i\\in \\text{TB}}w_{x,i})$。设 $sum_i=\\sum\\limits_{j=1}^n w_{i,j}$，上式即为 $A-B+sum_y-sum_x$。我们想让交换后答案变大，要保证 $sum_y\u0026gt;sum_x$，所以直接排序，前面一半一组，后面一半一组。答案即为两组的权值差的绝对值除以 $2$（因为 $i,j$ 无序）。\nARC017D\rMedium\n线段树 + 更相减损术。首先有结论：\n$$\\gcd (a_l,\\dots,a_r)=\\gcd (a_l,|a_{l+2}-a_{l+1}|,\\dots,|a_{r-1}-a_{r-2}|,|a_r-a_{r-1}|)$$ 维护差分数组，答案即为 $\\gcd (\\sum\\limits_{i=1}^l d_i,\\gcd(|d_{l+1}|,\\dots,|d_r|))$。线段树维护区间和与区间 $\\gcd$。\nLuogu P2300 合并神犇\rMedium\n单调队列优化 DP。设 $f_i$ 表示 $[1,i]$ 处理成单调不降序列的最小合并次数，$pre_i$ 表示 $[1,i]$ 最末尾的数。找到一个 $j$ 使得 $sum_i-sum_j\\geq pre_j$ 并且 $f_i$ 和 $pre_i$ 尽量小，转移 $f_i=f_j+i-j+1$、$pre_i=sum_i-sum_j$。\n考虑单调性。$pre_i$ 显然随 $j$ 增大而减小。$f_i$ 受 $f_j-j$ 影响，考虑邻项：$f_j-j$ 与 $f_{j-1}-(j-1)$。假设前者小于等于后者，移项得 $f_j-f_{j-1}\\leq j-(j-1)=1$。由定义得假设成立，所以 $f_i$ 随 $j$ 增大而减小。\n用单调队列优化，单调队列维护 $sum_i-pre_i$。由于上面的推导，最优决策是最大的满足条件的 $j$。这也是去除单调队列开头的条件。\n若现在有 $sum_j-pre_j\\leq sum_k-pre_k=q_r$，由于 $k\u0026lt;j$ 所以 $sum_j\u0026gt;sum_k$，所以 $pre_j\u0026lt;pre_k$，所以果断退队尾。\nARC069E\rEasy\n扫描线（？） + 离散化。假想一条线从高到底往下扫，扫到一个或多个就取最左边的下标累计答案，然后把扫到的高度都下降一。值域大可以离散化，累计答案时需要一个数组映射离散化后的高度原来的值。\nARC055C\rEasy\n字符串哈希 + 二分。需要 $O(1)$ 得到一段区间信息的题要想到字符串哈希。首先 $O(n)$ 枚举最右边“AC”的左端点 $i$，然后二分哈希得到最长的第一个“A”的右端点（二分条件是第一个“A”与“AC”的“A”相同），再二分哈希得到最短的第一个“A”的右端点（二分条件是“ABC”的“C”与“AC”的“C”相同）。那么当前这个“AC”的方案数为“右端点 - 左端点 + 1”。时间复杂度 $O(n\\log n)$。\n2024.11.23\r模拟赛又 tm 爆零了，明明昨晚才切了两道蓝题。果然还是提升得不够快。希望 NOIP 正式赛可以发挥出来吧。\nLuogu P4107 [HEOI2015] 兔子与樱花\rEasy\n贪心。自底向上按 $son_i+c_i$ 的顺序从小到大贪心删除一定最优。感性证明：对于排序，一定是选最小的儿子删掉不会劣；对于自底向上，如果点 $u$ 的儿子 $v$ 因为删了 $v$ 的儿子节点而导致不能删 $u$，发现不能被删的只有一个点 $u$，但是 $v$ 删掉的是至少一个 $v$ 的儿子节点。\n2024.11.25\rARC106D\rMedium\n二项式定理。又忘记二项式定理了，一定要记住！！记录一下：$(a+b)^n=\\sum\\limits_{i=0}^n\\binom{n}{i}a^{n-i}b^i$。这道题是推式子：\n$$\r\\begin{aligned}\r\\sum\\limits_{l=1}^{n-1}\\sum\\limits_{r=l+1}^n (a_l+a_r)^x\r\u0026=\\frac{\\sum\\limits_{l=1}^n\\sum\\limits_{r=1}^n(a_l+a_r)^x-\\sum\\limits_{p=1}^n(2a_p)^x}{2}\r\\end{aligned}\r$$ 分子后面好做，推前面那个：\n$$\r\\begin{aligned}\r\\sum\\limits_{l=1}^n\\sum\\limits_{r=1}^n(a_l+a_r)^x\u0026=\\sum\\limits_{i=0}^x\\binom{x}{i}\\sum\\limits_{l=1}^na_l^{x-i}\\sum\\limits_{r=1}^na_r^i\r\\end{aligned}\r$$ 这样就好做了。$\\mathcal{O}(nk)$。\n","date":"2024-10-30T09:14:00+08:00","permalink":"https://werchange.github.io/p/%E7%BD%AE%E9%A1%B6%E4%B8%80%E7%9B%B4%E6%9B%B4%E6%96%B0%E4%B8%AD%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/","title":"[置顶][一直更新中]一句话题解"},{"content":"\nCSP-S2024 游记\r前言\r去年这个时候在写 J/S 的总结。初三，300/130，这个成绩如何不写总结？\n今年高一了，只考 S 组，感觉实力有所提升但还是存在一点问题，\nDay 0\ranalysis 教了我如何在 windows 下配置 vscode，希望考场上也能成功配置吧。\n周五晚 21：00 回家。在此之前一直在复习模板（kmp、tarjan、点双、边双、平衡树、文艺平衡树、prim 最小生成树、kruskal 重构树、瓶颈路），想看一眼笛卡尔树，同舍生说考也是考思想，不过我赛场就算看出来也不一定想得到，所以不去学了。\n然后打点双、边双。点双之前写过，发现学得就是依托答辩，重学了一遍后 A 了。但是边双之前就没 A 过，想破头了也没调出来，又到 21：00 了着急回家，根本调不出来，后来 analysis 提醒是不能走上一条边而不是不能走上一个点，我就改了一下建边方式，该改就过了。发现这道题的测试点返回信息居然是“CSP/NOIPRP++”！爽啦！回家！\n回家前提醒了一下不回家的初中同学，叮嘱他们 S 组一定要打暴力 \u0026amp; 部分分（初二就过 S 组初赛了也是膜拜 Orz）。\n到家了，简单刷新了一下信息差。忘记电脑被我姐带走了，遂放弃复习。洗澡的时候一直在发抖，估计是肾上腺素持续分泌，一直想着去年 130 滚粗 NOIP 的黑历史，脑中有声音在回响起：“我现在或是千千万万个明天会遗憾的我穿越而来，而明天还有一次翻盘的机会。”想到这个好受很多了，睡前因为肾上腺素已经分泌完了，所以闷头就睡。\nDay 0.5\r上午是 J 组，不用考，因为没电脑了，所以愉快去喝茶。喝茶的时候一直在刷 B 站，到了 12：00 出发的时候才在车上不紧不慢的复习昨天复习过的内容，已经紧张不起来了，很自然。\n车到了，还有半小时到教练约定时间，在车上眯了一会儿，虽然已经到不知道有没有睡着的地步了。\n到了 JZ 校门，遇到了 analysis 和小赵老师，听小赵老师说 J 组考了 300 分，膜拜 Orz，初一的时候我还没过 J 组初赛（汗）。\n到了之后发现他们早就到了。发现圣人穿大红衣服，被逗笑了，膜拜完后就去拍大合影了，教练和 moriartys 在旁边，RP++！\nDay 0.9999\r先拿出手机拍几张 JZ 风景，历史名校的风景还是不错的。除了有些老旧之外，但这也是时间留下的痕迹。\n这一次是第三次来这里考 CSP 了，紧张多少是有的，但是毕竟高一了，稳重了很多，决定先去上个厕所。上完厕所后等待进场，人有点多就在队伍外先等着，我们学校的大多在统一考场，所以等待的时候又在东扯西扯，放松了很多。\n进场，座位号 01，当门神了。DSS 在我右边的右边，膜拜膜拜。飞速填完承诺书之类，旁边有个桌子可以放风衣，太棒了。\nDay 1\r开考的时候还没有 PDF（破大防）密码，我原来的计划也不是先开题，而是先去配置 vscode。很顺利，在听到两三声键盘声的时候已经跑起来 a+b 了。浅浅庆祝一手这次可以用 vscode 写代码啦！码速 ++。\n刚好过 14：30（因为提前 3 分钟开始、提前 3 分钟结束），此时建文件夹 checker 就不会显示时间错误。\n大概完活后已经听到大部分人开始打代码了，当然也有可能是像我一样建文件夹。看 T1 先看数据范围，发现 $O(n\\log n)$，有点害怕之后看了题面。读懂之后发现简单贪心，写了 sort 之后就大概写完了（埋下伏笔），大样例跑得飞快。这时有点害怕，担心考试快结束时我会选择冲其他题而不来检查 T1，所以反反复复检查了好久才走。\nT2 发现 $O(n^2)$ 有 60 分，觉得打个暴力方便对拍没啥不好，所以开码，途中出了很多问题，调调调，不知不觉就用完了 T1 的富余时间与 T2 的期望时间。我想了一下 $O(n)$ 该怎么做，或者带个 $\\log$，但是太紧张了，脑筋转不起来。况且我是门神，看见上厕所的人进进出出，尤其是我们学校的回来，有人淡定有人着急，让我产生都切了 T2 的错觉（事实上也是如此），加上去年因为死磕 T2 而 130 二等滚粗 NOIP 的黑历史，我真的淡定不下来想 T2 正解了。检查了文操后作好 T2 最终可能也只有 60 的准备，遂开 T3。\nT3 发现一个很妙的性质，“很妙”是赛后别人游记评价的，当时沿着这个去思考，想着打 50 分 DP 很有前途，这样的话总分也有机会上 200+。但是 DP 想不出来，依着前面的性质打了个贪心，贪心还用上了线段树。打打打，过了小样例，测大样例的时候发现贪心正确率是很高的，但是总有几个过不去，我仔细研究了一下，发现贪心的做法会引出一系列问题，而这些问题都是不太好做的。理应来说我应该想到：贪心有局限的问题，绝大部分是可以用 DP 解决的。可是没想到。上了考场很多经验主义的东西完全记不起来了。还是要锻炼心态。\nT4 一看是个很毒瘤的题，实际上我的开题顺序是 1、2、4、3，因为我期望着 T4 会比 T3 简单。难的话也可以先打暴力然后直接冲 T2、T3，总之这个决策是上上策，对于当时情况而言。仔细读了很多遍题意后捋清了题目要求，中途去上了个厕所平复心情。回来再随便调调就过了小样例，发现 $2$ 的幂的性质容易做，就优化了一下，又过了一个大样例。后面想破头也想不出来了，初步判断这道题就是毒瘤，遂放弃。\n又回到 T3，一直在想 50 分的我决定想像容易一档的，结果除了最简单的一档什么也想不到，这个时候快 18：00 了，打完 dfs 就跑路了。算了一下当前 $100+60+20+20=200$，其实较往年肯定是有进步了，但不多，而且尚不知道今年是不是过于简单。更何况在正式赛中永远不要预测一等线，要激发自己最大的潜能，突破自己的极限。所以跑去检查 T1，顺带看看 T2 能不能抠一点性质分。\nT1 发现一个诡异性质 A：“保证所有 $r_i$ 在范围内随机生成”，这个还不是最后一档的性质！他不会要卡我 sort 吧？我记得 sort 是可以被有序序列卡成 $O(n^2)$ 的，我马上精神起来，想着要不要打个稳定的归并，但是又怕打挂，就换了时间复杂度稳定一只 $\\log$ 的优先队列排序。飞速测完大样例后就跑了，长舒一口气。\nT2 发现只有匀速的话可以做到 $O(n)$！好耶抠出来 10 分，其他的怎么也扣不出来遂转 T3。\nT3 想着优化 dfs，但是这个完全没办法优化，想想别的做法，但此时离结束只剩 10 min 左右，是做还是检查？我摇摆了。\n先去 T4 看看，确认 20 分可以稳稳到手后又多打了一点，运气好的话可以多抠出来 12 分，那总分就 222 了。\n回 T3，放弃了，我不敢预测今年的一等线，哪怕我现在也没有计划再冲刺最后一点分数。\n结束的时候反复确认文操、文件名、checker 了一遍又一边，在结束前三分钟删掉了 .vscode 配置文件夹。少有的回到桌面等待仅剩的 1min 结束。此时还有人在冲刺啊，我在 01 座位，啥也看不到，只能靠听到的猜测别人的状态。\n我看向了门外，我在考前 3min 等待的时候就看过一次门外，门上有一条横梁，我想着关上门后没有横梁遮挡那风景应该还是很不错的。现在再看发现整场考试没有一次看过门外，唯有出去小便的时候看了一眼晚霞又匆匆回去。\n天黑了。\n上一次也是这样，只不过一年前我还和现在正在码代码的人一样，在冲 T2。即使最后只落了个 30 分。那时是无尽的空虚与自责，现在是什么感情呢？我不知道。\n出来后强者们都说炸了，我觉得还是不听为妙，匆匆拿包下楼，下到 2 楼想上厕所，就去了 3 楼。在厕所遇到圣人，问他是不是切 3，他说“你怎么知道”。我笑笑，情理之中，膜拜膜拜。\n走到半路发现忘记拿表了，又跑回去考场拿表，那里就剩我的表了。路上朱熹问“有没有切 3？”，我说“没有。”，“有没有切 2？”，“没有。”，“6。”唉，这架势肯定 T2 是人均题了，但我来不及感叹惋惜，一是 NOIP 是最重要的，这一次失误并不能决定什么，二是已经下了点小雨，我得赶紧走了。\n回家路上跟家人解释了信息学到底考什么诸如此类的问题。我又说估分 $[210,222]$，希望有 222 吧。\n晚上吃饭的时候 ccx 问我 T2 怎么做，我跟他说了我的 $O(n^2)$ 做法，他举了个范例。然后就鱼鱼蒸，饭不香了。\nDay 2\r第二天喝茶没有刷手机，花了 10min 想了想昨晚的反例，这个是抽象出来的例子，的确能卡掉我但他不符合题意呀！去问了问朱熹，获得肯定，又有机会上 200+ 啦，开心～\n返校后大家讨论高一人均 250 分，唉，我实力还是不够强啊。\nDay inf\r出分了，$100+70+20+20=210$，一分没挂。同舍生有 3 个 $250\\to 200$ 的，我就混到了同校高一 rk6，运气加成吧。\n最高 293，是朱熹，果然还得是朱熹。初三 lwq 是 300，属实被单调队列了，膜拜膜拜。\n不知道 210 有没有一等，教练说初中生 NOIP 体验名额好像都要 220，听到这个直接鱼鱼蒸。\n希望有一等吧，即使 CSP 一等不是决定性般的重要。\nFuture\r主要是展望与总结：\n去年总结我的问题是思维方式陷入怪圈，但是一年的训练后我的实力仍然没有发挥到最好（也有可能就是变菜了），说明不能空谈思维方式，更要结合海量题目来训练思维。 考场状态必须要锻炼好，即使没有超常发挥也要保证能发挥正常水平，而不是像模拟赛那样的烂水平。 刷题必须注重质量而非数量，如果不加思考或思考甚少的做题不如认真思考后才做出来一道题。前者甚至会养成惰性思维模式，只会想着看题解，没有任何提升反而“负提升”。往后训练要做题前先认真思考 20min 再决定还要不要再想，实在没思路再开题解。 刷题留痕。每道题做出来后一定要写总结，要分清受众是自己而不是别人，不是给别人看的就不要这么详细，要符合自己的脑回路，越简洁越好。 根据这么久的训练，我初步判断我是属于上下限均不稳定的人，分数时高时低，有些难题很有思路、有些简单题一点思路没有。那我不应该只注重于某一场模拟赛的成败，也不应该随意的界定自己的上限。我本来就不属于天赋选手，但拼到现在还有机会参加 NOIP 甚至省选，说明我要对自己有一定的信心，哪怕没有小说中的黑马逆袭，也能混到一个中等乃至中上（至少现在是掉车尾了），关键在于平日的训练与检验。 截止今天（11.4）还有 26 天 NOIP，那个才是至关重要的，希望是拿到省一并且分数有 250+。希望吧。努力吧。 ","date":"2024-11-04T22:31:00+08:00","permalink":"https://werchange.github.io/p/csp-s2024-%E6%B8%B8%E8%AE%B0/","title":"CSP-S2024 游记"},{"content":"\nYAMAYA 题解\r题目大意\r$n$ 个小夫坐成一排，每个小夫有一个真实值 $v_i$。小夫们有 $m$ 场聚会，第 $i$ 次聚会会在编号为 $[l_i, r_i]$ 的小夫中举办。\n聚会之后，这些小夫的真实值会变为他们之中的真实值的最大值。将会发生 $q$ 次事件，有两类事件。\n第一类事件，第 $x$ 个小夫的真实值变成了 $y$。 第二类事件，小夫们向你提问，假如第 $L$ 次聚会到第 $R$ 次聚会按顺序举办，第 $x$ 个小夫的真实值会变成多少。 Solution\r鲜花：\n这道题纯恶心，不可爱。\n也有可能只是我太菜了。:(\n正解：\n比较显然的一点是：$q$ 次询问中，记一次询问的 $x$ 为 $[x,x]$，而后从 $R$ 到 $L$ 枚举每个操作区间，如果区间 $[l_i,r_i]$ 有交，就取两区间的并，最后就将一个点 $[x,x]$ 扩展成了一个区间 $[l,r]$。$x$ 的真实值就是 $[l,r]$ 之间的最大值。\n对于 $m$ 次操作，分别对 $l$ 和 $r$ 维护上一次受影响的操作编号。\n以维护 $l$ 举例：当前枚举到第 $i$ 次的 $l_i$，去找一个最大的 $j\\ (j\\leq i-1)$ 使得 $l_i\\in [l_j,r_j]$。我们用 $pre_i$ 来记录这个 $j$。（下文出现的 $nxt$ 同理维护 $r$）\n现在你已经懂这个啦，但是我们不满足于知道 $i$ 的上一个，我们还想知道 $i$ 的上 $2^k$ 个。这个倍增很好搞，这里不提了。\n在维护 $pre$ 与 $nxt$ 的同时，我们顺带记录 $q$ 次查询中每个 $x$ 的被影响的初值。具体的，当前枚举到第 $i$ 次操作，那么对于所有 $R_j=r_i\\ (j\\in [1,q])$ 的查询来说，操作已然做完了，我们就可以得到最后影响 $x_j$ 的是哪个 $k\\ (k\\leq i)$，我们令它为 $id_j$。这里可以用区修区查最大值线段树维护。\n得到每个 $i\\in [1,q]$ 的初值 $id_i$ 后（这里的 $i$ 只讨论 $op_i=2$，上下文都是），就可以拓展区间了。\n怎么跑呢？倍增跑就好了~\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define ls rt\u0026lt;\u0026lt;1 #define rs ls|1 #define mid ((l+r)\u0026gt;\u0026gt;1) const int N=5e5+5; int n,m,q; struct node { int op,l,r,x; }a[N],b[N]; int v[N]; vector\u0026lt;int\u0026gt; Q[N]; int tr[N\u0026lt;\u0026lt;2],lz[N\u0026lt;\u0026lt;2],Id[N]; int pre[N][30],nxt[N][30]; void pushup(int rt) { tr[rt]=max(tr[ls],tr[rs]); } void build(int rt,int l,int r) { lz[rt]=0; if(l==r) return tr[rt]=v[l],void(); build(ls,l,mid),build(rs,mid+1,r); pushup(rt); } void pushdown(int rt) { tr[ls]=max(tr[ls],lz[rt]); lz[ls]=max(lz[ls],lz[rt]); tr[rs]=max(tr[rs],lz[rt]); lz[rs]=max(lz[rs],lz[rt]); } void upd(int rt,int l,int r,int lf,int rg,int x) { if(lf\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=rg) return tr[rt]=lz[rt]=x,void(); if(lf\u0026gt;r||l\u0026gt;rg) return; pushdown(rt); if(lf\u0026lt;=mid) upd(ls,l,mid,lf,rg,x); if(mid\u0026lt;rg) upd(rs,mid+1,r,lf,rg,x); pushup(rt); } int qry(int rt,int l,int r,int lf,int rg) { if(lf\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=rg) return tr[rt]; if(lf\u0026gt;r||l\u0026gt;rg) return 0; int res=0; pushdown(rt); if(lf\u0026lt;=mid) res=qry(ls,l,mid,lf,rg); if(mid\u0026lt;rg) res=max(res,qry(rs,mid+1,r,lf,rg)); return res; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;v[i]); for(int i=1;i\u0026lt;=m;i++) scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;b[i].l,\u0026amp;b[i].r); scanf(\u0026#34;%lld\u0026#34;,\u0026amp;q); for(int i=1;i\u0026lt;=q;i++){ scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;a[i].op,\u0026amp;a[i].l,\u0026amp;a[i].r); if(a[i].op==2) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i].x),Q[a[i].r].emplace_back(i); } for(int i=1;i\u0026lt;=m;i++){ pre[i][0]=qry(1,1,n,b[i].l,b[i].l); nxt[i][0]=qry(1,1,n,b[i].r,b[i].r); upd(1,1,n,b[i].l,b[i].r,i); for(int j:Q[i]) Id[j]=qry(1,1,n,a[j].x,a[j].x); } for(int j=1;j\u0026lt;=21;j++) for(int i=1;i\u0026lt;=m;i++){ pre[i][j]=pre[pre[i][j-1]][j-1]; nxt[i][j]=nxt[nxt[i][j-1]][j-1]; } build(1,1,n); for(int i=1;i\u0026lt;=q;i++){ if(a[i].op==1){ upd(1,1,n,a[i].l,a[i].l,a[i].r); v[a[i].l]=a[i].r; continue; } if(Id[i]\u0026lt;a[i].l){ printf(\u0026#34;%lld\\n\u0026#34;,v[a[i].x]); continue; } int l=Id[i],r=Id[i]; for(int j=21;~j;j--){ if(pre[l][j]\u0026gt;=a[i].l) l=pre[l][j]; if(nxt[r][j]\u0026gt;=a[i].l) r=nxt[r][j]; } printf(\u0026#34;%lld\\n\u0026#34;,qry(1,1,n,b[l].l,b[r].r)); } return 0; } ","date":"2024-10-16T15:02:00+08:00","permalink":"https://werchange.github.io/p/tamaya-%E9%A2%98%E8%A7%A3/","title":"TAMAYA 题解"},{"content":"\n[POI2008] BLO-Blockade 题解\r题目大意\r[POI2008] BLO-Blockade\nSolution\r鲜花：\n加深了对 tarjan 的理解：\ntarjan 本质上就是一个 dfs。 $low_u$ 一定不大于 $dfn_u$。 正解：\n分析断开的点是不是割点。\n如果不是割点，那么剩余图仍然联通，贡献为 $2(n-1)$。\n如果是割点，那么图会被分为 $k$ 个连通块，贡献为：\n$$\r2(n-1)+\\sum\\limits_{i=1}^k\\sum\\limits_{j=1}^k siz_i\\times siz_j\r$$ 搞掉第二个 $\\sum$：\n$$\r2(n-1)+\\sum\\limits_{i=1}^k siz_i\\times (n-siz_i-1)\r$$ 在实现中，如果遇到儿子不存在返租边（$low_v\\geq dfn_u$），则可以考虑子树连通块的贡献。最后记得计算子树内外的点形成点对产生的贡献（$(n-\\sum\\limits_{i\\in son_u} siz_i -1)\\times \\sum\\limits_{i\\in son_u} siz_i$）和该点和所有点形成点对的贡献（$n-1$）。\n最后因为是有序对所以记得乘 2。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=5e5+5; int n,m; vector\u0026lt;int\u0026gt; G[N]; int dfn[N],low[N],tim,sz[N],ans[N]; void tarjan(int u) { dfn[u]=low[u]=++tim; sz[u]=1; int siz=0; for(int v:G[u]){ if(!dfn[v]){ tarjan(v); sz[u]+=sz[v]; low[u]=min(low[u],low[v]); if(low[v]\u0026gt;=dfn[u]){ ans[u]+=sz[v]*siz; siz+=sz[v]; } }else low[u]=min(low[u],dfn[v]); } ans[u]+=(n-siz-1)*siz+n-1; } signed main() { ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1,u,v;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].push_back(v); G[v].push_back(u); } tarjan(1); for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;ans[i]*2\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return 0; } ","date":"2024-10-05T10:37:00+08:00","permalink":"https://werchange.github.io/p/poi2008-blo-blockade-%E9%A2%98%E8%A7%A3/","title":"[POI2008] BLO-Blockade 题解"},{"content":"\n「EZEC-8」猜树 加强版 题解\r题目大意\rP7597 「EZEC-8」猜树 加强版\nSolution\r鲜花：\n第二次做交互题，第一次太久远了，发现这种题目还挺有意思的。\n感觉这道题不是特别难，虽然不是自己想出来的，但是感觉很容易懂欸。\n正解：\n首先花费 $n-1$ 次操作一搞到每个节点的深度。\n然后想一个事情，这个题目要求我们在 $O(n\\log n)$ 内完成，可是一棵树怎么做到 $O(n\\log n)$ 呢？受到重链剖分、dsu on tree 的启发，我们联想到可以找每个节点的重儿子。\n找他有什么用呢？再想另一个事：如果节点 $u$ 的兄弟节点都已经确定他们的子树内有什么节点了，并且已知节点 $u$ 父亲子树内的所有节点，那么显然剩下的点就是 $u$ 的子树内的节点。\n我们可以用操作二来获取某点子树信息。而搭配刚刚思考的内容，我们可以省下一个节点的询问。\n我们当然希望这个节点的子树大小越大越好，这样就可以省下很多花费。所以自然而然的想到找重儿子。因为 $\\sum siz_i-siz_{heavyson_i}$ 是 $O(n\\log n)$ 级别的。\n现在我们怎么从一个不清楚结构的树内找一个重儿子呢？\n所以我们要用上万能的随机化！\n因为重儿子的子树大小是他的兄弟节点中最大的，所以我们随机到一个点是重儿子的子孙的概率是最大的。\n问题是随机几个节点呢？随机一个就好了。\n我们来细嗦一下随机的情况：\n首先大概率是随机到了重儿子的子孙，这样我们可以找到正确的重儿子，时间复杂度有保证。\n其次是小概率没随机到重儿子，相当于我们搞混了轻重儿子。可是时间复杂度的退化需要重儿子特别特别“重”，节省掉的花费非常非常“少”，唯有这样才会退化十分严重。可是这种情况我们大概率随机到的是正确的重儿子，而不是轻儿子。\n总结一下\r如果想卡我随机化错误（搞混轻重儿子），他只需要将我错误的代价搞得很大很大（让重儿子尽可能重），可是这个代价越大，我就越不会犯错误（重儿子越重，我随机到的点是他的子孙的可能越大）；如果他把轻重儿子子树大小搞得差不多，那我也不需要那么严谨的区分轻重儿子，因为我的目的只是达到 $O(n\\log n)$ 量级。\n双倍经验（其实是弱化版）：P7595 「EZEC-8」猜树\n代码\r小知识：为什么我没有用 fflush(stdout)，那是因为 endl 内部就有重载缓冲区。这也是 cout\u0026lt;\u0026lt;endl 会比 cout\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot; 稍慢的原因。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=5e3+5; int n,dep[N],fa[N]; int son[N]; bool vis[N]; vector\u0026lt;int\u0026gt; G[N]; mt19937 rnd(time(0)); void dfs(int u) { if(G[u].empty()) return; random_shuffle(G[u].begin(),G[u].end()); int tmp=G[u][rnd()%G[u].size()]; for(int v:G[u]){ if(dep[v]!=dep[u]+1) continue; int dis; if(v==tmp) dis=0; else{ cout\u0026lt;\u0026lt;\u0026#34;? 1 \u0026#34;\u0026lt;\u0026lt;tmp\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;dis; } if(dis==dep[tmp]-dep[v]){ son[u]=v; break; } } for(int v:G[u]) vis[v]=0; for(int v:G[u]){ if(v==son[u]||dep[v]!=dep[u]+1) continue; cout\u0026lt;\u0026lt;\u0026#34;? 2 \u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; int siz,x; cin\u0026gt;\u0026gt;siz; for(int i=1;i\u0026lt;=siz;i++){ cin\u0026gt;\u0026gt;x; if(v!=x) G[v].push_back(x),vis[x]=1; } } for(int v:G[u]){ if(dep[v]!=dep[u]+1\u0026amp;\u0026amp;!vis[v]) G[son[u]].push_back(v); } for(int v:G[u]){ if(dep[v]==dep[u]+1){ fa[v]=u; dfs(v); } } } signed main() { cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;? 1 1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;dep[i]; G[1].push_back(i); } dfs(1); cout\u0026lt;\u0026lt;\u0026#34;!\u0026#34;; for(int i=2;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;fa[i]; cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2024-10-05T09:07:00+08:00","permalink":"https://werchange.github.io/p/ezec-8%E7%8C%9C%E6%A0%91-%E5%8A%A0%E5%BC%BA%E7%89%88-%E9%A2%98%E8%A7%A3/","title":"「EZEC-8」猜树 加强版 题解"},{"content":"\n[省选联考 2020 A/B 卷] 冰火战士 题解\r题目大意\r[省选联考 2020 A/B 卷] 冰火战士\nSolution\r鲜花：\n这个题目 $n\\leq 2\\cdot 10^6$ 限制 3s 复杂度石锤 $O(n\\log n)$。正解是树状数组 + 离散化什么的。\n但是我不会，就翻了翻讨论区，看到暴力踩标算的做法。时间复杂度我也不会证，但是感觉上均摊 $O(n\\log n)$。\n正（假）解：\n先讲 $O(n\\log^2 n)$ 的朴素二分套树状数组。聪明的你发现了题目就是求：尽可能大的两支队伍能参赛的人的能量总和的最小值。\n说白了就是找最好的温度，使得两支队伍参赛的人尽量多，致使能量也尽量多，最后导致最小值最大。\n如果以温度为横轴、小队能量和为纵轴，发现火队的图像是下降的、冰队的图像是上升的。\n我们希望最小值最大，就找到那个点。\n这个过程用二分去找，check 就需要前缀/后缀和，需要树状数组。\n然鹅是 $O(n\\log^2 n)$ 的，只有 60pts……\n于是我们考虑正解暴力。\n这个暴力具体的就是从上一个温度向左或向右找最优点，离散化一下温度就好了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=2e6+5; int n,Q; struct node { int op,t,x,y; }q[N]; int cnt,tmp[N]; int A[N],B[N]; int suma,sumb; signed main() { ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); cin\u0026gt;\u0026gt;Q; for(int i=1;i\u0026lt;=Q;i++){ cin\u0026gt;\u0026gt;q[i].op\u0026gt;\u0026gt;q[i].t; if(q[i].op==1) cin\u0026gt;\u0026gt;q[i].x\u0026gt;\u0026gt;q[i].y,tmp[++cnt]=q[i].x; } sort(tmp+1,tmp+cnt+1); cnt=unique(tmp+1,tmp+cnt+1)-tmp-1; for(int i=1;i\u0026lt;=Q;i++) if(q[i].op==1) q[i].x=lower_bound(tmp+1,tmp+cnt+1,q[i].x)-tmp; int t=0; for(int i=1;i\u0026lt;=Q;i++){ if(q[i].op==1){ if(q[i].t==0){ A[q[i].x]+=q[i].y; if(q[i].x\u0026lt;=t) suma+=q[i].y; }else{ B[q[i].x]+=q[i].y; if(q[i].x\u0026gt;=t) sumb+=q[i].y; } }else{ int k=q[i].t; if(q[k].t==0){ A[q[k].x]-=q[k].y; if(q[k].x\u0026lt;=t) suma-=q[k].y; }else{ B[q[k].x]-=q[k].y; if(q[k].x\u0026gt;=t) sumb-=q[k].y; } } while(t\u0026gt;1\u0026amp;\u0026amp;min(suma-A[t],sumb+B[t-1])\u0026gt;=min(suma,sumb)){ suma-=A[t]; sumb+=B[--t]; } while(t\u0026lt;cnt\u0026amp;\u0026amp;min(suma+A[t+1],sumb-B[t])\u0026gt;=min(suma,sumb)){ sumb-=B[t]; suma+=A[++t]; } if(!suma||!sumb) puts(\u0026#34;Peace\u0026#34;); else printf(\u0026#34;%lld %lld\\n\u0026#34;,tmp[t],min(suma,sumb)*2); } return 0; } ","date":"2024-10-04T16:29:00+08:00","permalink":"https://werchange.github.io/p/%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-a/b-%E5%8D%B7-%E5%86%B0%E7%81%AB%E6%88%98%E5%A3%AB-%E9%A2%98%E8%A7%A3/","title":"[省选联考 2020 A/B 卷] 冰火战士 题解"},{"content":"\n[NOI1998] 免费的馅饼 题解\r题目大意\rP7302 [NOI1998] 免费的馅饼\nSolution\r鲜花：\n可爱数据结构优化带权 LIS。\n今天是可爱 @zswangziye 的生日捏~\n正解：\n首先暴力 DP 可以轻易推出：\n$$\rf_i=\\max\\limits_{2(t_i-t_j)\\geq |p_i-p_j|} f_j+v_i\r$$ 但是这个是 $O(n^2)$，受不鸟一点。\n灵机一动，这是个二维偏序啊，直接上树状数组维护。\n首先把这个条件拆掉绝对值吧：\n$$\r\\begin{align}\r2t_i-p_i\\geq 2t_j-p_j\\\\\r2t_i+p_i\\geq 2t_j+p_j\r\\end{align}\r$$ 发现只要同时满足这两个式子，就满足了 $2(t_i-t_j)\\geq |p_i-p_j|$。因为绝对值非负，所以一定满足 $t_i\\geq t_j$。\n那就可以以 $(1)$ 式排序，然后离散化 $(2)$ 的结果再用树状数组维护二维偏序。\n这样就能同时满足两式。\n劇終。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=2e5+5; int n,m; struct node { int t,p,v,l,r; }a[N]; int b[N],tr[N],f[N],tot; void upd(int x,int k){ for(;x\u0026lt;=tot;x+=x\u0026amp;-x) tr[x]=max(tr[x],k); } int qry(int x,int k=0){ for(;x;x-=x\u0026amp;-x) k=max(k,tr[x]); return k; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++){ int t,p,v; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;t,\u0026amp;p,\u0026amp;v); a[i]={t,p,v,2*t-p,2*t+p}; b[i]=2*t+p; } sort(b+1,b+m+1); tot=unique(b+1,b+m+1)-b-1; for(int i=1;i\u0026lt;=m;i++) a[i].r=lower_bound(b+1,b+tot+1,a[i].r)-b; sort(a+1,a+m+1,[](node x,node y){ return x.l\u0026lt;y.l; }); for(int i=1;i\u0026lt;=m;i++){ int tmp=qry(a[i].r); upd(a[i].r,tmp+a[i].v); } printf(\u0026#34;%lld\\n\u0026#34;,qry(tot)); return 0; } ","date":"2024-09-29T11:35:00+08:00","permalink":"https://werchange.github.io/p/noi1998-%E5%85%8D%E8%B4%B9%E7%9A%84%E9%A6%85%E9%A5%BC-%E9%A2%98%E8%A7%A3/","title":"[NOI1998] 免费的馅饼 题解"},{"content":"\nP4949 最短距离 题解\r题目大意\rP4949 最短距离\nSolution\r鲜花：萌萌树剖题。\n我这么水的人都手切这道题了，那肯定是道水紫吧。\n正解：\n首先如果给出的图只有 $n-1$ 条边，那就是棵树，那这题就是个树剖 RMQ 板子。\n但是给出的图有 $n$ 条边，只比树多出一条边，构成了一棵基环树。这样就不是板子中的板子了（尽管还是很水）。\n直觉的想法是把环上一条边暂时删掉，剩下的点又重新变成一棵树。\n但是我不会啊。\n其实是我马上想到了另一种方法：我们把环上挂着的子树用树剖处理 RMQ，环上的点再用树状数组搞一下 RMQ。到这里就完了。\n还是细讲一下吧。\n首先我们拓扑一下把环上的点搞出来，接着对这些点的子树都树剖处理（这里不用开多棵线段树，发现节点编号都不一样，而一棵子树的 dfn 序号都是连续的，所以可以共用一棵线段树）。\n然后去 dfs 处理环上的边权，再搞进树状数组里。\n查询的时候注意一下是否在同一棵子树、环上两种方向的贡献……\n劇終。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second #define mid ((l+r)\u0026gt;\u0026gt;1) #define ls rt\u0026lt;\u0026lt;1 #define rs ls|1 const int N=2e5+5; int n,m; vector\u0026lt;pii\u0026gt; G[N]; vector\u0026lt;int\u0026gt; Ring; int deg[N],a[N]; int sz[N],dep[N],fa[N],Rt[N],son[N],dfn[N],Id[N],tim,top[N]; int tr[N\u0026lt;\u0026lt;2]; struct edge { int u,v,w; }E[N]; int val[N]; bool vis[N]; void dfs1(int u,int pa,int root) { dep[u]=dep[fa[u]=pa]+(sz[u]=1); Rt[u]=root; for(pii i:G[u]){ if(i.ft==pa||deg[i.ft]\u0026gt;0) continue; int v=i.ft; a[v]=i.sd; dfs1(v,u,root); sz[u]+=sz[v]; if(sz[son[u]]\u0026lt;sz[v]) son[u]=v; } } void dfs2(int u,int tp) { Id[dfn[u]=++tim]=u; top[u]=tp; if(!son[u]) return; dfs2(son[u],tp); for(pii i:G[u]) if(i.ft!=fa[u]\u0026amp;\u0026amp;i.ft!=son[u]\u0026amp;\u0026amp;deg[i.ft]\u0026lt;=0) dfs2(i.ft,i.ft); } void pushup(int rt) { tr[rt]=tr[ls]+tr[rs]; } void build(int rt,int l,int r) { if(l==r){ if(deg[Id[l]]\u0026gt;0) return; tr[rt]=a[Id[l]]; return; } build(ls,l,mid),build(rs,mid+1,r); pushup(rt); } void update(int rt,int l,int r,int x,int k) { if(l==r){ tr[rt]=k; return; } if(x\u0026lt;=mid) update(ls,l,mid,x,k); else update(rs,mid+1,r,x,k); pushup(rt); } int query(int rt,int l,int r,int lf,int rg) { if(lf\u0026gt;r||l\u0026gt;rg) return 0; if(lf\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=rg) return tr[rt]; return query(ls,l,mid,lf,rg)+query(rs,mid+1,r,lf,rg); } namespace R { int tr[N],Id[N],n; void upd(int x,int k){ for(;x\u0026lt;=n;x+=x\u0026amp;-x){ tr[x]+=k; } } int qry(int x,int k=0){ for(;x;x-=x\u0026amp;-x){ k+=tr[x]; } return k; } void dfs3(int u,int tp) { if(vis[u]) return; vis[u]=1; for(pii i:G[u]){ if(deg[i.ft]\u0026lt;=0) continue; if(Id[i.ft]==0) Id[i.ft]=Id[u]+1; if(vis[i.ft]==0||i.ft==tp) val[i.ft]=i.sd; dfs3(i.ft,tp); } } } bool cmp(int x,int y) { return R::Id[x]\u0026lt;R::Id[y]; } int Qry(int u,int v) { int res=0; while(top[u]^top[v]){ if(dep[top[u]]\u0026lt;dep[top[v]]) swap(u,v); res+=query(1,1,n,dfn[top[u]],dfn[u]); u=fa[top[u]]; } if(dep[u]\u0026gt;dep[v]) swap(u,v); res+=query(1,1,n,dfn[u]+1,dfn[v]); return res; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++){ int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); G[u].push_back({v,w}); G[v].push_back({u,w}); deg[u]++,deg[v]++; E[i]={u,v,w}; } queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=n;i++) if(deg[i]==1) q.push(i),deg[i]=-1; while(!q.empty()){ int u=q.front();q.pop(); for(pii i:G[u]){ if(deg[i.ft]==-1) continue; --deg[i.ft]; if(deg[i.ft]==1){ deg[i.ft]=-1; q.push(i.ft); } } } for(int i=1;i\u0026lt;=n;i++) if(deg[i]\u0026gt;0){ Ring.push_back(i); dfs1(i,0,i); dfs2(i,i); } build(1,1,n); R::Id[Ring[0]]=1; R::dfs3(Ring[0],Ring[0]); sort(Ring.begin(),Ring.end(),cmp); R::n=(int)Ring.size(); for(int i=0;i\u0026lt;R::n;i++) R::upd(i+1,val[Ring[i]]); while(m--){ int op,x,y,u,v; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x,\u0026amp;y); if(op==1){ u=E[x].u,v=E[x].v; if(deg[u]\u0026gt;0\u0026amp;\u0026amp;deg[v]\u0026gt;0){ int pos=max(R::Id[u],R::Id[v]); if(min(R::Id[u],R::Id[v])==1\u0026amp;\u0026amp;pos==R::n) pos=1; int tmp=R::qry(pos)-R::qry(pos-1); R::upd(pos,y-tmp); }else{ int pos=(dep[u]\u0026lt;dep[v]?dfn[v]:dfn[u]); update(1,1,n,pos,y); } }else{ if(deg[x]\u0026gt;0\u0026amp;\u0026amp;deg[y]\u0026gt;0){ if(R::Id[x]\u0026gt;R::Id[y]) swap(x,y); int t1=R::qry(R::Id[y])-R::qry(R::Id[x]); int t2=R::qry(R::Id[x])+R::qry(R::n)-R::qry(R::Id[y]); printf(\u0026#34;%lld\\n\u0026#34;,min(t1,t2)); }else{ if(Rt[x]^Rt[y]){ int res=Qry(Rt[x],x)+Qry(Rt[y],y); if(R::Id[Rt[x]]\u0026gt;R::Id[Rt[y]]) swap(x,y); int t1=R::qry(R::Id[Rt[y]])-R::qry(R::Id[Rt[x]]); int t2=R::qry(R::Id[Rt[x]])+R::qry(R::n)-R::qry(R::Id[Rt[y]]); printf(\u0026#34;%lld\\n\u0026#34;,res+min(t1,t2)); }else{ printf(\u0026#34;%lld\\n\u0026#34;,Qry(x,y)); } } } } return 0; } ","date":"2024-09-29T09:56:00+08:00","permalink":"https://werchange.github.io/p/p4949-%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB-%E9%A2%98%E8%A7%A3/","title":"P4949 最短距离 题解"},{"content":"\nABC373E 题解\r题目大意\r$n$ 个候选人目前各有一些选票 $a_i$，总共选民投出了 $k$ 张选票。现在有 $k-\\sum a_i$ 张可支配选票。现在请你求出第 $i$ 个人至少需要多少票使得剩下的票无论投给谁他都可以当选。\n当选规则是：当且仅当选票比他多的人 $\u0026lt;m$。\n如果无法当选即为 $-1$\nSolution\r鲜花：\n可爱题。\n这个题目很好想啊，即使是在 D 题被卡、同舍生皆开 E 的情况下，没花几分钟就想到了怎么做了。一度怀疑读错题了。\n就是一个萌萌二分算代价是否合法。\n但是调的时候是很麻烦的，总有一些边界问题。考后几分钟就 A 了。\n解法：\n首先从大到小排序，得到初始选票支持情况。\n接着对于每个 $i$ 都二分他的增量 $mid$。\n我们把选票统计抽象成条形统计图，一开始是非严格递减的。现在 $i$ 这个位置突然多了 $mid$ 的增量，就把他挪到合适的位置使得这个图再次非严格递减。设这个位置为 $p$。\n我们考虑如何 ban 掉他。无非就是他后面 $m-p+1$ 个位置的值得到了选票都比他高了，那么使得这一情况发生需要多少选票呢？\n显然为：\n$$\r(a_i+mid+1)\\times(m-p+1)-\\sum\\limits_{j=p}^m a_j\r$$ 这个 $\\sum$ 在排序前维护一下前缀和就行了。\n只有上式加上让 $i$ 激增的增量 $mid$ 后的值小于等于剩余选票数，才有可能 ban 掉他。\n现在在考虑一种情况：如果本来 $i$ 初始就在 $1\\sim m$ 内呢？\n会发现如果我们用上式计算，会把他自己也算进“ban 掉他”的大军里。所以要往后多算一个，再把他自己给加上。\n$$\r(a_i+mid+1)\\times(m-p+1)-\\sum\\limits_{j=p}^{m+1} a_j+a_i\r$$ 然后就可以实现了，注意小于大于这种情况要不要等于。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=2e5+5; int n,m,k; pii a[N]; int ans[N],sum[N]; int b[N]; int work(int x) { int l=1,r=n,res=1; while(l\u0026lt;=r){ int mid=l+r\u0026gt;\u0026gt;1; if(b[mid]\u0026lt;=x) res=mid,r=mid-1; else l=mid+1; } return res; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; int tot=0; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i].ft,a[i].sd=i,tot+=a[i].ft; int Dt=k-tot; if(n==m){ for(int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;0 \u0026#34;; } exit(0); } sort(a+1,a+n+1,[](pii x,pii y){ if(x.ft!=y.ft) return x.ft\u0026gt;y.ft; return x.sd\u0026lt;y.sd; }); for(int i=1;i\u0026lt;=n;i++) sum[i]=sum[i-1]+a[i].ft,b[i]=a[i].ft; for(int i=1;i\u0026lt;=n;i++){ int l=0,r=Dt,res=-1; if(a[i].ft+Dt\u0026lt;a[m].ft){ ans[a[i].sd]=-1; continue; } while(l\u0026lt;=r){ int mid=l+r\u0026gt;\u0026gt;1; if(i\u0026lt;=m){ int p=work(a[i].ft+mid); if(p\u0026gt;m){ l=mid+1; continue; } if((a[i].ft+mid+1)*(m-p+1)-(sum[m+1]-a[i].ft-sum[p-1])+mid\u0026gt;Dt){ res=mid; r=mid-1; }else l=mid+1; }else{ int p=work(a[i].ft+mid); if(p\u0026gt;m){ l=mid+1; continue; } if((a[i].ft+mid+1)*(m-p+1)-(sum[m]-sum[p-1])+mid\u0026gt;Dt){ res=mid; r=mid-1; }else l=mid+1; } } ans[a[i].sd]=res; } for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return 0; } ","date":"2024-09-28T21:52:00+08:00","permalink":"https://werchange.github.io/p/abc373e-%E9%A2%98%E8%A7%A3/","title":"ABC373E 题解"},{"content":"\nP9481 [NOI2023] 贸易 题解\r题目大意\rP9481 [NOI2023] 贸易\nSolution\r萌萌题。\n也是做上 NOI 的题了呀。\n首先因为题目满二叉树的优秀性质，我们可以得到两个式子：\n$dep_u=log_2 u$ $siz_u=2^{n-dep_u}-1$ 不用证明吧，手推一下就出来了。\n接着考虑几种 $dist(u,v)$ 的情况，分别是“子到祖”、“祖到子”、“彼到此”。说人话就是：\n$u$ 是 $v$ 的祖先，考虑 $v\\to u$ 的贡献（水）。 $v$ 是 $u$ 的祖先，考虑 $v\\to u$ 的贡献。 $u$，$v$ 在不同的子树内，考虑 $u\\to v$ 的贡献。 第一个情况好搞，这里不说了，就是无脑爬一类边。这里不会走二类边，因为权值为正，所以没必要兜圈子。\n第二种情况我们设一个 $f_{u,i}$ 表示 $u$ 的深度为 $i$ 的祖先到 $u$ 的距离。\n如果 $u$ 是 $v$ 的祖先且有 $u\\to v$，显然转移为： $$\rf_{v,dep_u}=\\min \\{w_{u,v} \\}\r$$ $w_{u,v}$ 是这条有向边的边权。\n上面这个转移还是 too simple 了呀，我们接着考虑在路径 $v\\to u$ 上的点 $x$ 到路径 $v\\to x$ 上 $y$ 的最短路。\n其实我们预处理出所有点的 $dist(1,i)$ 之后，这个显然是好转移的，相当于是兜个圈子：\n$$\rf_{y,dep_x}=\\min \\{w_{u,v}+dist(1,v)-dist(1,y)+dist(1,x)-dist(1,u) \\}\r$$ 这条链是这样的：$v\\to \\dots\\to y\\to \\dots \\to x\\to\\dots\\to u\\to\\dots\\to 1$\n更新所有点的过程很像 Floyd 的过程，注意枚举顺序即可。\n这样就搞定第二种情况了。\n现在考虑第三种情况。\n聪明的小朋友已经发现了呀，第三种情况的实现就是靠前两种情况贡献得来的。\n首先在情况一时我们可以搞一个类似于前缀和的东西把该点子树内的一些计数信息都推上来到该点。\n其次在情况二时我们已经得到了 $f_{u,i}$。\n那么计数就很简单了，我们在考虑到点 $u$ 时，我们只需要边爬父亲，边计算该父亲另一个儿子的贡献。\n具体的就是： $$\r\\sum f_{u,i}\\times (siz(v\\oplus 1)+1)+val(v\\oplus 1)\r$$ $u$ 是枚举的当前点，$v$ 是不断向父亲爬的点（初始为 $u$），$i$ 是 $v$ 父亲的 $dep$，$v\\oplus 1$ 是 $v$ 的兄弟节点（满二叉树性质）。\n就此完了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=18,M=262144,P=998244353,INF=1e18; int n,m; int dis[M],sum[M],f[M][N],a[M]; int dep(int u) { return log2(u); } int siz(int u) { return (1\u0026lt;\u0026lt;(n-dep(u)))-1; } int val(int u) { return sum[u]+siz(u)*a[u]; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=2;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); dis[i]=dis[i\u0026gt;\u0026gt;1]+a[i]; } for(int i=(1\u0026lt;\u0026lt;n)-1;i\u0026gt;1;i--) sum[i\u0026gt;\u0026gt;1]+=val(i); memset(f,0x3f,sizeof(f)); while(m--){ int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); for(int y=v;y\u0026gt;u;y\u0026gt;\u0026gt;=1) for(int x=y\u0026gt;\u0026gt;1;x\u0026gt;=u;x\u0026gt;\u0026gt;=1) f[y][dep(x)]=min(f[y][dep(x)],w+dis[v]-dis[y]+dis[x]-dis[u]); } for(int u=1;u\u0026lt;(1\u0026lt;\u0026lt;n);u++) for(int i=dep(u)-1,v=u\u0026gt;\u0026gt;1;v;i--,v\u0026gt;\u0026gt;=1) for(int j=i-1;~j;j--) f[u][j]=min(f[u][j],f[u][i]+f[v][j]); int ans=0; for(int u=(1\u0026lt;\u0026lt;n)-1;u;u--){ (ans+=sum[u])%=P; for(int i=dep(u)-1,v=u;v\u0026gt;1;i--,v\u0026gt;\u0026gt;=1){ if(f[u][i]\u0026lt;INF) (ans+=f[u][i]*(siz(v^1)+1)%P+val(v^1))%=P; } } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } ","date":"2024-09-27T19:37:00+08:00","permalink":"https://werchange.github.io/p/p9481-noi2023-%E8%B4%B8%E6%98%93-%E9%A2%98%E8%A7%A3/","title":"P9481 [NOI2023] 贸易 题解"},{"content":"「蓬莱人形」 题解\r题目大意\rP9212 「蓬莱人形」\nSolution\r这种有模数、记录数量、范围 1e5 的题，多半是根号分治。\n因为模数小时，区间数量多、区间内元素少；模数大时，区间数量少、区间内元素多。相当于两个极端，两种极端各跑一种算法，可以通过。\n而通常我们把判断模数是大还是小的阈值设为 $\\sqrt{n}$。\n对于本题而言，当 $m\\leq \\sqrt{n}$ 时，我们用 $\\sqrt{n}$ 个桶 $sum_{i,j}$ 表示模数为 $i$ 时结果为 $j$ 的数量。\n当 $m \u0026gt; \\sqrt{n}$ 时，此时 $\\lceil \\frac{n}{m}\\rceil \u0026lt; \\sqrt{n}$，所以可以暴力枚举 $\\lceil \\frac{n}{m}\\rceil$。考虑到每个 $\\lceil \\frac{n}{m}\\rceil$ 贡献的是一段区间，我们可以维护一个分块前缀和。\n上面是根号分治部分，剩下怎么做呢？\n首先区间 $[l,r]$ 直接转化成 $[1,l-1]$ 和 $[1,r]$ 两个区间，用类似前缀和的思想来获得 $[l,r]$ 的贡献。\n转化成这样之后就可以把询问离线下来扫描线了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=5e5+5,M=500+5,B=320; int n,m,sq; int a[N]; int sum[M][M]; int pre1[M],pre2[M][M]; int qx[N],qy[N],qm[N]; vector\u0026lt;pii\u0026gt; vec[N]; int ans[N]; void add(int x) { int Id=x/B+1,_Id=x%B; for(int i=_Id;i\u0026lt;B;i++) pre2[Id][i]++; for(int i=Id;i\u0026lt;=(100000)/B+1;i++) pre1[i]++; } int query(int x) { int Id=x/B+1,_Id=x%B; return pre1[Id-1]+pre2[Id][_Id]; } int work(int x,int y,int m) { if(x\u0026lt;y) swap(x,y); int l=m-x,r=m-y-1,res=0; if(m\u0026lt;sq){ for(int i=l;i\u0026lt;=r;i++) res+=sum[m][i]; return res; } for(int L=l,R=r;L\u0026lt;=100000;L+=m,R=min(R+m,100000)) res+=query(R)-query(L-1); return res; } signed main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); sq=sqrt(n); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i=1,l,r;i\u0026lt;=m;i++){ scanf(\u0026#34;%d%d%d%d%d\u0026#34;,\u0026amp;l,\u0026amp;r,\u0026amp;qx[i],\u0026amp;qy[i],\u0026amp;qm[i]); qx[i]%=qm[i],qy[i]%=qm[i]; if(qx[i]==qy[i]) continue; vec[l-1].push_back({i,-1}); vec[r].push_back({i,1}); } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;sq;j++) sum[j][a[i]%j]++; add(a[i]); for(pii j:vec[i]){ int p=j.ft; int tmp=work(qx[p],qy[p],qm[p]); if(qx[p]\u0026lt;qy[p]) tmp=i-tmp; ans[p]+=j.sd*tmp; } } for(int i=1;i\u0026lt;=m;i++){ if(qx[i]==qy[i]) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,ans[i]); } return 0; } ","date":"2024-09-27T15:31:00+08:00","permalink":"https://werchange.github.io/p/%E8%93%AC%E8%8E%B1%E4%BA%BA%E5%BD%A2-%E9%A2%98%E8%A7%A3/","title":"「蓬莱人形」 题解"},{"content":"BZOJ3706 反色刷 题解\r题目大意\rP10777 BZOJ3706 反色刷\nSolution\r先考虑无解情况噻~\n显然就是只关注黑边构成的图，如果一张连通黑图内有奇数度的点，肯定是不能构成欧拉回路的。证明根据欧拉回路的性质，可以翻我之前的博客。\n接下来思考要最少多少次回路可以跑完黑边。\n我们只考虑连通图，不连通情况就当做多张连通图来处理。\n如果现在有一条起点终点都是 $u$ 的回路和起点终点都是 $v$ 的回路（当然回路上的边都是黑的），这两条回路可不可以只用一次回路就完成呢？\n端详一下，因为现在只考虑连通图，所以 $u$，$v$ 一定是连通的。那么我们为什么没选到这条 $u\\leftrightarrow v$ 之间的路径呢？想必是这条路径上是白边。那意味着我们可以往返走，即走两次，这样的话这条路径就反色了个寂寞，也就是它还是白色。\n所以按照上面这种方法，两条回路势必可以连成一条回路，那么整个连通图最后肯定只有一条回路。\n所以一个连通块最少做一次回路操作。\n具体的答案就是有黑边的连通块个数。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=1e6+5,INF=1e18; int n,m,q,cnt; int deg[N]; vector\u0026lt;pii\u0026gt; G[N]; bool vis[N],flg; int top[N],cnttop[N]; struct edge{int u,v,w;}E[N]; void dfs(int u,int tp) { vis[u]=1,top[u]=tp; for(pii v:G[u]){ if(!vis[v.ft]){ cnttop[tp]+=(v.sd==1); dfs(v.ft,tp); } } } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++){ int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); G[u].push_back({v,w}); G[v].push_back({u,w}); if(w==1) deg[u]++,deg[v]++; E[i]={u,v,w}; } for(int i=1;i\u0026lt;=n;i++) if(!vis[i]){ flg=0; dfs(i,i); if(cnttop[i]\u0026gt;0) ++cnt; } scanf(\u0026#34;%lld\u0026#34;,\u0026amp;q); flg=0; for(int i=1;i\u0026lt;=q;i++){ int op,x; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;op); if(op==1){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;x); x++; if(E[x].w){ deg[E[x].u]--,deg[E[x].v]--; E[x].w^=1; if((deg[E[x].u]\u0026amp;1)||(deg[E[x].v]\u0026amp;1)) flg=1; else flg=0; --cnttop[top[E[x].u]]; if(cnttop[top[E[x].u]]==0) cnt--; }else{ deg[E[x].u]++,deg[E[x].v]++; E[x].w^=1; if((deg[E[x].u]\u0026amp;1)||(deg[E[x].v]\u0026amp;1)) flg=1; else flg=0; ++cnttop[top[E[x].u]]; if(cnttop[top[E[x].u]]==1) cnt++; } }else{ if(flg){ puts(\u0026#34;-1\u0026#34;); continue; } printf(\u0026#34;%lld\\n\u0026#34;,cnt); } } return 0; } ","date":"2024-09-27T10:44:00+08:00","permalink":"https://werchange.github.io/p/bzoj3706-%E5%8F%8D%E8%89%B2%E5%88%B7/","title":"BZOJ3706 反色刷"},{"content":"题解\r题目大意\rP7831 Travelling Merchant\nSolution\r萌萌题。\n首先放一个很不牛逼的结论：一个点没有出度时，连向它的点的答案随即确定了。\n然后是一个很显然的贪心：按边权 $r_i$ 从大到小排序，处理该边的起点更新其最小代价 $ans_u$。按刚刚的结论，如果它的所有出边都处理过了，该点的答案就已经确定了，我们就可以对连向它的边进行更新了。\n这个过程是不是很像拓扑排序啊？所以我们可以对于每个点预处理连接一下它作为终点时的每条边，方便我们后面更新。\n所以这道题对于原题的图没有建图，而是对连边关系进行了建图。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=2e5+5,INF=1e18; int n,m; int ans[N]; struct edge { int a,b,r,p; bool operator\u0026lt;(const edge \u0026amp;T)const{ return r\u0026gt;T.r; } }E[N]; int deg[N]; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); fill(ans+1,ans+n+1,INF); for(int i=1;i\u0026lt;=m;i++){ scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;E[i].a,\u0026amp;E[i].b,\u0026amp;E[i].r,\u0026amp;E[i].p); ++deg[E[i].a]; } sort(E+1,E+m+1); for(int i=1;i\u0026lt;=m;i++) G[E[i].b].push_back(i); queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=n;i++) if(!deg[i]) q.push(i),deg[i]=-1; for(int i=1;i\u0026lt;=m;i++){ while(!q.empty()){ int u=q.front();q.pop(); for(int j:G[u]){ if(vis[j]) continue; vis[j]=1; deg[E[j].a]--; if(!deg[E[j].a]) q.push(E[j].a),deg[E[j].a]=-1; if(ans[u]!=INF) ans[E[j].a]=min(ans[E[j].a],max(E[j].r,ans[u]-E[j].p)); } } if(!vis[i]){ vis[i]=1; deg[E[i].a]--; if(!deg[E[i].a]) q.push(E[i].a),deg[E[i].a]=-1; ans[E[i].a]=min(ans[E[i].a],E[i].r); } } for(int i=1;i\u0026lt;=n;i++){ if(ans[i]==INF) ans[i]=-1; printf(\u0026#34;%lld \u0026#34;,ans[i]); } return 0; } ","date":"2024-09-27T09:08:00+08:00","permalink":"https://werchange.github.io/p/cco2021-travelling-merchant-%E9%A2%98%E8%A7%A3/","title":"[CCO2021] Travelling Merchant 题解"},{"content":"奇偶矩阵 题解\r题目大意\r奇偶矩阵 Tablica\nSolution\r这里学到了个经典小 trick：矩阵转二分图。左部是行、右部是列，如果有一条连边，则意味着这条边构成的坐标（即矩阵中的点）被选中。\n那现在转化成：二分图左部 $n$ 个点、右部 $m$ 个点，在无重边的情况下，求每个点的度数 $\\in [1,2]$ 的方案数。\n枚举左部有 $j$ 个二度点，相当于将 $n+j$ 个球放进 $m$ 个盒子里，每个盒子球的数量 $\\in [1,2]$。设 $f_{i,j}$ 表示 $i$ 个球放进 $j$ 个盒子的方案数，易得： $$\rf_{i,j}=f_{i-1,j-1}\\times i+\\binom{i}{2}\\times f_{i-2,j-1}\r$$ 贡献为 $\\frac{f_{n+j,m}}{2^j}$，因为同一左部点代表的球本质相同。\n可是有重边，枚举重边个数 $i$，容斥一下，答案为： $$\r\\sum\\limits_{i=0}^n \\binom{n}{i}\\binom{m}{i}i!(-1)^i\\sum\\limits_{j=0}^{n-i}\\frac{1}{2^{i+j}}\\binom{n-i}{j}f_{n-i+j,m}\r$$ 可以提一个 $\\frac{1}{2^i}$ 出来： $$\r\\sum\\limits_{i=0}^n \\binom{n}{i}\\binom{m}{i}i!(-1)^i\\frac{1}{2^i}\\sum\\limits_{j=0}^{n-i}\\frac{1}{2^{j}}\\binom{n-i}{j}f_{n-i+j,m}\r$$ 后面的 $\\sum$ 可以写个函数封装起来。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int P=1e9+7,N=6e3+5; int n,m; int fac[N],inv[N],pow2[N]; int f[N][N]; int qpow(int a,int b=P-2) { int c=1; for(;b;b\u0026gt;\u0026gt;=1,a=a*a%P) if(b\u0026amp;1) c=c*a%P; return c; } void init() { fac[0]=1; for(int i=1;i\u0026lt;=N-5;i++) fac[i]=fac[i-1]*i%P; inv[N-5]=qpow(fac[N-5]); for(int i=N-5;i;i--) inv[i-1]=inv[i]*i%P; int inv2=qpow(2); pow2[0]=1; for(int i=1;i\u0026lt;=N-5;i++) pow2[i]=pow2[i-1]*inv2%P; } int C(int n,int m) { if(n\u0026lt;m) return 0; return fac[n]*inv[m]%P*inv[n-m]%P; } int work(int i) { int res=0; for(int j=0;j\u0026lt;=n-i;j++) (res+=pow2[j]*C(n-i,j)%P*f[n-i+j][m-i]%P)%=P; return res; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); init(); f[0][0]=1; for(int i=1;i\u0026lt;=2*n;i++) for(int j=1;j\u0026lt;=m;j++){ f[i][j]=f[i-1][j-1]*i%P; if(i\u0026gt;=2) (f[i][j]+=f[i-2][j-1]*C(i,2)%P)%=P; } int ans=0; for(int i=0;i\u0026lt;=n\u0026amp;\u0026amp;i\u0026lt;=m;i++) (ans+=C(n,i)*C(m,i)%P*fac[i]%P*((i\u0026amp;1)?-1:1)*pow2[i]%P*work(i)%P)%=P; ans=(ans%P+P)%P; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } ","date":"2024-09-26T21:49:00+08:00","permalink":"https://werchange.github.io/p/%E5%A5%87%E5%81%B6%E7%9F%A9%E9%98%B5-tablica-%E9%A2%98%E8%A7%A3/","title":"奇偶矩阵 Tablica 题解"},{"content":"划分题解\r题目大意\r现有集合 $A=\\{0,1,\\dots,n\\}$，函数 $f_m(S)$ 表示从 $S$ 中选出两个不同的数相加等于 $m$ 的方案数（选出的数无序）。\n现在要给出一种构造，构造出集合 $S$，另一部分即为 $T$（全集是 $A$），使得 $\\forall 1\\leq m\\leq n$，$f_m(S)=f_m(T)$ 。\n不需要你输出 $S$ 所有元素，你只需要以下列方式输出：\n令 $1\\in S$ 设 $x=(\\prod\\limits_{r\\in S} r)\\bmod 998244353$ 输出 $x$ 题目采用 $\\text{SPJ}$ 评测。\nSolution\r首先一眼发现这个 $\\text{SPJ}$ 是假的，因为很难通过若干个数的乘积（模 $998244353$ 的情况下）来还原出唯一的 $S$。结合出题人比较懒的特点， 应该是不会真的把所有可能都列出在 $\\text{SPJ}$ 里面的。所以答案是唯一的。\n但是我没看出来。\n当然可以证明，但是我不会， 现在会了：\n证明：考虑我们 $0\\sim n-1$ 的情况都处理好了，现在放 $n$。因为 $0\\in T$，所以如果放在 $T$ 里 $f_n(T)$ 就会增加 $1$；如果放在 $S$ 里 $f_n(S)$ 不变 。所以不存在 $n$ 既可以放在 $S$ 又可以放在 $T$ 的情况。\n这道题的做法有很多，推导过程也很有趣，类似于大力打表找规律、手玩样例找规律，但是因为我推导最后假了，所以我不觉得有趣。\n直接上结论吧：元素 $i\\in S$ 当且仅当 $\\text{popcount}(i)$ 为奇数。\n原因：令 $x,y\\in S$，$x+y=n$，$x\\neq y$。在二进制下从低到高找到第一个不同的位（显然可以做到），对 $x,y$ 把那一位翻转得到 $x\u0026rsquo;$ 和 $y\u0026rsquo;$，显然加和仍然相等且二者互不相等，就可以给 $f_n(T)$ 做贡献。\n现在怎么区分哪些元素到底怎么放不会混淆呢？发现 $x$ 与 $x\u0026rsquo;$ 的差别、$y$ 与 $y\u0026rsquo;$ 的差别就是 $\\text{popcount}$ 的奇偶性发生了变化。所以我们可以规定一个集合内的 $\\text{popcount}$ 奇偶性相同。\n为什么上面写的是“原因”而不是“证明”？\n因为我感觉作为证明就怪怪的，但是它正好自洽。果然信息竞赛不是数学竞赛。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int P=998244353,N=2e3+10; int n,ans; int popcount(int x) { int cnt=0; for(int i=63;~i;i--) cnt+=((x\u0026gt;\u0026gt;i)\u0026amp;1); return cnt; } signed main() { ans=1; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ if(popcount(i)\u0026amp;1) ans=ans*i%P; } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } ","date":"2024-09-26T19:37:00+08:00","permalink":"https://werchange.github.io/p/%E5%88%92%E5%88%86-%E9%A2%98%E8%A7%A3/","title":"划分 题解"},{"content":"扫雷题解\r题目大意\r$a_{i,j}\\in[0,1]$ 表示该格是否有雷，$b_{i,j}$ 为该格所处九宫格内雷的数量。对于所有可能的 $a$，求出 $\\sum b_{i,j}$ 的总和 $(\\bmod 998244353)$。\n$n\\leq 10^{20090327}$\nSolution\r首先明确一点，矩阵上有角落、棱、内部三种区划，该区划内联通的格子数分别为 $4$、$6$、$9$。\n题目要求的是这个：$\\sum\\limits_a \\sum\\limits_i \\sum\\limits_j b_{i,j}$，我们单独去分析一个格点可能的情况：\n设该格点联通格子数量为 $k$，那么可以遍历雷的数量 $i\\in [0,k-1]$。首先明显的是联通格子外的点可以随便放，即 $2^{n^2-k}$。接着我们考虑联通格子内，共有 $\\binom{k-1}{i}$ 种可能，雷的数量 $i$ 即对这个格子的贡献。所以可得下式： $$\r\\sum\\limits_{i=0}^{k-1} 2^{n^2-k}\\binom{k-1}{i}i\r$$ 提一个 $2^{n^2}$ 出来： $$\r2^{n^2}\\sum\\limits_{i=0}^{k-1} 2^{-k}\\binom{k-1}{i}i\r$$ 这个式子在乘上情况数量就是 $\\sum\\limits_a\\sum\\limits_i\\sum\\limits_j b_{i,j}$ 了。\n因为 $k$ 仅可能为 $4$、$6$、$9$，所以我们一个一个求出来这三种情况的贡献。\n考虑三种情况的数量，这是十分显然的。角落就是 $4$ 个，棱共有 $4(n-2)$ 个，内部共 $(n-2)^2$ 个。把这些数量分别乘上对应的贡献加起来就好了。\n最后的答案要乘上一个 $2^{n^{2}}$，因为刚刚提出来了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int P=998244353,phi=998244352,N=1e3+5; string s; int n,m; int res[6]={0,0,48,5120,1376256,209715199}; int ans; int qpow(int a,int b) { int c=1; for(;b;b\u0026gt;\u0026gt;=1,a=a*a%P) if(b\u0026amp;1) c=c*a%P; return c; } signed main() { cin\u0026gt;\u0026gt;s; int len=(int)s.size(); for(int i=0;i\u0026lt;len;i++) n=(n*10%P+(s[i]^48))%P; for(int i=0;i\u0026lt;len;i++) m=(m*10%phi+(s[i]^48))%phi; if(n\u0026lt;=5) return printf(\u0026#34;%lld\\n\u0026#34;,res[n]),0; int t4=qpow(2,phi-4)*12%P; int t6=qpow(2,phi-6)*80%P; int t9=qpow(2,phi-9)*1024%P; (ans+=t4*4)%=P; (ans+=t6*4%P*(n-2)%P)%=P; (ans+=t9*qpow(n-2,2)%P)%=P; ans=ans*qpow(2,m*m%phi)%P; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } ","date":"2024-09-26T19:11:00+08:00","permalink":"https://werchange.github.io/p/%E6%89%AB%E9%9B%B7-%E9%A2%98%E8%A7%A3/","title":"扫雷 题解"},{"content":"AC 自动机查漏补缺\r前言\r今年 1 月份学过一次，当时自以为掌握得很好，实际上就是依托答辩。而且还有很多地方是有严重误导性的。所以这篇查漏补缺就是记录一下自己对 AC 自动机尚不完全掌握的地方。并对之前的那篇不太正确的题解进行纠正。\n因此，在这样的背景下，这篇文章注定就不是给初学者看的，是大致了解了 AC 自动机是什么后的一篇提高读物。\n当然你硬要初学就来看也没问题，毕竟此篇文章与重头开始写没有什么区别。\n三问 AC 自动机\r第一问：AC 自动机到底是什么？\nKMP 是解决单模式串匹配问题的算法，而 AC 自动机则可以解决多模式串匹配问题。\n第二问：AC 自动机靠什么实现？\n通过多模式串建起一棵 Trie 树，再构建 Trie 上每个点的失配指针（fail），由此可得 Fail 树。将文本串在 Trie 上留痕。然后就可以得到文本串前缀的信息。根据 Fail 树的定义可以更新这些前缀的后缀，即文本串的子串。同时如果该子串如果是模式串则可以维护模式串的信息了。\n第三问：AC 自动机为什么叫“自动机”？\n自动机是一种数学模型，至于它的深层的定义可以去看《自动机 - OI Wiki》。\n三问 Fail 树\r第一问：Fail 树是怎么冒出来的？\nAC 自动机一个重要的步骤是构建失配指针，即 fail 指针。某个点的 fail 指针所指向的点在 Trie 上对应的字符串是该点在 Trie 上对应的字符串的最大后缀（“对应的字符串”指 Trie 上的根节点到此点的路径上的字符构成的串）。所以每个点都只有一个 fail 指针（可能指向根节点），每个点也有可能被多个节点的失配指针指向。这个就很像父子关系，所以 fail 指针构造出来后，即得到了一棵 Fail 树。\n第二问：Fail 树和 Trie 树有什么区别？\nFail 树上每个节点的祖先都是该点在 Trie 上对应字符串的后缀。Trie 树是把每个模式串塞进去而建起来的。当文本串在 Trie 上留痕后，一个留痕过的点从根节点到它的路径上形成的字符串就是文本串的前缀（这个很显然啦~）。\n第三问：Fail 树和 Trie 树有什么联系？\n首先是在 Trie 上将文本串留痕，边留痕边在该节点记录信息。这样结束后便得到了文本串前缀的信息。我们还想处理文本串子串的信息。这时候需要搬出我们的 Fail 树。拓扑排序，从叶子节点将信息传递到父亲节点。为什么呢？因为 Fail 树上的祖先是该点的后缀，而前缀的后缀就是子串。为什么可以这样？因为该点是文本串留痕过的点，说明此时是可以匹配上文本串的。既然该点的串可以匹配上，那该点的串的后缀必然也是可以匹配上的。\n典型例题\rP3808 AC 自动机（简单版）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1e6+5,M=30; int n; char str[N],s[N]; int tr[N][M],fail[N],tot,deg[N],pos[N]; bool vis[N]; void ins(char *s,int j) { int len=strlen(s),root=0; for(int i=0;i\u0026lt;len;i++) { if(!tr[root][s[i]-\u0026#39;a\u0026#39;]) tr[root][s[i]-\u0026#39;a\u0026#39;]=++tot; root=tr[root][s[i]-\u0026#39;a\u0026#39;]; } pos[j]=root; } void FL() { queue\u0026lt;int\u0026gt; q; for(int i=0;i\u0026lt;26;i++) if(tr[0][i]) q.push(tr[0][i]); while(!q.empty()) { int u=q.front();q.pop(); for(int i=0;i\u0026lt;26;i++) { if(tr[u][i]) { fail[tr[u][i]]=tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i]=tr[fail[u]][i]; } } } void AC() { int len=strlen(str),root=0; for(int i=0;i\u0026lt;len;i++) { root=tr[root][str[i]-\u0026#39;a\u0026#39;]; vis[root]=1; } for(int i=1;i\u0026lt;=tot;i++) deg[fail[i]]++; queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=tot;i++) if(!deg[i]) q.push(i); while(!q.empty()) { int u=q.front();q.pop(); if(!u) continue; vis[fail[u]]=1; deg[fail[u]]--; if(!deg[fail[u]]) q.push(fail[u]); } } signed main() { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%s\u0026#34;,s); ins(s,i); } scanf(\u0026#34;%s\u0026#34;,str); FL(); AC(); int ans=0; for(int i=1;i\u0026lt;=n;i++) if(vis[pos[i]]) ++ans; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } P3796 AC 自动机（简单版 II）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1e6+5,M=30,L=80; int n; char str[N],s[N][L]; int tr[20000][M],fail[N],tot,pos[N]; int vis[N]; void ins(char *s,int j) { int len=strlen(s),root=0; for(int i=0;i\u0026lt;len;i++) { if(!tr[root][s[i]-\u0026#39;a\u0026#39;]) tr[root][s[i]-\u0026#39;a\u0026#39;]=++tot; root=tr[root][s[i]-\u0026#39;a\u0026#39;]; } pos[tot]=j; } void FL() { queue\u0026lt;int\u0026gt; q; for(int i=0;i\u0026lt;26;i++) if(tr[0][i]) q.push(tr[0][i]); while(!q.empty()) { int u=q.front();q.pop(); for(int i=0;i\u0026lt;26;i++) { if(tr[u][i]) { fail[tr[u][i]]=tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i]=tr[fail[u]][i]; } } } void AC() { int len=strlen(str),root=0; for(int i=1;i\u0026lt;=tot;i++) vis[i]=0; for(int i=0;i\u0026lt;len;i++) { root=tr[root][str[i]-\u0026#39;a\u0026#39;]; for(int j=root;j;j=fail[j]) vis[pos[j]]++; } } signed main() { while(~scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n)\u0026amp;\u0026amp;n) { memset(fail,0,sizeof(fail)); memset(tr,0,sizeof(tr)); memset(pos,0,sizeof(pos)); tot=0; for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%s\u0026#34;,s[i]); ins(s[i],i); } //\tcerr\u0026lt;\u0026lt;tot\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; scanf(\u0026#34;%s\u0026#34;,str); FL(); AC(); int ans=0; for(int i=1;i\u0026lt;=n;i++) ans=max(ans,vis[i]); printf(\u0026#34;%lld\\n\u0026#34;,ans); for(int i=1;i\u0026lt;=n;i++) if(vis[i]==ans) puts(s[i]); } return 0; } P5357 【模板】AC 自动机\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=2e5+5,M=30,L=80; int n; char str[N*10],s[N][L]; int tr[N][M],fail[N],tot,deg[N],pos[N]; int vis[N]; void ins(char *s,int j) { int len=strlen(s),root=0; for(int i=0;i\u0026lt;len;i++) { if(!tr[root][s[i]-\u0026#39;a\u0026#39;]) tr[root][s[i]-\u0026#39;a\u0026#39;]=++tot; root=tr[root][s[i]-\u0026#39;a\u0026#39;]; } pos[j]=root; } void FL() { queue\u0026lt;int\u0026gt; q; for(int i=0;i\u0026lt;26;i++) if(tr[0][i]) q.push(tr[0][i]); while(!q.empty()) { int u=q.front();q.pop(); for(int i=0;i\u0026lt;26;i++) { if(tr[u][i]) { fail[tr[u][i]]=tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i]=tr[fail[u]][i]; } } } void AC() { int len=strlen(str),root=0; for(int i=0;i\u0026lt;len;i++) { root=tr[root][str[i]-\u0026#39;a\u0026#39;]; vis[root]++; } queue\u0026lt;int\u0026gt; q; for(int i=1;i\u0026lt;=tot;i++) deg[fail[i]]++; for(int i=1;i\u0026lt;=tot;i++) if(!deg[i]) q.push(i); while(!q.empty()) { int u=q.front();q.pop(); if(!u) continue; vis[fail[u]]+=vis[u]; deg[fail[u]]--; if(!deg[fail[u]]) q.push(fail[u]); } } signed main() { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%s\u0026#34;,s[i]); ins(s[i],i); } scanf(\u0026#34;%s\u0026#34;,str); FL(); AC(); int ans=0; for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%lld\\n\u0026#34;,vis[pos[i]]); return 0; } 后记\r感觉例题没什么好说的，这篇文章本来就不是详解，只是一点查漏补缺。代码都是在写文章当天重写过一遍的，以此来加深印象。\n另：之前那篇《浅谈 AC 自动机》有些有错误的地方，例如 fail 指针的构建根本就不是路径压缩，而是记忆化。\n","date":"2024-08-22T21:34:00+08:00","permalink":"https://werchange.github.io/p/ac-%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/","title":"AC 自动机查漏补缺"},{"content":"Solution\r题意简述\r给你一个正整数 $N$ 和 $N^3$ 个非负整数，表示为 $A_{x,y,z}$ 其中 $1 \\leq x, y, z \\leq N$ 。\n您将得到以下格式的 $Q$ 个查询，必须按顺序处理。\n对于第 $i$ 次查询 $(1 \\leq i \\leq Q)$ ，您将得到一个整数元组 $(Lx_i, Rx_i, Ly_i, Ry_i, Lz_i, Rz_i)$ ，其中 $1 \\leq Lx_i \\leq Rx_i \\leq N$ , $1 \\leq Ly_i \\leq Ry_i \\leq N$ , 和 $1 \\leq Lz_i \\leq Rz_i \\leq N$ 。求\n$$\r\\sum\\limits_{x=Lx_i}^{Rx_i} \\sum\\limits_{y=Ly_i}^{Ry_i} \\sum\\limits_{z=Lz_i}^{Rz_i} A_{x,y,z}\r$$ 题解\r简单三维前缀和。考虑一下容斥关系就好了。\ncode\n容斥知识补充\r既然题解写都写了，写详细一点。\n首先引入容斥的最经典的就是这张韦恩图（来自 OI-wiki）：\n现在我想知道 $|A\\cup B\\cup C|$，并不是简单粗暴的三个集合大小相加，因为互相有重叠部分。正确答案是：$|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|A\\cap C|-|B\\cap C|+|A\\cap B\\cap C|$。相信还是很好理解的这里不赘述了。\n把它推广到一般情况，就是我们熟悉的容斥原理了。\n定义\r$$\r\\left|\\bigcup_{i=1}^nS_i\\right|=\\sum\\limits_i\\left|S_i\\right|-\\sum\\limits_{i","date":"2024-08-12T11:45:00+08:00","image":"https://oi-wiki.org/math/combinatorics/images/incexcp.png","permalink":"https://werchange.github.io/p/abc366d-%E9%A2%98%E8%A7%A3/","title":"ABC366D 题解"},{"content":"Solution\r题意简述\r现在有 $N$ 个线性函数 $f_1,\\dots,f_N$。函数 $f_i(x)=A_ix+B_i$。\n找到一个长度为 $K$ 的序列 $p=(p_1,\\dots,p_k)$，序列元素为 $K$ 个大小在 $[1,N]$ 的不同整数。\n输出 $f_{p_1}(f_{p_2}(\\dots f_{p_k}(1)\\dots))$ 可能的最大值。\n思路\r贪心+DP。\n假设现在已经选出了序列 $p$，考虑怎么放（放外层还是内层）答案更优。\n钦定 $i\u0026lt;j$，则有两种放法：$f_i(f_j(x))$ 和 $f_j(f_i(x))$。\n把 $A$，$B$ 代入：$A_iA_jx+A_iB_j+B_i$ 和 $A_iA_jx+A_jB_i+B_j$。发现其实只有后两项不同，我们钦定排序后越前面的放在越里层，所以我们可以定下排序规则为：\n$$\rA_iB_j+B_i","date":"2024-08-12T11:13:00+08:00","permalink":"https://werchange.github.io/p/abc366f-%E9%A2%98%E8%A7%A3/","title":"ABC366F 题解"},{"content":"Solution\r题意简述\r二维平面上有 $N$ 个点 $(x_1,y_1),\\dots,(x_N,y_N)$ 和一个非负整数 $D$。\n求有多少对点对 $(x,y)$ 满足 $\\sum\\limits_{i=1}^N (|x-x_i|+|y-y_i|)\\le D$。\n思路\r发现 $x_i$ 与 $y_i$ 的捆绑关系不强（其实是几乎没有关联），所以我们分开考虑，也就是先考虑 $\\sum\\limits_{i=1}^n|x-x_i|$，得到结论后另外一边也是一样的。\n见到绝对值先拆绝对值，我们可以先对 $x_i$ 排个序，就可以通过枚举知道 $x$ 的相对位置，结合前缀和，可以 $O(1)$ 得到上面这个和式的值。设这个值为 $A_x$，我们可以直接枚举 $x\\in [-10^6,10^6]$，然后 $O(M)$ 得到 $A_x$。另外一边照葫芦画瓢，也可以快速得知 $B_y$ 的值。\n现在考虑计数。首先可以枚举值域内的每个 $x$，枚举中的子任务为求有多少个 $y$ 满足 $B_y\\leq D-A_x$。这是很简单的，对所有 $B_y$ 排个序，二分答案即可。\ncode\n","date":"2024-08-12T10:42:00+08:00","permalink":"https://werchange.github.io/p/abc366e-%E9%A2%98%E8%A7%A3/","title":"ABC366E 题解"},{"content":"重学 KMP 小记\r前言\rKMP 这个东西赛时用到的几率很小（虽然圣人说概率不小、也不是很大），但是如果一旦考字符串类的题又极可能考匹配问题。当时掌握得也是一知半解，所以现在来重学来了。\n情境引入\r现实中我们会遇到类似的问题：\n给你一篇报道，让你找一找这篇报道中有没有出现某个人的名字。\n形式化地，可以说：\n给你文本串 $S$，和模式串 $T$，判断 $T$ 是否为 $S$ 的子串。\n这个问题我们暴力地想，可以用两个指针 $i$，$j$ 分别表明现在匹配到 $S$，$T$ 的哪个位置了（$0\\le i\u0026lt; len_S$，$0\\leq j\u0026lt;len_T$）。如果 $S_i\\neq T_j$，则 $i\\leftarrow i-j+1$、$j\\leftarrow 0$。相当于是推翻重来。\n有没有优美一点的算法呢？答案是有的，就是我们的主角——KMP。\n算法概要\r我们在暴力的时候，如果一旦失配，模式串的指针 $j$ 就又从头开始，这显然是非常浪费的。所以我们如果想降低时间复杂度，就要从这里入手。\n首先我们定义一个数组 $next_i$，其满足：$S_{[0,next_i-1]}=S_{[i-next_i,i]}$。$S_{[l,r]}$ 表示 $S_l,S_{l+1},\\dots,S_{r}$ 组成的子串。当然这个 $next_i$ 有很多种情况，我们储存的是子串最长的情况。说白了这两部分子串就是 $S_{[0,i]}$ 的最长公共前后缀。\n特别地，$next_0=-1$。\n接下来就可以引入 KMP 了，算法流程如下：\n如果 $S_i$ 与 $T_{j+1}$ 匹配成功，即相同，就 $i\\leftarrow i+1$，$j\\leftarrow j+1$，继续匹配。 如果失配，则令 $i$ 不动，$j\\leftarrow next_j$。这意味着 $S$ 不变，将整个 $T$ 向右移动了 $j-next_j$ 位。这个值肯定是大于等于 $1$ 的。 这样就没了。\n现在来分析一下这个 KMP 是怎么减少浪费的。\n当 $T$ 匹配到 $j$ 位时，说明前面都是和 $S$ 相同的。如果此时失配了，暴力的思想是相当于直接把 $T$ 向右平移一位，然后重新比较。这样显然没有前途。KMP 是怎么做的呢？KMP 的思想是：“既然我这个 $T_{[0,j]}$ 里可能有公共前后缀，如果有的话，为什么我不直接把 $T$ 向右平移至这个最长公共前后缀相同的部分呢？”。\n画个草图理解一下：\n图中蓝色的部分都相同。\n如何预处理 $next_i$ 数组\r考虑递推。现假设 $next_{[0,i-1]}$ 的元素都已求出。\n算法过程就很简单了：\n如果 str[i]==str[next[i-1]+1]，则 next[i]=next[i-1]+1。 否则判断 str[i] 与 str[next[next[i-1]]+1] 是否相等。 再否则，判断 str[i] 与 str[next[next[next[i-1]]]+1] 是否相等。 回环往复，直至相等或 $next$ 的值为 $0$ 为止。 1 2 3 4 5 6 7 8 9 10 11 12 void getnxt() { int j=0; for(int i=2;i\u0026lt;=m;i++) { while(j\u0026amp;\u0026amp;b[j+1]!=b[i]) j=nxt[j]; if(b[j+1]==b[i]) j++; nxt[i]=j; } } 例题展现\rP3375 【模板】KMP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e6+5; int n,m; char a[MAXN]; char b[MAXN]; int nxt[MAXN]; void getnxt() { int j=0; for(int i=2;i\u0026lt;=m;i++) { while(j\u0026amp;\u0026amp;b[j+1]!=b[i]) j=nxt[j]; if(b[j+1]==b[i]) j++; nxt[i]=j; } } void kmp() { for(int i=1,j=0;i\u0026lt;=n;i++) { while(j\u0026amp;\u0026amp;a[i]!=b[j+1]) j=nxt[j]; if(b[j+1]==a[i]) j++; if(j==m) { printf(\u0026#34;%lld\\n\u0026#34;,i-m+1); j=nxt[j]; } } } signed main() { scanf(\u0026#34;%s%s\u0026#34;,a+1,b+1); n=strlen(a+1),m=strlen(b+1); getnxt(); kmp(); for(int i=1;i\u0026lt;=m;i++) printf(\u0026#34;%lld \u0026#34;,nxt[i]); return 0; } ","date":"2024-08-03T22:00:00+08:00","permalink":"https://werchange.github.io/p/%E9%87%8D%E5%AD%A6-kmp-%E5%B0%8F%E8%AE%B0/","title":"重学 KMP 小记"},{"content":"7.6 做题笔记\r笔记、梳理、题解合三为一的产物。\nP2569 [SCOI2010] 股票交易\r考虑 DP，数据允许开到平方级别。\n设 $f_{i,j}$ 表示第 $i$ 天持有 $j$ 张股票的最大钱。\n四种转移：\n凭空买入，即本次买入与前面无关。$f_{i,j}=-ap_i\\cdot j$。\n不买不卖，直接从前些天转移。$f_{i,j}=\\max{f_{i,j},f_{i-1,j}} $。\n在前面交易（买或卖）基础上买入，需要满足“两次交易间隔 $w$ 天”的条件。\n虽然不一定上一次交易就是第 $i-w-1$ 天，但是由转移 2 得，$f_{i-w-1,k}$ 已经是前面这些天的最优答案，所以可以从这天转移到今天。\n注意买入的数量不要超过 $as_i$。方程为：$f_{i,j}=\\max{f_{i,j},f_{i-w-1,k}-(j-k)\\cdot ap_i}; (j-as_i\\leq k\u0026lt;j)$。\n与转移 3 类似，在前基础上卖出。方程为：$f_{i,j}=\\max{f_{i,j},f_{i-w-1,k}+(k-j)\\cdot bp_i}; (j\u0026lt;k\\leq j+bs_i)$。\n发现转移 3，4 均为立方级别时间复杂度。$\\max$ 转移可以考虑单调队列优化。\n根据乘法分配律，转移 3 方程实际为：$f_{i,j}=\\max{f_{i,j},f_{i-w-1,k}+k\\cdot ap_i}-j\\cdot ap_i$。转移 4 类似，就不写了。区间取最大值的操作，单调队列可完成。\n转移时注意顺序与逆序，不要把已更新过的拿来更新其他状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=2e3+5; int n,m,w; int f[N][N]; int q[N],l,r; int ap,bp,as,bs; signed main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;w); memset(f,~0x3f,sizeof f); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;ap,\u0026amp;bp,\u0026amp;as,\u0026amp;bs); for(int j=0;j\u0026lt;=as;j++) f[i][j]=-ap*j; for(int j=0;j\u0026lt;=m;j++) f[i][j]=max(f[i][j],f[i-1][j]); if(i-w-1\u0026lt;0) continue; l=1,r=0; for(int j=0;j\u0026lt;=m;j++) { while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026lt;j-as) l++; while(l\u0026lt;=r\u0026amp;\u0026amp;f[i-w-1][q[r]]+q[r]*ap\u0026lt;=f[i-w-1][j]+j*ap) r--; q[++r]=j; if(l\u0026lt;=r) f[i][j]=max(f[i][j],f[i-w-1][q[l]]+q[l]*ap-j*ap); } l=1,r=0; for(int j=m;j\u0026gt;=0;j--) { while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026gt;j+bs) l++; while(l\u0026lt;=r\u0026amp;\u0026amp;f[i-w-1][q[r]]+q[r]*bp\u0026lt;=f[i-w-1][j]+j*bp) r--; q[++r]=j; if(l\u0026lt;=r) f[i][j]=max(f[i][j],f[i-w-1][q[l]]+q[l]*bp-j*bp); } } for(int j=1;j\u0026lt;=m;j++) f[n][j]=max(f[n][j-1],f[n][j]); printf(\u0026#34;%lld\\n\u0026#34;,f[n][m]); return 0; } 「一本通 5.5 例 2」最大连续和\r时间只允许线性级别。设 $f_i$ 为以 $i$ 结尾的长度不超过 $m$ 的子串的最大和。\n朴素转移：$f_i=\\max_j{\\sum\\limits_{k=j}^i a_k};(j\u0026gt;i-m)$。\n预处理前缀和，则 $f_i=\\max_j{sum_i-sum_{j-1}};(j\u0026gt;i-m)$。\n把 $sum_i$ 提出来，再把 $-sum_{j-1}$ 去负号，$\\max$ 也就变成了 $\\min$：$f_i=sum_i-\\min_j{sum_{j-1}}$。\n可以用单调队列解决这个 $\\min$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=3e5+5; int n,m; int a[N],ans,sum[N]; int q[N],l,r; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); ans=LLONG_MIN; for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]),sum[i]=sum[i-1]+a[i]; l=0,r=0; for(int i=1;i\u0026lt;=n;i++) { while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026lt;i-m) l++; ans=max(ans,sum[i]-sum[q[l]]); while(l\u0026lt;=r\u0026amp;\u0026amp;sum[q[r]]\u0026gt;=sum[i]) r--; q[++r]=i; } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } P3089 [USACO13NOV] Pogo-Cow\r时间允许平方级别。设 $f_{i,j}$ 表示当前在 $i$ 点，从 $j$ 点跳来的最大得分。首先按坐标顺序排序。\n立方转移：$f_{i,j}=\\max{f_{j,k}}+p_i;(x_j-x_k\\leq x_i-x_j)$。\n这里有一个建立 DP 方程式的 trick：尝试一下把 $f_{i-1,j}$ 带入 $f_{i,j}$。$f_{i,j}=f_{i-1,j}-p_{i-1}+p_i$。\n注意这里 $f_{i-1,j}$ 的范围是 $x_{j}-x_k\\leq x_{i-1}-x_j$，但是由于 $x_i\u0026gt;x_{i-1}$，所以满足 $f_{i,j}$ 范围的 $k$ 会比满足 $f_{i-1,j}$ 范围的 $k$ 要多。这里简单用 while 拓展一下就好了。\n题意是可以一直向左或一直向右，正反做两次 DP 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define x first #define p second const int N=1e3+5; int n; int f[N][N]; pii a[N]; signed main() { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;a[i].x,\u0026amp;a[i].p); sort(a+1,a+n+1); for(int j=1;j\u0026lt;=n;j++) { f[j][j]=a[j].p; for(int i=j+1,k=j+1;i\u0026lt;=n;i++) { f[i][j]=f[i-1][j]-a[i-1].p; while(k-1\u0026gt;=1\u0026amp;\u0026amp;a[j].x-a[k-1].x\u0026lt;=a[i].x-a[j].x) f[i][j]=max(f[i][j],f[j][--k]); f[i][j]+=a[i].p; } } for(int j=n;j\u0026gt;=1;j--) { f[j][j]=a[j].p; for(int i=j-1,k=j-1;i\u0026gt;=1;i--) { f[i][j]=f[i+1][j]-a[i+1].p; while(k+1\u0026lt;=n\u0026amp;\u0026amp;a[k+1].x-a[j].x\u0026lt;=a[j].x-a[i].x) f[i][j]=max(f[i][j],f[j][++k]); f[i][j]+=a[i].p; } } int ans=LLONG_MIN; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++) ans=max(ans,f[i][j]); printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } P2627 [USACO11OPEN] Mowing the Lawn G\r只允许线性复杂度。设 $f_{i,0/1}$ 表示前 $i$ 头奶牛中 不选/选 这头奶牛。$f_{i,0}=\\max{f_{i-1,0},f_{i-1,1}}$，$f_{i,1}=\\max_j{f_{j,0}+\\sum\\limits_{k=j+1}^iE_k};(i-K\\leq j\u0026lt; i)$。\n预处理前缀和，$f_{i,1}=\\max{f_{j,0}+sum_i-sum_{j}}=\\max{f_{j,0}-sum_j}+sum_i$。单调队列维护 $\\max$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1e5+5; int n,a[N],sum[N],f[N][2]; int q[N],l,r,k; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]),sum[i]=sum[i-1]+a[i]; l=1,r=1; for(int i=1;i\u0026lt;=n;i++) { while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026lt;i-k) l++; f[i][0]=max(f[i-1][0],f[i-1][1]); if(l\u0026lt;=r) f[i][1]=f[q[l]][0]-sum[q[l]]+sum[i]; while(l\u0026lt;=r\u0026amp;\u0026amp;f[q[r]][0]-sum[q[r]]\u0026lt;f[i][0]-sum[i]) r--; q[++r]=i; } int ans=LLONG_MIN; for(int i=1;i\u0026lt;=n;i++) ans=max({ans,f[i][0],f[i][1]}); printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } P2564 [SCOI2009] 生日礼物\r妙妙思路，不知道算不算 DP。\n想象一个窗口，当窗口内的种类齐全时，就可以更新答案。窗口的右端点容易推进，直接循环就是了，考虑左端点。可以表示一种彩珠种类最新的位置。这里的最新指窗口右端点左边的最靠近右端点的彩珠。然后，当彩珠左端的位置不再是这个种类的最新位置时，即这个窗口里包含的种类除了它，还有一个也在窗口里，那么我们就可以舍弃掉它、推进左端点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define x first #define col second const int N=1e6+5; int n,m; pair\u0026lt;int,int\u0026gt; a[N]; int l,tot,k,X[N]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1,t;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;t); for(int j=1;j\u0026lt;=t;j++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[++k].x),a[k].col=i; } sort(a+1,a+n+1); memset(X,-1,sizeof X); l=1; int ans=LLONG_MAX; for(int i=1;i\u0026lt;=n;i++) { if(X[a[i].col]==-1) ++tot; X[a[i].col]=a[i].x; while(X[a[l].col]!=a[l].x\u0026amp;\u0026amp;l\u0026lt;=n) l++; if(tot==m) ans=min(ans,a[i].x-a[l].x); } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } POJ 3017 Cut the Sequence\r设 $f_i$ 表示前 $i$ 个已被分为若干段的最优答案。$f_i=\\min{f_j+\\max_{k=j+1}^i a_k};(j\u0026lt;i,\\cup sum_i-sum_j\\leq m)$。上式可以把 $\\max$ 提出来。\n对于每个 $i$ 有多个满足条件的 $j$，因为 $f$ 单调不减，所以贡献嘴有答案的是最左边的满足条件的 $j$，记为 $c_i$。可以二分求得 $c_i$。\n$\\max$ 可以用单调队列搞定。$f_i=f_{c_i}+a_{q_l}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1e5+5; int n,m,a[N],c[N],q[N],f[N],sum[N]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); bool flg=1; for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i\u0026lt;=n;i++) if(a[i]\u0026gt;m) {flg=0;break;} if(!flg) return puts(\u0026#34;-1\u0026#34;),0; for(int i=1;i\u0026lt;=n;i++) { int l=0,r=i,mid,ans; while(l\u0026lt;=r) { mid=l+r\u0026gt;\u0026gt;1; if(sum[i]-sum[mid]\u0026lt;=m) ans=mid,r=mid-1; else l=mid+1; } c[i]=ans; } int l=1,r=0; for(int i=1;i\u0026lt;=n;i++) { while(l\u0026lt;=r\u0026amp;\u0026amp;a[q[r]]\u0026lt;=a[i]) r--; q[++r]=i; while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026lt;=c[i]) l++; f[i]=f[c[i]]+a[q[l]]; for(int j=l;j\u0026lt;=r;j++) f[i]=min(f[i],f[q[j]]+a[q[j+1]]); } printf(\u0026#34;%lld\\n\u0026#34;,f[n]); return 0; } AcWing 298. 围栏\r设 $f_{i,j}$ 表示前 $i$ 个工人刷了前 $j$ 个木板的最大价值（可以有一些木板不被刷）。\n显然，前一个人可以不刷，或者不刷前一块木板：$f_{i,j}=\\max{f_{i-1,j},f_{i,j-1}}$。\n朴素转移：$f_{i,j}=\\max_{j-l_i\\leq k\u0026lt;s_i}{f_{i-1,k}+p_i\\cdot(j-k)};(j\\geq s_i)$。\n把含 $j$ 项提出来，$\\max$ 里面就只剩有关 $k$ 项。单调队列优化就搞定了。\n实现的时候可以先把符合的 $k$ 塞入单调队列中，然后进行转移求 $f$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1.6e4+5,M=105; int n,m; struct node { int l,p,s; bool operator\u0026lt;(const node \u0026amp;T)const { return s\u0026lt;T.s; } }a[N]; int f[M][N]; int q[N],l,r; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++) scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;a[i].l,\u0026amp;a[i].p,\u0026amp;a[i].s); sort(a+1,a+m+1); for(int i=1;i\u0026lt;=m;i++) { l=1,r=0; for(int k=max(a[i].s-a[i].l,0ll);k\u0026lt;a[i].s;k++) { while(l\u0026lt;=r\u0026amp;\u0026amp;f[i-1][q[r]]-a[i].p*q[r]\u0026lt;=f[i-1][k]-a[i].p*k) --r; q[++r]=k; } for(int j=1;j\u0026lt;=n;j++) { f[i][j]=max(f[i-1][j],f[i][j-1]); if(j\u0026gt;=a[i].s) { while(l\u0026lt;=r\u0026amp;\u0026amp;q[l]\u0026lt;j-a[i].l) ++l; if(l\u0026lt;=r) f[i][j]=max(f[i][j],a[i].p*j+f[i-1][q[l]]-a[i].p*q[l]); } } } printf(\u0026#34;%lld\\n\u0026#34;,f[m][n]); return 0; } P2254 [NOI2005] 瑰丽华尔兹\r设 $f_{i,j}$ 为当前钢琴在 $(i,j)$ 时已滑行的最大距离。\n同一时间段内滑动具有唯一性，所以：$f_{i,j}=\\max {f_{i-dx,j-dy}+\\text{dis}(i,j,i-dx,j-dy)}$。因为滑动只在同一行或列上，所以偏移量可以快速求得，自然想到单调队列优化 DP。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define val first #define pos second const int N=205; int n,m,sx,sy,K; int f[N][N],fx[5][2]={0,0,-1,0,1,0,0,-1,0,1}; pair\u0026lt;int,int\u0026gt; q[N]; int l,r,len,ans; char s[N][N]; bool in(int x,int y) { return x\u0026gt;=1\u0026amp;\u0026amp;x\u0026lt;=n\u0026amp;\u0026amp;y\u0026gt;=1\u0026amp;\u0026amp;y\u0026lt;=m; } void work(int x,int y,int d) { l=1,r=0; for(int i=1;in(x,y);i++,x+=fx[d][0],y+=fx[d][1]) if(s[x][y]==\u0026#39;x\u0026#39;) l=1,r=0; else { while(l\u0026lt;=r\u0026amp;\u0026amp;q[r].val+i-q[r].pos\u0026lt;f[x][y]) r--; q[++r]={f[x][y],i}; while(q[r].pos-q[l].pos\u0026gt;len) l++; f[x][y]=q[l].val+i-q[l].pos; ans=max(ans,f[x][y]); } } signed main() { scanf(\u0026#34;%lld%lld%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;sx,\u0026amp;sy,\u0026amp;K); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%s\u0026#34;,s[i]+1); memset(f,~0x3f,sizeof f); f[sx][sy]=0; for(int k=1,s,t,d;k\u0026lt;=K;k++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;s,\u0026amp;t,\u0026amp;d); len=t-s+1; if(d==1) for(int i=1;i\u0026lt;=m;i++) work(n,i,d); if(d==2) for(int i=1;i\u0026lt;=m;i++) work(1,i,d); if(d==3) for(int i=1;i\u0026lt;=n;i++) work(i,m,d); if(d==4) for(int i=1;i\u0026lt;=n;i++) work(i,1,d); } printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } ","date":"2024-07-06T11:45:00+08:00","permalink":"https://werchange.github.io/p/7.6-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"7.6 做题笔记"},{"content":"中考2024 游记\r前言\r貌似中考也可以写游记捏，谨以此纪念我的中考与毕业。\nDay -7\r6 月 23 日，星期日。\n今天回校下周就不回来咯，直接考完中考再回来。啊啊啊啊啊好漫长的一周……\n复习已经复不动了，还有大把提纲没看、试卷没写。每次的模拟考总是差一点点，明明可以不出错的呀，不知道中考可不可以全力以赴，超常发挥。\n那既然是中考前的最后的一个周末，做点什么好呢？随便做了一个表盘，发给商家，商家说能做，就下单了。中考完应该就送到家了吧，当作中考礼物吧！\n就这样，初三的最后一个周末，就这样过去了。\nDay -6\r6 月 24 日，星期一。\n周末从家里顺了一本新书，拿出来给 wzy 看，给小朋友馋哭了。我知道考前一周带课外书挺不合适的，但是头脑一热就带过来了。\n实际情况就是，我没看几眼，就被三两个同学借走去看了。\n当晚得知贺校要给我们班每人发一个苹果，真是高兴坏了！你看这，这就是好校长、好学校啊！\n周老师是教语文的，特此上了一节“语文课”：\n苹果就是平平安安、硕果累累、红红火火、圆圆满满。\n不过苹果确实又大又红，比拳头还大！又脆又甜，牙齿还不酸。晚上后悔吃饱啦！晚上饱得睡不着~\n嗝~\n不过贺校的到来，属实有动员的作用。原先累了，贺校进来说两句话、亲手发苹果、一个相信的笑容——这就足够了！直接动力满满，全力以赴，剑指中考！\nDay -4\r发现 wzm 在用订书机的钉子拼立方体，立刻来了兴趣，直接学习一手。\n我不知道当时在干嘛，居然在干这种无聊的事情。钉子少了，就不要脸的跑去找化学老师借。\n终于是拼好了，好像初中的最后一丝余念也尽了，心中涌起奇怪的感觉。我去问 wzm 终于拼完了他有啥感受，他说：\n“终于可以开始复习中考了。”\n“我记得上学期期末考我也在做手工。”\n这是真的，他在方格纸裁剪下来图形，然后用胶水把他们粘起来粘成一个立方体。当然是十八面体。\n我还记得当时我也参与了。我真是好笑啊，无聊到这种地步了。\nDay -3\r我发现中考真的是能把什么人都逼出来。\n手工大王，不赘述了，就是昨天的事儿。\n棋王，中考前中午、晚上就寝前迟迟不回来，在教室里下棋。\n开锁大王，抱着别人的行李箱在那儿听动静跟小偷一样开锁。\n书王，一周内把我带来的那本书看完了。我问他从头看到尾？他点头。我问怎么做到的，他说上课都在看……\n还有球王，说什么早起去练排球的，还有中午早起一个人在练投篮的……\nDay 0\r6 月 29 日，不知道星期几了（其实星期一）。明天下午就要考语文了。\n感觉距离周五过去好几天了，我们竞赛班和小学生住在一起，感觉他们好久没回来了。这天回宿舍，看着乌漆嘛黑的宿舍楼，就我们一栋亮着，心里不是滋味：\n“怎么我们不放中考假啊！”\n哦，忘记就是我们要中考了。\n这一天晚修全用来复习语文啦，却感觉有好多都没有做。什么生字啦、文言文过关啦……欠了一大堆。初三这年又一直在追求所谓“创新”、“思想”的作文。结果就是不尽人意，现在反倒担心写不好常规应试作文来。\n不管啦，反正明天还有整个上午，看看作文参考书吧。\nDay 1\r6 月 30 日，上午。\n距离 2024 届中考仅剩：就在今天\n当然不是早上，早上是初二学弟学妹们的生地会考。话说我们生地会考那天怎么不记得下午就是学长学姐的中考了？看来是当时我考完后太嗨了，都没注意。\n先是简单看了一下一些老师发的什么《终极秘籍——不在迫不得已不使用》、《考前注意事项》、《考前复习提纲》啦，然后就过了一下文言文。\n有个好笑的事情，周老师说昨晚做了一个梦，梦到了中考文言文考《北冥有鱼》。我寻思着这也不是重点的重点啊，但我还是复习了，为什么？——因为我也有过这种预感，就是《北冥有鱼》。\n有的时候真的不得不相信一下，起码心里安定些。\n考完后的我：怎么是《小石潭记》啊，没复习啊。一看早读本，怎么就在《北冥有鱼》的前一篇！啊啊啊啊啊！\n复习完就找 gbj 借了作文书，这是我初二最喜欢的作文书（2023版）。可是我再看的时候（2024版），总觉得它不是它了。说不上来的感觉。\n我多想看一篇正常的中考作文啊，怎么这版全是那些“创新”作文？？\n蒙了。\n得过且过吧，完成任务。\n然后和我们班里的老师、同学来了一张大合影。有个很神的事情，我的表带了至少半年，从来没有自己脱落过。在拍照的时候推推搡搡，表带不知怎么的就松了！可是没人碰到我手腕啊。手表掉在了地上，硬着陆，贼响。我赶紧拿了起来，表盘没碎，又急着拍照，就又戴在手上了。那时是 11：05 左右。\n中午一直到回宿舍，我都没看表。突然 ccx 说：“你的表怎么不动了呀！”我以为开玩笑呢，当时急着看作文，没理他。结果说的人越来越多，我拿来一看。\n我天。\n真不转了。\n时分针定格在 11：03。\n我想完了完了，这个中午找谁借表好呢？身边都是初三的同学，都要中考。而且这个中午我本来计划好看作文的，这一搞我有点不知所措了。\n但实际上我当时平静得一批。\n我说：“不转就不转了呗，又不是考不了了。”\n我还坐着看作文书，过来一会儿去找生活老师，让他帮帮忙借初二学弟的表，因为初二今天上午刚好考了生地嘛，所以我猜他们的表肯定是符合要求的。果不其然，借来了。\n天无绝人之路好吧！就算你再语文考试前几个小时手表突然不转了，我依然有法子来应对！\n但是一直到中考结束，那个表就一直定格在 11：03，星期日，30。算是纪念中考开始当天吧。\n6 月 30 日，下午。\n怎么答题卡是两张 A4 大小？第一次见！\n语文还是很简单啊，没什么难题，就是答题卡正面（文言文即以前）的题都很活。怎么文言文对比阅读最后一题是介绍小石潭这个景点啊？？\n后面就正常发挥。\n阅读题：《春到零丁洋》。\n以为深中通道要来了！其实没有……\n题目中规中矩吧，就不是套路题，看时间挺多，还停下来一会儿思考怎么答全面。\n作文：《当好自己故事的主角》。\n没有要求，诗歌除外。\n讲真当时剩 50 分钟左右，就认真思考了一下怎么写。其实中考前一直有个执念，我想在中考把自己接受中学教育后写出来的第一篇作文写上去。我尤其记得我的第一篇中学文章是《这里，也是我的舞台》。我这里所说的不是从小学升到初中的第一篇作文，而是第一次脱离了“小学生作文”思想后的第一篇作文。那篇文章给我很深的感触，他给我一种“原来中学作文是这样的”的感觉。\n当然了，素材就是才艺成长类了。可当时对于我很新颖。\n我觉得中考这类素材多了去了，我想创新。但是拿分有什么不好？为什么一定要在中考逞这个能呢？我的字写得好一点，千篇一律的素材也是可以上 40 的呀！况且我有 50 分钟多的时间写。不可能书写会差。\n所以，重新立意，以初三的视角重写这个故事。一笔一划认真写下每一个字。最后写完，有点小兴奋，还剩 5 分钟左右吧，我就去检查了，又回来好好欣赏了一下，面带微笑。\n这是一种见面吧，毕业的我与刚接触中学教育的我的见面。其实十分情绪，有七分兴奋，余下三分是感动。\n是的，我被一个千篇一律的应试作文感动到了。\n考完试直接去打球好吧，打排球。都是我们年级的，都是菜菜，没有鄙视链。来了两个校队的，也是初三的，一男一女，人不错，很热情友好。关键是那个女生好像是我幼儿园同学，问了 flt （他之前和我一个幼儿园），他说也像。\nDay 2\r7 月 1 日。\n上午物理道法正常发挥，反正物理有些坑点，没想象中的简单。道法背的提纲没有几道题押中了……但是都写满了，求 A+。\n下午被数学硬控。\n刚浏览试卷时：“居然问我 $-5+3$ 等于多少这种简单题，这个 120 我拿定了。”\n打完十五分钟铃后：“快点看一眼最后一题就去检查前面吧，后面不要了……”\n算了，就这样吧……\nDay 3\r最后一天啦，化学英语正常发挥，历史超常发挥好吧。\n历史考完后检查了一遍，把一道本来蒙对的选择题改错了。\n然后坐着、放空。我的位置向斜左方可以看到外面，是蓝天绿地。我看到监考老师也挺放松的，在静静发呆。这种感觉真好。想来三年终于要在这里结束了，心里的感觉五味杂陈。好像又轻松、又兴奋、有不知所措。我就这样静静看着窗外，喝几口水，放空自己。让我想起来那次省选的时候。静静地享受着这属于我的 5 分钟。\n“请考生停止答卷……”\n我们监考老师贼早就放我们走了。特别开心！\n我直接飞奔回教室放笔袋、复习资料，然后飞奔去小球场。看到 xcr 已经在等候多时了，一看就是提前交卷了。跑的时候上气不接下气，这应该是我中学跑得最快的一次了。因为体育报的是游泳。我仍然记得那天的裤子很松，我一边提着裤子一边跑，跑过教学楼、跑过饭堂、跑过路人诧异的目光、跑过这初三的尾声……\n虽然但是，打球的时候成功垫起来了一个扣杀球，结果球的机械能太大了，直接飞天，然后就卡在房顶和横梁之间了。用球砸，差一点；好不容易上去了，但是现在是两个球都在上面了……\n借了竹竿，可算捅下来了。\n去吃饭路上同 flt 的对话：\n“我回家要把这几天写一篇游记出来。”\n“你不觉得有些事写出来就变无趣了吗？”\n“……不会啊。”\n晚上搞了超级狂欢晚会，其实也没有超级狂欢。游戏挺好玩的，就是这个“你画我猜”太折磨我啦！中途和 gbj 在年级溜了一圈，聊了一下。回来欣赏歌曲，合唱了一些小歌曲。\n啊。\n好羡慕他们有一技之长的人啊。\n为什么我没有才艺呢。如果抽到我上去了，我能一展歌喉或者说弹一曲好吉他吗？\n“没事啊，你不一定要成为那样的人。”\n也对，我自有我发光的地方。\nDay 4\r毕业典礼，同学们还是才艺多多啊。老师的合唱也很给力啊！结束之前被老师委托将花拿去校长办公室，YES！获得早退资格！\n考完了直接填志愿好吧。\n什么，你问志愿填报会？\n没有那种繁琐的东西，直接无脑填 DY 就好了。\n挑了个好时机，去的时候刚好没人搞，三两下就搞定了。在这之前还在班里看了一点点《扬名立万》的电影。好看！\n搞定就回家了，吃了顿好饱好饱的麦当劳！那种被炸鸡噎到的感觉真的太——难受了。下次不吃这么猛了。\n至此，7 月 3 日，初中就结束啦~，我也如愿拿到了我中考前订做的手表，现在戴在了我的手上。\n初中真的有很多很多想说的吗？\n其实也没有，因为高中仍然是身边的这些同学，老师也可以随时找到，其实离别什么的没有太大情感。\n至于分数嘛。\n特意没估分。等 7.20 出成绩了在更新吧。\n那么，中考，到此结束！\n抬眼，是新的征程！\n“考试结束，请考生停止作答！……”\n","date":"2024-07-04T00:02:00+08:00","permalink":"https://werchange.github.io/p/%E4%B8%AD%E8%80%832024-%E6%B8%B8%E8%AE%B0/","title":"中考2024 游记"},{"content":"猜排列 题解\r差 eps 步想到正解。\n题意描述\r有 $m$ 个长为 $n$ 序列 $a_1,\\dots,a_n$，还有 $m$ 个长为 $n$ 序列 $b_1,\\dots,b_n$。\n其中 $b_i$ 是由 $a_i$ 通过排列 $p$ 置换得到的，$b_{p_i}=a_i$。\n现在又要求出排列 $p$ 会有多种可能，模 $998244353$。\nSolution\r首先手玩样例，发现如果这 $m$ 次 $a$ 的某个位置和 $b$ 的某个位置都是相等的，可以确保一定有一种可能的 $p$ 排列使他们就是通过置换得到的。\n有点像二分图，连个边再说。\n发现有些位置是可以同时连不同的位置的（那当然了，不然答案就是唯一的，输出 $1$ 就好了），这时发现，对面也可以向我们连边。而无论哪个样例，似乎连出来的二分图都是一个部的每个点都连向了另一个部的每个点。\n那这个子图贡献的就是子图所有点 $\\div 2$ 的数量的阶乘。（就全排列嘛，除以二是因为二分图上下两部的点的数量是对称的）\n考场就想到这里，发现如果要找子图的话是 $O(n^2m)$ 的。含泪 80pts。\n差那一步呢？\n我们发现，同一位上的 $m$ 次可以压成哈希。这样的话如果本来就是同一子图，那哈希值相等。\n也不用建图了，因为可用 map 统计点数，不需要把图真正建出来去跑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N = 6e5 + 5, P = 998244353, base = 19491001, P0 = 20090327, P1 = 20070923; int T, n, m; int fac[N], inv[N], cnt[N]; bool vis[N]; unsigned int a[N][2], b[N][2]; int su, en[N], lt[N], hd[N]; map\u0026lt;pair\u0026lt;unsigned int, unsigned int\u0026gt;, unsigned int\u0026gt; mp1, mp2; map\u0026lt;pair\u0026lt;unsigned int, unsigned int\u0026gt;, bool\u0026gt; Vis; void add(int u, int v) { en[++su] = v, lt[su] = hd[u], hd[u] = su; } void init() { fac[0] = 1; for (int i = 1; i \u0026lt;= N - 5; i++) fac[i] = fac[i - 1] * i % P; } inline void solve() { memset(a, 0, sizeof a); memset(b, 0, sizeof b); scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x; for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); a[j][0] = (1ll * a[j][0] * base + x) % P0; a[j][1] = (1ll * a[j][1] * base + x) % P1; } for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); b[j][0] = (1ll * b[j][0] * base + x) % P0; b[j][1] = (1ll * b[j][1] * base + x) % P1; } } mp1.clear(), mp2.clear(); Vis.clear(); for (int i = 1; i \u0026lt;= n; i++) mp1[{ a[i][0], a[i][1] }]++, mp2[{ b[i][0], b[i][1] }]++; int ans = 1; for (int i = 1; i \u0026lt;= n; i++) { if (!Vis[{ a[i][0], a[i][1] }]) { Vis[{ a[i][0], a[i][1] }] = 1; if (mp1[{ a[i][0], a[i][1] }] != mp2[{ a[i][0], a[i][1] }]) ans = 0; else ans = ans * fac[mp1[{ a[i][0], a[i][1] }]] % P; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); } signed main() { // freopen(\u0026#34;interact.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); // freopen(\u0026#34;interact.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); init(); while (T--) solve(); return 0; } ","date":"2024-06-08T15:23:00+08:00","permalink":"https://werchange.github.io/p/%E7%8C%9C%E6%8E%92%E5%88%97-%E9%A2%98%E8%A7%A3/","title":"猜排列 题解"},{"content":"按按钮题解\r在量体温，打不了代码，来写题解。\n赞美 lwq，三句话让我跟上了课堂节奏。\n题意\r数轴 $n$ 个按钮，第 $i$ 个按钮在坐标 $i$。有 $m$ 次询问，$i$ 询问为在时刻 $t_i$ 按下 $b_i$。\n可以在时刻 $0$ 安排一些机器人，机器人可以花 $1$ 单位时间向左或右移动 $1$ 个单位。机器人按下按钮不需要时间。\n问最初最少安排多少个机器人。\nSolution\r每个按钮在被按后，改点的机器人可以走到的范围是一个区间。\n$$\r[b_i+Max-t_i,b_i-(Max-t_i)]\r$$ 其中 $Max$ 为最大的 $t_i$。\n接着，如果这些区间里存在一些小区间被一个大区间完全覆盖，那么这些小区间的任务可以都交给一个机器人去做。\n思路到此就很清晰了，即求一个最小集，这个集合里都是互不完全包含的区间。答案即这个集合的大小。\n怎么做呢？\n区间按左端点从小到大、右区间从大到小排序，然后树状数组处理一下就好了。\n时间复杂度 $O(n\\log n)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pii pair\u0026lt;int,int\u0026gt; #define ft first #define sd second const int N=5e6+5; int n,m; int t[N],b[N]; pii a[N]; int tr[N]; int tmp[N],tot; map\u0026lt;int,int\u0026gt; Hs; void add(int x,int k) {for(;x\u0026lt;=tot;x+=x\u0026amp;-x)tr[x]=max(tr[x],k);} int query(int x) {int c=0;for(;x;x-=x\u0026amp;-x)c=max(c,tr[x]);return c;} bool cmp(pii x,pii y) { if(x.ft!=y.ft) return x.ft\u0026lt;y.ft; return x.sd\u0026gt;y.sd; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); int Max=0; for(int i=1;i\u0026lt;=m;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;t[i]),Max=max(Max,t[i]); for(int i=1;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;b[i]); tmp[++tot]=b[i]-(Max-t[i]); tmp[++tot]=b[i]+Max-t[i]; } sort(tmp+1,tmp+tot+1); for(int i=1;i\u0026lt;=tot;i++) Hs[tmp[i]]=i; for(int i=1;i\u0026lt;=m;i++) { a[i].ft=Hs[b[i]-(Max-t[i])]; a[i].sd=Hs[b[i]+Max-t[i]]; } sort(a+1,a+m+1,cmp); for(int i=1;i\u0026lt;=m;i++) add(a[i].sd,query(a[i].sd-1)+1); printf(\u0026#34;%lld\\n\u0026#34;,query(tot)); return 0; } ","date":"2024-06-04T21:33:00+08:00","permalink":"https://werchange.github.io/p/%E6%8C%89%E6%8C%89%E9%92%AE%E9%A2%98%E8%A7%A3/","title":"按按钮题解"},{"content":"【NOI2010】能量采集 题解\r谨纪念我的第一道手推出来的莫反题。\n题目大意：已知 $n$，$m$，求 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m(2\\cdot \\gcd(i,j)-1)$。\n首先变形一手：\n$$\r\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m(2\\cdot\\gcd(i,j)-1)=2\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\gcd(i,j)-n\\times m\r$$ 然后我们只用求出中间那两个 $\\sum$ 就好了。\n$$\r\\begin{aligned}\r\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\gcd(i,j)\u0026=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d=1}^nd[\\gcd(i,j)=d]\\\\\r\u0026=\\sum\\limits_{d=1}^nd\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}[\\gcd(i,j)=1]\\\\\r\u0026=\\sum\\limits_{d=1}^nd\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\sum\\limits_{x|\\gcd(i,j)}\\mu(x)\\\\\r\u0026=\\sum\\limits_{d=1}^nd\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(x)\\lfloor\\frac{n}{dx}\\rfloor\\lfloor\\frac{m}{dx}\\rfloor\r\\end{aligned}\r$$ 令 $T=dx$，\n$$\r\\begin{aligned}\r\\sum\\limits_{d=1}^nd\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(x)\\lfloor\\frac{n}{dx}\\rfloor\\lfloor\\frac{m}{dx}\\rfloor\r\u0026=\\sum\\limits_{d=1}^nd\\sum\\limits_{T=1}^n\\mu(\\frac{T}{d})\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor[d|T]\\\\\r\u0026=\\sum\\limits_{T=1}^n\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor\\sum\\limits_{d=1}^nd\\cdot\\mu(\\frac{T}{d})[d|T]\\\\\r\u0026=\\sum\\limits_{T=1}^n\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor\\sum\\limits_{d|T}d\\cdot\\mu(\\frac{T}{d})\r\\end{aligned}\r$$ 如何处理后面那个 $\\sum$，考虑狄利克雷卷积。不会的可以看我博客。\n因为 $\\varphiI=Id_1$，又因 $I\\mu=\\epsilon$，所以\n$$\r\\varphi=Id_1*\\mu\r$$ 注意到右边那个 $\\sum$ 其实就是 $Id_1*\\mu$，即 $\\varphi$。\n所以可化为：\n$$\r\\sum\\limits_{T=1}^n\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor\\sum\\limits_{d|T}d\\cdot\\mu(\\frac{T}{d})=\\sum\\limits_{T=1}^n\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor\\cdot\\varphi(T)\r$$ 很明显的整除分块，预处理 $\\varphi$ 的前缀和就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N=1e5+5; int n,m; int cnt,pri[N],phi[N],mu[N],sum[N]; bool flg[N]; void init() { mu[1]=1,phi[1]=1; for(int i=2;i\u0026lt;=N-5;i++) { if(!flg[i]) pri[++cnt]=i,phi[i]=i-1,mu[i]=-1; for(int j=1;j\u0026lt;=cnt\u0026amp;\u0026amp;pri[j]*i\u0026lt;=N-5;j++) { flg[i*pri[j]]=1; if(i%pri[j]==0) { phi[i*pri[j]]=phi[i]*pri[j]; break; } mu[i*pri[j]]=-mu[i]; phi[i*pri[j]]=phi[i]*phi[pri[j]]; } } for(int i=1;i\u0026lt;=N-5;i++) sum[i]=sum[i-1]+phi[i]; } int work(int n,int m) { if(n\u0026gt;m) swap(n,m); int res=0; for(int l=1,r;l\u0026lt;=n;l=r+1) { r=min(n/(n/l),m/(m/l)); res+=(sum[r]-sum[l-1])*(n/l)*(m/l); } return res; } signed main() { init(); scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); printf(\u0026#34;%lld\\n\u0026#34;,2*work(n,m)-n*m); return 0; } ","date":"2024-05-25T16:40:00+08:00","permalink":"https://werchange.github.io/p/noi2010%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86-%E9%A2%98%E8%A7%A3/","title":"【NOI2010】能量采集 题解"},{"content":"莫比乌斯反演速通\r前言\r由于请假错过了讲课，所以莫反是我第一个需要自学的难度不小的数学知识。\n自学的过程的狼狈的，旁边也曾是自学的 czn 告诉我如果学会“狄利克雷卷积”就可以对“莫比乌斯反演”的理解进行“降维打击”。他还十分热心地带着我速通了一遍狄卷与莫反。\n一知半解，就自学了很多资料。终于是补全了每一块知识碎片。\n秉着造福后人的原则，我想写一篇非常非常通俗易懂的学习笔记。\n易懂到什么程度呢？——就是初一的同学，也能速通。\n食用指南：备好草稿纸，遇到式子先自己推导，培养推式子的习惯。\n数论函数\r这是狄利克雷卷积（后文简称“狄卷”）的前置知识。\n数论函数是一类这样的函数：定义域为正整数，值域是一个数集。\n数论函数间的简单运算有加法与数乘。\n加法：定义为两个函数逐位相加。$(f+g)(n)=f(n)+g(n)$ 数乘：定义为其函数每位都乘一个数。$(xf)(n)=x\\cdot f(n)$ 狄利克雷卷积\r狄卷是数论函数间的运算，记为：\n$$\rf*g=h\r$$ 等号左侧展开为：\n$$\rf*g=\\sum\\limits_{i|n}f(i)\\cdot g(\\frac{n}{i})\r$$ 一些运算律\r交换律：$fg=gf$，这个显然。\n结合律：$(fg)h=f(gh)$，因为：\n$$\r\\sum\\limits_{i\\cdot j\\cdot k=n}(f(i)g(j))\\cdot h(k)=\\sum\\limits_{i\\cdot j\\cdot k=n}f(i)\\cdot (g(j)h(k))\r$$ 分配律：$fh+gh=(f+g)*h$，因为：\n$$\r\\begin{aligned}\rf*h+g*h\u0026=\\sum\\limits_{i|n}f(i)h(\\frac{n}{i})+\\sum\\limits_{i|n}g(i)h(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} f(i)h(\\frac{n}{i})+g(i)h(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} (f(i)+g(i))\\cdot h(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} (f+g)(i)\\cdot h(\\frac{n}{i})\\\\\r\u0026=(f+g)*h\r\\end{aligned}\r$$ 一些函数意义\r$\\varphi(n)$：$[1,n]$ 中与 $n$ 互质的数的个数。 性质：$\\varphi(1)=1$，$\\varphi(n)=n-1$ 当且仅当 $n$ 为质数。\n$\\mu(n)$：莫比乌斯函数。 定义：\n$\\mu(n)=1$，（$n=1$） $\\mu(n)=(-1)^k$，（$n=\\prod\\limits _{i=1}^{k} p_i$ 且 $p_i$ 为指数为 $1$ 的质数） $\\mu(n)=0$，（其他情况） $Id_k(n)$：幂函数，$Id_k(n)=n^k$。\n$\\sigma_k(n)$：$n$ 的所有因数的 $k$ 次方和。\n$\\epsilon(n)$：值为 $[n=1]$。即当且仅当 $n=1$ 时值为 $1$，否则为 $0$。\n$d(n)$：$n$ 的所有因数个数，即 $\\sigma_0(n)$。\n$I(n)$：常函数，值恒为 $1$，即 $Id_0(n)$。\n这里说明一下第七条，在一些参考书中写作 $\\mathbf{1}(n)$，本文为了区分函数与常数，这里用 $I(n)$ 代替 $\\mathbf{1}(n)$。\n一些式子\r这里会有很多公式，可以再看证明之前自己先证一遍，难度从易到难。\n式子一：$(xf)g=x(fg)$，因为：\n$$\r\\begin{aligned}\r(xf)*g\u0026=\\sum\\limits_{i|n} (xf)(i)\\cdot g(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} x\\cdot f(i)\\cdot g(\\frac{n}{i})\\\\\r\u0026=x\\cdot \\sum\\limits_{i|n} f(i)g(\\frac{n}{i})\\\\\r\u0026=x(f*g)\r\\end{aligned}\r$$ 式子二：$f*\\epsilon=f$，因为：\n$$\r\\begin{aligned}\r(f*\\epsilon) (n)\u0026=\\sum\\limits_{i|n} f(i)\\epsilon(\\frac{n}{i})\\\\\r\u0026=f(n)\r\\end{aligned}\r$$ 式子三：$I*I=d$，因为：\n$$\r\\begin{aligned}\rI*I\u0026=\\sum\\limits_{i|n} I(i)I(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} 1\\\\\r\u0026=d\r\\end{aligned}\r$$ 式子四：$I*Id_k=\\sigma_k$，因为：\n$$\r\\begin{aligned}\rI*Id_k\u0026=\\sum\\limits_{i|n} I(i)Id_k(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} Id_k(i)\\\\\r\u0026=\\sigma_k\r\\end{aligned}\r$$ 式子五：$\\mu*I=\\epsilon$，因为：\n$$\r\\begin{aligned}\r\\mu*I\u0026=\\sum\\limits_{i|n} \\mu(i)I(\\frac{n}{i})\\\\\r\u0026=\\sum\\limits_{i|n} \\mu(i)\r\\end{aligned}\r$$ 当 $n=1$，显然成立。 当 $n\\neq 1$，将 $n$ 分解为 $n=p_1^{m_1}p_2^{m_2}\\dots p_k^{m_k}$。 计算有效的 $\\mu$，肯定质因子的指数为 $1$。 所以每次在 $k$ 个质因数选择 $r$ 个，即 $C_k^r$ 个。 那就可以继续推式子了。 $$\r\\begin{aligned}\r\\sum\\limits_{i|n} \\mu(i)\u0026=C_k^0-C_k^1+C_k^2-C_k^3+\\dots +(-1)^kC_k^k\\\\\r\u0026=\\sum\\limits_{i=0}^k (-1)^iC_k^i\\\\\r\u0026=(1-1)^k=0\r\\end{aligned}\r$$ 因此，$\\mu *I=\\sum\\limits_{i|n} \\mu(i)=[n=1]=\\epsilon$。\n这里解释一下是怎么得到 $(1-1)^k$ 的：\n二项式定理：$(x+y)^k=\\sum\\limits_{i=0}^k C_k^ix^{k-i}y^i$。\n这里把 $x=1$，$y=-1$ 带进去得证。\n式子六：$\\varphi*I=Id_1$，因为：\n设 $p$ 为质数，$m\u0026gt;0$，则：\n$$\r\\begin{aligned}\r(\\varphi*I)(p^m)\u0026=\\sum\\limits_{i|p^m} \\varphi(p^m)\\\\\r\u0026=\\sum\\limits_{i=0}^m \\varphi(p^i)\\\\\r\u0026=p^0+\\sum\\limits_{i=1}^m \\varphi(p^i)\\\\\r\u0026=p^0+\\sum\\limits_{i=1}^m (p^i-p^{i-1})\\\\\r\u0026=p^m\r\\end{aligned}\r$$ 因为 $n$ 可分解为 $p_1^{m_1}p_2^{m_2}\\dots p_k^{m_k}$，可由积性函数的性质得证 $(\\varphi*I)(n)=n=Id_1(n)$。\n即 $\\varphi*I=Id_1$。\n式子七：$\\varphi=\\mu*Id_1$。\n这个留作作业，答案放在文尾。\n简单性质\r上文的式子二、四、六就是主要性质，除此之外还有积性函数性质：\n若 $f$，$g$ 为积性函数，则 $f*g$ 也为积性函数。\n狄利克雷的逆元\r对于每个 $f(1)\\ne 0$ 的 $f$，都存在一个 $g$ 使得 $f*g=\\epsilon$。\n如何求 $g$？\n先推一下式子：\n$$\r\\begin{aligned}\rf*g\u0026=\\sum\\limits_{i|n} f(i)g(\\frac{n}{i})\\\\\r\u0026=f(1)g(n)+\\sum\\limits_{i|n,i\\ne 1}f(i)g(\\frac{n}{i})\\\\\r\u0026=\\epsilon=[n=1]\r\\end{aligned}\r$$ 现在目标为定义 $g(n)$ 使得等式成立。\n可以定义：$g(n)=\\frac{1}{f(1)}([n=1]-\\sum\\limits_{i|n,i\\ne 1}f(i)g(\\frac{n}{i}))$。\n$g$ 就是 $f$ 的逆元，也可写作 $f^{-1}$。\n莫比乌斯反演\r莫比乌斯反演公式\r在“狄卷”的“一些函数意义”中我们直接给出了 $\\mu$ 的定义与运算方式。\n但其实是要推的，仅知道的条件是“定义 $I$ 的逆为 $\\mu$”。\n让我们来看看如何用狄卷推出莫反的式子——看看狄卷是怎么降维打击的。\n如果 $g=f*I$，则\n$$\rf=f*I*\\mu=g*\\mu\r$$ 一展开，即：\n如果 $g(n)=\\sum\\limits_{i|n}f(i)$，则\n$$\rf(i)=\\sum\\limits_{i|n}\\mu(i)g(\\frac{n}{i})\r$$ 写得优美一点：\n$$\rg(n)=\\sum\\limits_{i|n}f(i)\\Leftrightarrow f(i)=\\sum\\limits_{i|n}\\mu(i)g(\\frac{n}{i})\r$$ 而这个就是我们的莫反公式了！\n别忘了，我们尚未知道 $\\mu$ 的值，现在来讲讲怎么求。\n由于 $I$ 是积性函数，所以 $\\mu$ 也是积性函数。简单算数可得：\n$$\r\\mu(p^k)=\\begin{cases}\r1 \u0026 k=0\\\\\r-1 \u0026 k=1\\\\\r0 \u0026 k\u003e1\r\\end{cases}\r$$ 再根据积性函数，就得到了：\n$$\r\\mu(n)=\\begin{cases}\r1 \u0026 n=1\\\\\r(-1)^k \u0026 n=p_1p_2\\dots p_k\\\\\r0 \u0026 \\text{other situation}\r\\end{cases}\r$$ 于是华丽结束。\n有没有体味到降维打击呀朋友们！\n莫比乌斯函数的性质\r如果不讲狄卷，这里应该是第二章，但是学过狄卷的我们可以速通以下三个性质。\n$\\sum\\limits_{i|n}\\mu(i)=[n=1]$。这个用 $\\mu*I=\\epsilon$ 秒了。 $n=\\sum\\limits_{i|n}\\varphi(i)$。用 $\\varphi*I=Id_1$ 秒了。 $\\sum\\limits_{i|n}\\frac{\\mu(i)}{i} = \\frac{\\varphi(n)}{n}$。因为 $\\varphi=\\mu*Id_1$，所以展开得 $\\sum\\limits_{i|n} \\frac{\\mu(i)\\cdot n}{i}=\\varphi(n)\\Rightarrow \\sum\\limits_{i|n} \\frac{\\mu(i)}{i}=\\frac{\\varphi(n)}{n}$，秒了。 $\\mu(n)$ 是积性函数，这个上文解释过了。 代码实现预处理 $\\mu$\r$\\mu$ 是积性函数，线性筛带走。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void init(int x) { mu[1]=1; for(int i=2;i\u0026lt;=x;i++) { if(!vis[i]) pri[++cnt]=i,mu[i]=-1; for(int j=1;j\u0026lt;=cnt\u0026amp;\u0026amp;i*pri[j]\u0026lt;=x;j++) { vis[i*pri[j]]=1; if(i%pri[j]==0) break; mu[i*pri[j]]=-mu[i]; } } } 参考文献\r[1]，Mcggvc，《狄利克雷卷积》 [2]，An_Account，《莫比乌斯反演-让我们从基础开始》 [3]，铃悬，《铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演》 式子七答案\r$$\r\\begin{aligned}\r\\varphi\u0026=\\varphi *\\epsilon\\\\\r\u0026=\\varphi*I*\\mu\\\\\r\u0026=Id_1*\\mu\r\\end{aligned}\r$$ 结尾\r有没有感受到用狄卷理解莫反“降维打击”的快感？\n由于我是自学的，有一些地方会有纰漏，欢迎指出。\n没有例题是因为还没去刷，大家如果想锻炼推式子能力可以看参考文献 2。\n","date":"2024-05-21T22:48:00+08:00","permalink":"https://werchange.github.io/p/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%8F%8A%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E9%80%9F%E9%80%9A/","title":"莫比乌斯反演及狄利克雷卷积速通"},{"content":"Solution\rP9030 [COCI2022-2023#1] Berilij\n本题解转载翻译自官方题解：COCI 2022/2023 CONTEST 1\nPart 1\r让我们定义图形 $G$，顶点代表飞船，边代表两艘飞船外部接触的情况。此外，让边的边权成为它所连接的圆之间的距离。\n现在的任务等同于为顶点找到非负值，使得每条边所连接的两个顶点值之和等于这条边的边权，其中顶点值的平方和尽可能小。\n如果顶点 $(i, j)$ 与边权为 $w_{i,j}$ 的边相连，则顶点值的条件 $v_i \\geq 0$，$v_j \\geq 0$ 与 $v_i + v_j = w_{i,j}$ 成立。\nPart 2\r在 Subtask 1 中，$G$ 是一个奇环。由于我们可以计算出每条边的值 $w_{i,j}$，所以我们可以唯一确定环中第二个顶点的值。\n现在我们尝试将第一个顶点的值增加 $x$。为了满足条件，我们现在需要减少第二个顶点的值，然后增加第三个顶点的值……以此类推，直到我们绕回第一个顶点，新的条件是它的值必须是 $a-x$。\n由于 $x = a - x$，我们可以唯一确定 $x$ 为 $x = \\frac{a}{2}$。\n现在我们只需检查将 $\\frac{a}{2}$ 替换为第一个顶点的值是否会导致所有其他顶点的值为非负值。\nPart 3\r在 Subtask 3 中，$G$ 是一个森林，但只需对每棵树分别求解即可。\n为了满足任务的条件，我们现在可以唯一确定每个顶点 $i$ 的值为线性多项式 $\\pm x + c_i$，其中 $c_i$ 是一个常数，其值等于从顶点 $i$ 到根的各条边的交替边权之和。\n由于每个值都必须是非负值，因此 $x + c_i$ 的顶点为 $x$ 设定了下限，而 $-x + c_i$ 的顶点为 $x$ 设定了上限。如果上限小于下限，则无解。为了确定顶点值平方和最小的 $x$，让我们求出每个顶点的线性多项式的平方和。结果是二次多项式 $ax^2 + bx + c$。\n注意，$a$ 等于树的大小，因此二次多项式的最小值为 $x =-\\frac{b}{2a}$。由于这个表达式中没有使用 $c$，而 $b$ 等于每个顶点的 $-2s_ic_i$ 之和，其中 $s_i$ 是多项式 $\\pm x + c_i$ 中 $x$ 前面的符号，因此我们可以计算出 $-\\frac{b}{2a}$，而无需将任何数字平方。如果 $x = -\\frac{b}{2a}$ 在下限和上限之间，则 $x$ 就是我们的解，否则我们取上限或下限中更接近 $-\\frac{b}{2a}$ 的值。\nPart 4\r对于完整的解决方案，让我们按照 Subtask 3 的解决方案来解决任意生成树上每个分量的任务。\n我们注意到，在 Subtask 3 的解法中，从根开始偶数深度的每个顶点的多项式是 $x + c_i$，而奇数深度的每个顶点的多项式是 $-x + c_i$。由于偶环连接不同深度奇偶性的顶点，它们只增加了 $(+x+c_i)+(-x+c_j ) = w_{i,j}$ 形式的条件，换句话说 $c_i + c_j = w_{i,j}$。奇环连接深度奇偶性相同的顶点，并增加了 $(\\pm x + c_i) + (\\pm x + c_j ) = w_{i,j}$ 形式的条件，换句话说，$\\pm x =\\frac{1}{2} (w_{i,j} - c_i - c_j)$，与 Subtask 1 一样，$x$ 的解只有一个。\n时空分析\r所述算法的时间复杂度为 $O(n+m)$。另外，该任务也可以通过更好的三元搜索实现来解决，复杂度为 $O((n+m)log(C\\epsilon ^{-1}))$，其中 $C$ 为坐标的最大绝对值 $C = 10^4$，$\\epsilon$ 为所需精度。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define ld long double #define pb push_back #define ft first #define sd second #define po(x) ((x)*(x)) const int MAXN=1e5+5; const ld eps=1e-8; int n,m; ld sz[MAXN]; ld ans[MAXN]; ld vl[MAXN],A,B,C; ld b[MAXN],c[MAXN]; ld lf[MAXN],rg[MAXN]; int rot[MAXN],dep[MAXN]; bool fitr[MAXN],vis[MAXN]; vector\u0026lt;int\u0026gt; Rt; pair\u0026lt;ld,ld\u0026gt; a[MAXN]; struct edge { int u,v,nxt; bool ontr; ld w; }E[MAXN]; int su=1,hd[MAXN]; void add(int u,int v,ld w) { E[++su]={u,v,hd[u],0,w},hd[u]=su; } ld dis(int x,int y) { return sqrt(po(a[x].ft-a[y].ft)+po(a[x].sd-a[y].sd)); } void findtree(int x,int rt) { sz[rt]++; rot[x]=rt; fitr[x]=1; for(int i=hd[x];i;i=E[i].nxt) { int v=E[i].v; ld d=E[i].w; if(fitr[v]) continue; E[i].ontr=E[i^1].ontr=1; dep[v]=dep[x]+1; vl[v]=d-vl[x]; C+=po(vl[v]); if(dep[v]\u0026amp;1) rg[rt]=min(rg[rt],vl[v]),b[rt]-=2*vl[v]; else lf[rt]=max(lf[rt],-vl[v]),b[rt]+=2*vl[v]; if(rg[rt]+eps\u0026lt;=lf[rt]) { puts(\u0026#34;NE\u0026#34;); exit(0); } findtree(v,rt); } } void pushans(int x) { vis[x]=1; for(int i=hd[x];i;i=E[i].nxt) { int v=E[i].v; if(vis[v]||E[i].ontr==0) continue; if(dep[v]\u0026amp;1) lf[v]=rg[v]=vl[v]-rg[rot[v]]; else lf[v]=vl[v]+lf[rot[v]],rg[v]=vl[v]+rg[rot[v]]; pushans(v); } } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%Lf%Lf\u0026#34;,\u0026amp;a[i].ft,\u0026amp;a[i].sd); for(int i=1;i\u0026lt;=m;i++) { int x,y; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y); add(x,y,dis(x,y)); add(y,x,dis(x,y)); } for(int i=1;i\u0026lt;=n;i++) { if(fitr[i]) continue; vl[i]=0; rg[i]=LDBL_MAX; findtree(i,i); Rt.pb(i); } for(int i=2;i\u0026lt;=su;i+=2) { if(E[i].ontr) continue; int X=E[i].u,Y=E[i].v; if((dep[X]\u0026amp;1)==(dep[Y]\u0026amp;1)) { ld x=(E[i].w-(vl[X]+vl[Y]))/2; if(dep[X]\u0026amp;1) x*=-1.0; int rt=rot[X]; ld l=lf[rt],r=rg[rt]; if(x+eps\u0026lt;=l||r+eps\u0026lt;=x) return puts(\u0026#34;NE\u0026#34;),0; lf[rt]=rg[rt]=x; } else { if(abs(vl[X]+vl[Y]-E[i].w)\u0026gt;eps) return puts(\u0026#34;NE\u0026#34;),0; } } for(int i:Rt) { A=sz[i],B=b[i],C=c[i]; ld x=-B/(2*A); ld l=lf[i],r=rg[i]; if(x+eps\u0026lt;=l|abs(x-l)\u0026lt;eps) rg[i]=lf[i]; else if(r+eps\u0026lt;=x||abs(x-r)\u0026lt;eps) lf[i]=rg[i]; else lf[i]=rg[i]=x; pushans(i); } printf(\u0026#34;DA\\n\u0026#34;); for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%.6Lf\\n\u0026#34;,abs(lf[i])); return 0; } ","date":"2024-05-07T21:27:00+08:00","permalink":"https://werchange.github.io/p/coci2022-2023","title":"[COCI2022-2023#1] Berilij 题解"},{"content":"GDOI2024 游记\rDay -6\r元宵节，得知自己可以参加 GDOI，惊喜坏了。\n要知道，我 CSP-S 2=，NOIP 没参加。居然去了 GDOI！\n真的有很多很多想说的话，非常非常感谢教练。但是这里不作抒情了，“此中有真意，欲辨已忘言”。\nDay -4\r知道可以参加 GDOI，肯定疯狂卷卷题、刷刷数据结构呀（虽然并没有什么用）。\n但是开学考。计划打乱。重新制定计划。\nDay -1\r这一整天都非常兴奋，感觉肾上腺素飙升。晚上在机房还是复习了一会儿，思考了一下比赛计划。\nDay 0\r到了松山湖中学，学校是老学校了，建在山上，走了好远。\ncjx 一路上拍拍拍（拍照），你看，这就是进省队的苗子——大考当前仍然心态如此平和。\n试了机，敲了一遍区修区查线段树。不得不说这个 DEV 依旧很痛苦，没有 vscode 好用。这个键盘的键程也太长了，敲完几十行的代码还是没怎么适应。\n虽然区修区查 pushdown 打挂了，但是很快调了过来，然后就结束了。试机还算顺利，就是旁边那老哥的凳子太靠我这边了。\nDay 1\r上午\r有了昨天的经验，我提前进了考场，抢在那老哥之前坐下，让他无便宜可占。\n看 T1，觉得可做就打了。看起来是二分。\n后面调的时候看到不止一个峰，所以无脑三分。\n打完了又发现好像多峰，不知道怎么办，随便套了个 for 循环三分，打完就跑了。此时还剩 1.5h，我不想重蹈 CSP-S2023 的覆辙。\nT2 暴力分，拿了之后思考了一下性质。打了、调了，差不多了就看 T3。\nT3 真的不懂，虽然暴力分可打，但是当我打完 T3 输入的时候只剩 10min。随便全部输出 0，跑路。\n跑去检查文操，checker 一遍。然后关闭程序，静静等待这最后的 5 min。\n出来考场的时候腿都在抖，想着 Day1 一道题也没切怎么办。\n说来也怪，考前、考时都不紧张，一结束就紧张地打颤。\n下午\r后来听 blln 说好像 $O(n)$ 扫一遍，就可以解决。或许是吧。\n食堂还是挺好吃的，虽然猪扒（牛扒？）吃起来像科技，但管他呢，好吃。嗝。\n下午就去骑行松山湖，环湖骑了一圈。\n不得不说真的景色很好看，还有西式建筑，估计是华为总部的一些建筑。玩了一下午，心情真的放松多了。\n晚上简单打了道 cdq，都不记得晚上还有 AtCoder，大失败。\nDay 2\r上午\r依旧早到，精神有点不佳，趴在桌上眯了一会儿，直到监考老师宣读规则。\nT1 明显比昨天难，我想着今天肯定更不可能切一道题，但此刻我很冷静，甚至还有点放松：可以好好享受这 4.5h 的思考了。\n光速看完 T2、T3，没有什么头绪，还是 T1 可做，开打。\n看着性质打，每个性质、每个数据梯度都思考了，然后算出来这样下去 T1 可以拿 70pts。\n当时第一次算算成了 50pts，但还是快乐开打。后面一个一个性质打完，快乐地过了 3 个大样例，就是第 3 个死活过不去。\n我不清楚是该弃疗还是坚持。我就又去看看 T2、T3。\n好吧。\n坚持的勇气是 T2、T3 给的。\n调调调，终于调对了，并且稳过手造数据。\n真的，当你 4 次 fc maze.out maze.ans 都是找不到文件差异的时候，那种感觉简直起飞！重算了一遍部分分，居然有 70pts！！\n第 5 个大样例没过，我也不打算调了，因为样例大、时间少，更何况我的计划并没打算死磕 T1。而且如果我死磕 T1，据我的比赛经验来看，这样的效益最低（详见 CSP-S2023）。\n后面 T2 表了个 1，没想到云斗有 5pts！高兴坏了。\nT3 也是全部表 1，这是一场豪赌。\n比赛还剩 12min 吧，我也不打算思考了，并不是不乐意去想，而是万一我又有点头绪，却苦于没时间打，那种折磨劝退了我。\n况且我怎么可能做到 10min 切紫/黑呢？\n检查完后就提前关掉所有程序，回到桌面，静静看着大屏上时间一点一点的消逝，享受这来之不易的 GDOI 考场上最后的 10min。\n一瞬间闪过一个念头：我想参加 NOI 了。\n结束了，出来的时候上了个厕所，回来就发现德芙和士力架被拿完了……\n还是在发抖，拿了个牛角包，去吃饭。\n下午\r下午就坐车回校了，这两天的感冒也好了（虽然和我同住的 hzx 感冒了）。\n车上也不知道是抽了还是怎样，竟然开始和 wzy 玩蛋仔派对。\nDK 中途加入，谁知道 DK 还是个蛋仔派对高手。\n一到校就晕车了，洗了热水澡，来机房看看云斗，GDOI 就算正式结束了。\nDay 5\r估分：50+12+0+40+5+0=107。\n不是？T1 挂得也太惨了吧，估的 70pts 呢？我的 30pts 呜呜。\n今年 GDOI 算是结束了，上文化课的时候还是会梦回考场，以及住酒店的欢乐。\n希望今年再努力一点吧，实现我在考场中一闪而过的念想：我想去 NOI。\n文末再次感谢教练 Orz。\nThe End.\n","date":"2024-03-05T19:27:00+08:00","permalink":"https://werchange.github.io/p/gdoi2024-%E6%B8%B8%E8%AE%B0/","title":"GDOI2024 游记"},{"content":"可持久化线段树\r前言\r这个东西之前讲过，但是用得少，很快就忘了。\n我又看了我之前的那篇笔记，简直就是胡言乱语。所了解的太浅了。\n最近在刷数据结构，于是决定再写一篇。\n但是，之前那篇不打算删了，想看黑历史的可以去看。\n算法概要\r可持久——即可以保存历史版本。\n我们如何得到一棵可以保存历史数据的树呢？最笨的方法就是每个操作之后都建一棵线段树。\n如何优化？\n发现我们可以共用前面建好的结构，无需重新建树。\n主席树\r主席树是可持久化线段树的一种，由黄嘉泰发明，因名字缩写而被称为主席树。\n主席树一开始是用来处理区间第 $k$ 小的问题。\n一句话概要思想：一棵权值线段树是由不在同一层的从根到叶子结点的链构成。\n什么意思呢？\n可以理解成一条时间轴将根节点穿起来，每个根节点都是一个历史版本的入口，每个历史版本都可以沿用以前的节点结构。\n实现主席树——建树\r难点其实就是建树，因为这与主席树的思想紧紧相关。\n每次插入一个信息，就将它从根节点到叶子结点的这条链新建出来（权值线段树）。\n当然，这条链上的节点都是新建，因为这是一个新的历史版本；其他节点就沿用以前的节点。\n例 1 区间第 $k$ 小\rP3834 【模板】可持久化线段树 2\n怎么做呢？\n我们可以按顺序插入数组中的每个元素。\n这样的话就有 $n$ 个历史版本。\n当我们想知道 $[l,r]$ 的第 $k$ 小时，我们可以只关注版本 $l-1$ 和版本 $r$。\n这样的话，又因为这是棵权值线段树，所以可以通过当前节点的 $size$ 之差来判断第 $k$ 小在什么地方。\n注意，本题不带修。\n带修怎么办呢？看例 3。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=2e5+5,INF=1e9; int n,m,tot; int a[MAXN]; int rts[MAXN]; struct TREE { int lc,rc,sz; }tr[MAXN\u0026lt;\u0026lt;5]; void pushup(int rt) { tr[rt].sz=tr[tr[rt].lc].sz+tr[tr[rt].rc].sz; } void update(int \u0026amp;rt,int lst,int l,int r,int val) { rt=++tot; tr[rt]=tr[lst]; if(l==r) tr[rt].sz++; else { int mid=(l+r)\u0026gt;\u0026gt;1; if(val\u0026lt;=mid) update(tr[rt].lc,tr[lst].lc,l,mid,val); else update(tr[rt].rc,tr[lst].rc,mid+1,r,val); pushup(rt); } } int query(int r1,int r2,int l,int r,int k) { if(l==r) return l; int lc1=tr[r1].lc,lc2=tr[r2].lc; int mid=(l+r)\u0026gt;\u0026gt;1; int tmp=tr[lc2].sz-tr[lc1].sz; if(tmp\u0026gt;=k) return query(lc1,lc2,l,mid,k); return query(tr[r1].rc,tr[r2].rc,mid+1,r,k-tmp); } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); update(rts[i],rts[i-1],-INF,INF,a[i]); } for(int i=1;i\u0026lt;=m;i++) { int x,y,z; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z); printf(\u0026#34;%lld\\n\u0026#34;,query(rts[x-1],rts[y],-INF,INF,z)); } return 0; } 例 2 可持续化数组\rP3919 【模板】可持久化线段树 1（可持久化数组）\n这个就是很简单的了，不用权值线段树。\n首先对于原数组建线段树，称为历史版本 0。\n然后对于 $m$ 次操作，每次都是一个历史版本；如果是查询操作，就复制前一个一模一样的。\n剩下的就是中规中矩了，就是建一条链，其他节点就沿用。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; // #define int long long #define ls tr[rt].lc #define rs tr[rt].rc const int MAXN=2e6+5; int n,m; int a[MAXN],rts[MAXN*20]; struct HJT { int lc,rc,val; }tr[MAXN*20]; int tot; void build(int \u0026amp;rt,int l,int r) { rt=++tot; if(l==r) return tr[rt].val=a[l],void(); int mid=l+r\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); } void update(int \u0026amp;rt,int old,int l,int r,int x,int k) { rt=++tot; tr[rt]=tr[old]; if(l==r) return tr[rt].val=k,void(); int mid=l+r\u0026gt;\u0026gt;1; if(x\u0026lt;=mid) update(ls,tr[old].lc,l,mid,x,k); else update(rs,tr[old].rc,mid+1,r,x,k); } int query(int rt,int l,int r,int x) { if(l==r) return tr[rt].val; int mid=l+r\u0026gt;\u0026gt;1; if(x\u0026lt;=mid) return query(ls,l,mid,x); return query(rs,mid+1,r,x); } signed main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); build(rts[0],1,n); for(int i=1,old,op,x,k;i\u0026lt;=m;i++) { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;old,\u0026amp;op,\u0026amp;x); if(op==1) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); update(rts[i],rts[old],1,n,x,k); } else printf(\u0026#34;%d\\n\u0026#34;,query(rts[i]=rts[old],1,n,x)); } return 0; } 例 3 区间第 $k$ 小（带修）\r首先你要知道树状数组是个什么东西。\n这里要用到它的思想。\n题面\r给定一个长度为 $n$（$n \\leq 50,000$）的数组 $a_1 , a_2 \u0026hellip; ,a_n$ 和 $q$（$q \\leq 10,000$）此询问，每次询问：\nQ i j k 表示区间 $[i,j]$ 中第 $k$ 小的数是多少，并输出这个数 C i t 表示将第 $i$ 个数改为 $t$ Solution\r首先考虑最笨的办法，就是修改这个历史版本后，它后面的所有版本都跟着改写。\n怎么优化呢？\n想起树状数组就是通过类树分区间管辖，所以可以做到 $O(\\log n)$。\n那这里也可以沿用这种思想，就是分区间管辖，每次改写就改写管辖他们的“大哥”，查询的时候在下放。\n概要就是这么个概要，洛谷上没有这道题，我也不打算写代码（看起来很麻烦的样子），自己去写吧（雾）。\n参考文献\r[1] zcysky，《题解 P3919 【【模板】可持久化数组（可持久化线段树/平衡树）】》 结尾\r先草草结束吧，可能未来还会写可持久化平衡树什么的，也不确保这次一定就完全掌握了主席树。\n先这样吧，多卷题，时而温故而知新。\n","date":"2024-02-25T21:47:00+08:00","permalink":"https://werchange.github.io/p/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91-2/","title":"可持久化线段树 2"},{"content":"引入\r这是由 DengDuck 总结整理的一种处理线段树类问题的算法。\n板题引入\r给定数列 $A{a_i}$ 和 $B{b_i}$。\n其中有以下操作：\nC l r z：$a_i\\leftarrow a_i+z$，$i\\in [l,r]$\nQ l r：$\\sum\\limits_{i=l}^r a_i\\times b_i$\n算法概要\r先预处理 $B$ 的前缀和 $sum_i$。\n对于每一个线段树上的区间的修改实际上就是 $z\\times sum_{[l,r]}$。\n然后懒标记依旧下传 $z$，pushdown 操作就同理了。\n","date":"2024-02-24T09:41:00+08:00","permalink":"https://werchange.github.io/p/dk-%E6%A0%91/","title":"DK 树"},{"content":"[ARC145E] Adjacent XOR 题解\r这道题真的是道神仙题，是那种考场想不出来、补题也补得十分艰难的题。可能我还是太菜了。\n看了 APJ 大神的题解，琢磨很久才懂。为了帮助像我一样的同学，特地写一篇题解。\n这是 2 月的第一篇题解、更是我的第一道黑题题解，谨纪念。\n参考文献\r[1] APJifengc，「解题报告」[ARC145E] Adjacent XOR 题意\r给你 $n$ 个整数 $a_1,a_2,\\dots,a_n$，再给你 $n$ 个整数 $b_1,b_2,\\dots,b_n$。通过执行以下操作，问你能不能操作 $70000$ 次以内使得 $a$ 与 $b$ 相同。\n操作：选择整数 $k\\in[1,n]$，进行 $a_i\\leftarrow a_{i-1}\\oplus a_i$，$i\\in[2,k]$ 的赋值操作。 数据范围：$2\\le n\\le 1000$，$0\\le a_i,b_i \\lt 2^{60}$。\nSolution\r转化目标\r题意清晰，就是告诉你要构造方案。\n由于每一次操作都是 $a_i\\leftarrow a_{i-1}\\oplus a_i$，这个及其难下手。不妨反过来，从 $b$ 入手。\n在此之前，先琢磨透这个在 $a$ 上做手脚的操作，到底是个啥？\n其实一次操作，钦定 $k$ 以后，就是去把每一个在 $[2,k]$ 的 $a_i$ 都赋值为原 $a$ 数组下标从 $1\\sim i-1$ 的异或和。\n而我们对 $a_i$ 做手脚，是因为我们期望得到 $b_i$。这个对 $a$ 数组的操作，每次都依靠前缀。\n形式化地，这样：\n$$\rb_1=a'_1=a_1\\\\b_2=a'_2=a_1\\oplus a_2\\\\b_3=a'_3=a_1\\oplus a_2\\oplus a_3\\\\\\dots\\\\b_i=a'_i=\\oplus_{j=1}^i a_j\r$$ 现在考虑从 $b$ 入手，从而推出 $a$。那么题意变为：\n选择 $k\\in[1,n]$，进行 $b_i=\\oplus_{j=1}^i b_j$，$i\\in[1,k]$ 的赋值操作。\n为什么这样得到的 $b_i$ 会等于 $a_i$ 呢？展开一下就明白了：\n$$\rb'_1=b_1\\\\b'_2=b'_1\\oplus b_2\\\\b'_3=b'_1\\oplus b'_2\\oplus b_3\r$$ 如果一项一项带入，就会发现 $b'_{i}=b_{i-1}\\oplus b_i$。\n又把 $b_i$ 用 $a_i$ 表示，可以得到 $b'_{i}=(a_1\\oplus\\dots\\oplus a_{i-1})\\oplus (a_1\\oplus \\dots \\oplus a_i)=a_i$。\n至此，题意与解题目标发生了转化、也更加清晰。\n能否构造\r观察一手数据范围，可以跑 $n\\log b$。考虑对于每个 $i$，就用 $O(\\log b)$ 构造出一个 $a_i$。这里为了防止前缀和影响已更新好的数，我们选择倒着构造。\n先判断能否构造，不难想到，可以构造的充要条件是：每一个 $a_i$ 都可以由 $b_{[1,i-1]}$ 中的若干数与 $b_i$ 异或得到。\n构造开始\r这个 $b$ 数组，不是个善茬，想不到怎么很好处理。思考一下 $b$ 数组需要做的操作，都是它的线性基可以处理的（其实看到异或问题，多多少少要想到一点线性基）。\n我们把基底按先后加入顺序标号，来表示 $b$ 的每一个数。此刻来考虑这个新数组 $c$。\n我们想从 $a_n\\sim a_1$ 进行构造，如果我们此时构造 $a_i$，那么我们不能动 $a_k$，$k\\in[i+1,n]$；否则就打乱了。\n所以，当我们改变到第 $i$ 位的时候，只能对 $k=i$ 进行操作：$b_i\\leftarrow \\oplus_{j=1}^ib_j$。实际上，就是构造异或和等于 $a_i$。\n我们按加入的先后顺序标号，所以当第 $i$ 位最早在 $pos_i$ 出现时，在 $[1,pos_i-1]$ 中 $i$ 这一位都为零。这个很显然。\n那得知这个有什么用呢？我们可以通过这个将前缀异或和进行某一位的翻转。既然 $pos_i$ 是第一次出现 $i$，那如果我对 $k=pos_i+1$ 进行操作，只有 $b_{pos_i+1}$ 的异或和多了 $i$ 这一位，总异或和这一位也就可以翻转了。\n也是从大到小考虑，$pos_i$ 递减，不会影响之前的数。\n构造总结\r那现在构造方法就很明了了：\n从大到小枚举 $i$，计算当前异或和。 当异或和与 $a_i$ （重标号后的）某一位不一样，就对那一位进行翻转操作。 最后对 $k=m$ 进行操作，即可得出 $a_m$。 重复 $n$ 遍，最后把操作序列翻转，就是从 $a$ 到 $b$ 的操作了。 代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 1e3 + 5; int n; int a[MAXN], b[MAXN], c[MAXN]; int pos[64]; vector\u0026lt;int\u0026gt; ans; struct XXJ { int d[64]; // 基底 int id[64], tot; void Clear() { memset(d, 0, sizeof(d)); memset(id, 0, sizeof(id)); tot = 0; } bool Count(int x) { for (int i = 59; ~i; i--) if (x \u0026gt;\u0026gt; i \u0026amp; 1) { if (d[i] == 0) return 0; x ^= d[i]; } return 1; } int Insert(int x) { int res = 0; for (int i = 60; ~i; i--) if (x \u0026gt;\u0026gt; i \u0026amp; 1) { if (d[i] == 0) { d[i] = x; id[i] = tot++; return res | (1ll \u0026lt;\u0026lt; id[i]); } res |= (1ll \u0026lt;\u0026lt; id[i]); x ^= d[i]; } return res; } } X; void work(int x) { ans.push_back(x); for (int i = 1; i \u0026lt;= x; i++) { b[i] ^= b[i - 1]; c[i] ^= c[i - 1]; } } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;b[i]); for (int i = 1; i \u0026lt;= n; i++) { if (X.Count(a[i] ^ b[i]) == 0) return puts(\u0026#34;No\u0026#34;), 0; X.Insert(b[i]); } for (int i = n; i; i--) { X.Clear(); for (int j = 1; j \u0026lt;= i; j++) { bool flg = X.Count(b[j]); c[j] = X.Insert(b[j]); if (flg == 0) pos[__lg(c[j])] = j; } int tmp = X.Insert(a[i]); for (int j = X.tot; ~j; j--) { int sum = 0; for (int k = 1; k \u0026lt;= i; k++) sum ^= c[k]; if ((sum \u0026gt;\u0026gt; j \u0026amp; 1) != (tmp \u0026gt;\u0026gt; j \u0026amp; 1)) work(pos[j] + 1); } work(i); } reverse(ans.begin(), ans.end()); printf(\u0026#34;Yes\\n%lld\\n\u0026#34;, (int)ans.size()); for (int i : ans) printf(\u0026#34;%lld \u0026#34;, i); return 0; } ","date":"2024-02-01T23:58:00+08:00","permalink":"https://werchange.github.io/p/arc145e-adjacent-xor-%E9%A2%98%E8%A7%A3/","title":"[ARC145E] Adjacent XOR 题解"},{"content":"魔法少女LJJ 题解\r这题纯属就是迷惑题。。\n为什么这么说？\n注意数据范围：\n对 100% 的数据 $0\\leq m\\leq400000$，$c\\leq 7$。\n$c\\leq 7$！！\n这意味着根本没有删除操作。就连样例也是错的。\nSolution\r这题的各种操作，用并查集 + 线段树合并完成。\n如果你是被题目数据范围晃飞的，建议先去想想怎么做。\n先介绍一下线段树的节点：\n1 2 3 4 5 6 struct node { int ls,rs; // 左右儿子 int num; // 数量 double val; // log 值，这里后面会讲 }tr[N*20]; 接下来分析一下各种操作：\n新建一棵权值线段树，$x$ 节点的 $num+1$。 并查集连接一下，合并这两个节点的线段树。 先查询得到 $a$ 连通块内有多少比 $x$ 小的点的数量 $S$；然后把这些小的区间清空；最后把 $x$ 所在的点的信息更改为 $S$。 类似操作 3。 基本操作了，二分查找树。 由 $\\log(a\\times b)=\\log a+\\log b$ 发现，直接比较 $\\log$ 值即可。这就是为什么节点信息中要储存一个 $val$。 标准操作了，输出 $num$ 即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #define int long long #define db double #define ls(x) tr[x].ls #define rs(x) tr[x].rs const int MAXN = 2e6 + 5; int n, m, tmp, cnt, fa[MAXN], d[MAXN], rts[MAXN]; struct node { int op, x, y; } q[MAXN]; struct tree { int ls, rs, num; bool tag; db val; } tr[MAXN * 20]; int rk(int x) { return lower_bound(d + 1, d + 1 + n, x) - d; } int find(int x) { // 略 } void pushup(int rt) { tr[rt].num = tr[ls(rt)].num + tr[rs(rt)].num; tr[rt].val = tr[ls(rt)].val + tr[rs(rt)].val; } void pushdown(int rt) { if (tr[rt].tag) { tr[rt].tag = 0; tr[ls(rt)].num = tr[ls(rt)].val = 0, tr[ls(rt)].tag = 1; tr[rs(rt)].num = tr[rs(rt)].val = 0, tr[rs(rt)].tag = 1; } } void update(int \u0026amp;rt, int l, int r, int k, int x, db y) { // 略 } void merge(int \u0026amp;rt1, int rt2, int l, int r) { // 略 } int query(int rt, int l, int r, int lf, int rg) { // 略 } void clean(int rt, int l, int r, int lf, int rg) { if (!rt || rg \u0026lt; lf) return; if (lf \u0026lt;= l \u0026amp;\u0026amp; rg \u0026gt;= r) { tr[rt].num = tr[rt].val = 0, tr[rt].tag = 1; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (lf \u0026lt;= mid) clean(ls(rt), l, mid, lf, rg); if (rg \u0026gt; mid) clean(rs(rt), mid + 1, r, lf, rg); pushup(rt); return; } int ask(int rt, int l, int r, int k) { // 略 } signed main() { ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int op, x, y = 0; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if (op != 1 \u0026amp;\u0026amp; op != 7) cin \u0026gt;\u0026gt; y; q[i] = (node){op, x, y}; if (op == 3 || op == 4) d[++n] = y; if (op == 1) d[++n] = x; } sort(d + 1, d + 1 + n); n = unique(d + 1, d + 1 + n) - d - 1; for (int i = 1; i \u0026lt;= m; i++) { int op = q[i].op, x = q[i].x, y = q[i].y; if (op == 1) update(rts[++tmp], 1, n, rk(x), 1, (db)log(x)), fa[tmp] = tmp; if (op == 2) { int fx = find(x), fy = find(y); if (fx != fy) { fa[fy] = fx; merge(rts[fx], rts[fy], 1, n); } } if (op == 3) { int fx = find(x), k = rk(y); int sum = query(rts[fx], 1, n, 1, k - 1); clean(rts[fx], 1, n, 1, k - 1); update(rts[fx], 1, n, k, sum, sum * log(y)); } if (op == 4) { int fx = find(x), k = rk(y); int sum = query(rts[fx], 1, n, k + 1, n); clean(rts[fx], 1, n, k + 1, n); update(rts[fx], 1, n, k, sum, sum * log(y)); } if (op == 5) printf(\u0026#34;%lld\\n\u0026#34;, ask(rts[find(x)], 1, n, y)); if (op == 6) puts(tr[rts[find(x)]].val \u0026gt; tr[rts[find(y)]].val ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;); if (op == 7) printf(\u0026#34;%lld\\n\u0026#34;, tr[rts[find(x)]].num); } return 0; } 结尾\r这道题告诉我们，读题一定要认真****！！\n本题考查并查集 + 线段树合并 + 读题仔细。\n","date":"2024-01-25T22:29:00+08:00","permalink":"https://werchange.github.io/p/%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3ljj-%E9%A2%98%E8%A7%A3/","title":"魔法少女LJJ 题解"},{"content":"Tarjan 算法\r前言\r说来惭愧，这个模板仅是绿的算法至今我才学会。\n我还记得去年 CSP2023 坐大巴路上拿着书背 Tarjan 的模板。虽然那年没有考连通分量类似的题目。\n现在做题遇到了 Tarjan，那么，重学，开写！\n另，要想学好此算法的第一件事——膜拜 Tarjan 爷爷。\nTarjan 算法到底是什么\r其实广义上有许多算法都是 Tarjan 发明的（大名鼎鼎的 Link-Cut-Tree 正是出自他手），而本文介绍的是可以解决图中强连通分量的算法。\n也就是狭义的 Tarjan 算法。\n什么是强连通分量\r对于一个图 $G$ 来说，一个字图中，任意两点都可以彼此到达（存在路径），这个子图就称为图 $G$ 的强连通分量。特别地，一个点也是一个强连通分量。\n算法思路\rTarjan 是基于 DFS 实现的，走过的边会形成一棵搜索树。可以看作是原图删去一些边留下来而形成的。\n看个图吧：\n如果我们把抛弃的边分为三个大类，可以分为：\n横叉边（红） 前向边（蓝） 后向边（黄） 上图把抛弃的边画出来就是这样了：\n容易发现，能够构成环的只有后向边。而我们所需要得到的连通分量，正需要环。\n我们怎么知道 DFS 到什么时候是一条后向边呢？\n我们可以在 DFS 过程中给每个点打一个时间戳（实际上就是 DFS 序， dfn[x]=++cnt），如此，当我们遍历某节点的儿子 $v$ 时，$v$ 是一个已访问过的节点，那么我们找到了后向边。\n如何维护？——用两个数组\ndfn[i]：储存时间戳。 low[i]：储存 $i$ 点可以访问到的最高祖先的 dfn 值（因为 DFS 序由小到大，所以储存的数越小、表示 $i$ 点访问祖先能力越强）。 特殊地，一个点访问祖先的能力再差，也可以访问到自己。\n代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int dfn[MAXN],low[MAXN],tim; bool vis[MAXN]; int ans; stack\u0026lt;int\u0026gt; st; int belong[MAXN]; vector\u0026lt;int\u0026gt; G[MAXN]; void tarjan(int x) { dfn[x]=low[x]=++tim; st.push(x); vis[x]=1; for(int i=hd[x];i;i=lt[i]) { int v=en[i]; if(!dfn[v]) { tarjan(v); low[x]=min(low[x],low[v]); } else if(vis[v]) // 此时找到后向边，不着急操作，等待回溯以后在操作 low[x]=min(low[x],dfn[v]); } if(dfn[x]==low[x]) // 这是根节点独有的性质 { ++ans; // 看看目前已经是第几个强连通分量了 int top; do { top=st.top();st.pop(); vis[top]=0; belong[top]=ans; // belong[] : 某节点属于那个强连通分量 G[ans].push_back(top); // 强连通分量有哪些成员节点。 } while (top!=x); } } P1726 上白泽慧音\r题目要求：求出最大强连通分量、并输出其成员。如数量相同，输出最小的成员集合。\n此题目中，belong[] 就不需要了，存成员是必要的；按字典序输出的话，把成员丢进优先队列带走，秒了！\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=2e5+5; int n,m; int dfn[MAXN],low[MAXN],tim; bool vis[MAXN]; int ans; stack\u0026lt;int\u0026gt; st; int belong[MAXN]; int su,hd[MAXN],lt[MAXN],en[MAXN]; priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; G[MAXN]; struct node { int id,sz,val; }p[MAXN]; void add(int u,int v) { en[++su]=v,lt[su]=hd[u],hd[u]=su; } void tarjan(int x) { dfn[x]=low[x]=++tim; st.push(x); vis[x]=1; for(int i=hd[x];i;i=lt[i]) { int v=en[i]; if(!dfn[v]) { tarjan(v); low[x]=min(low[x],low[v]); } else if(vis[v]) low[x]=min(low[x],dfn[v]); } if(dfn[x]==low[x]) { ++ans; p[ans].id=ans; p[ans].val=st.top(); int top; do { top=st.top();st.pop(); vis[top]=0; belong[top]=ans; p[ans].sz++; G[ans].push(top); } while (top!=x); } } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1,u,v,w;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v); if(w==2) add(v,u); } for(int i=1;i\u0026lt;=n;i++) if(!dfn[i]) tarjan(i); sort(p+1,p+ans+1,[](node x,node y){ return x.sz==y.sz?x.val\u0026lt;y.val:x.sz\u0026gt;y.sz; }); printf(\u0026#34;%lld\\n\u0026#34;,p[1].sz); while (!G[p[1].id].empty()) { printf(\u0026#34;%lld \u0026#34;,G[p[1].id].top()); G[p[1].id].pop(); } return 0; } 参考文献\r[1] _H1kar1，题解 P1726 【上白泽慧音】 ","date":"2024-01-24T22:16:00+08:00","image":"https://werchange.github.io/img/tar/1.png","permalink":"https://werchange.github.io/p/tarjan-%E7%AE%97%E6%B3%95%E8%B6%85%E8%AF%A6%E7%BB%86/","title":"Tarjan 算法（超详细！！）"},{"content":"upd 2024.10.24 ：补充了为什么求欧拉路径时不能正序存点。\n欧拉路径、回路、图\r前言\r当一手标题党，快乐~\n之前一直分不清楚，写篇笔记分辨一下。\n欧拉路径\r可以一笔画的路径，称为欧拉路径。不要求起点终点为同一点。\n判定：\n有向图：图中只有一个出度比入度大 $1$ 的点（起点），与一个入度比出度大 $1$ 的点（终点），其余点出入度相等。 无向图：图中只有两个奇点（起点和终点），其余点都是偶点。 当然，将有向边视作无向边后，路径必须连通。\n欧拉回路\r在欧拉路径的基础上，起点终点是同一点。\n判定：\n有向图：所有点的出入度相等。 无向图：所有点都是偶点。 欧拉图\r欧拉图：具有欧拉回路的图。 半欧拉图：存在欧拉路径、但没有欧拉回路的图。 判断方法\r判断一个图是否有欧拉路或欧拉回路，要用到 Fleury 算法。（虽然这不是文章的重点，重点是上文）\n用 DFS 实现。\n算法核心：除非都是桥，否则走桥边。\n关于为什么不能倒序存点\r先放张图：\n正确顺序：$1\\to 3\\to 4\\to 1\\to 2$\n如果先进栈会出现断层。\nP7771 【模板】欧拉路径\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e5+5; int n,m; int tmp[MAXN]; int rd[MAXN],cd[MAXN]; stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; G[MAXN]; void dfs(int S) { for(int i=tmp[S];i\u0026lt;G[S].size();i=tmp[S]) tmp[S]=i+1,dfs(G[S][i]); // tmp[S] : G[S][1,2,...,tmp[S]-1] 都已访问，下一次从 G[S][tmp[S]] 开始 st.push(S); } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1,u,v;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v); G[u].push_back(v); // 注意有向图 cd[u]++,rd[v]++; } for(int i=1;i\u0026lt;=n;i++) sort(G[i].begin(),G[i].end()); int S=1,c1=0,c2=0; bool flg=1; // 是否所有点出入度相等 for(int i=1;i\u0026lt;=n;i++) { if(cd[i]!=rd[i]) { flg=0; if(cd[i]-rd[i]==1) c1++,S=i; // 出度比入度大 1 else if(rd[i]-cd[i]==1) c2++; else return puts(\u0026#34;No\u0026#34;),0; } } if(flg==0\u0026amp;\u0026amp;!(c1==c2\u0026amp;\u0026amp;c1==1)) return puts(\u0026#34;No\u0026#34;),0; // 不满足判定条件 dfs(S); while(!st.empty()) printf(\u0026#34;%lld \u0026#34;,st.top()),st.pop(); return 0; } ","date":"2024-01-24T20:39:00+08:00","permalink":"https://werchange.github.io/p/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E6%AC%A7%E6%8B%89%E5%9B%BE%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/","title":"欧拉路径、欧拉回路、欧拉图傻傻分不清楚？看这一篇就够了！"},{"content":"差分约束系统\r前言\r真的好久好久都没打过这个算法了。当时学的时候学得不明不白，又不写总结、又不刷题（我都不知道自己咋想的），所以今天刷图论题的时候，发现一车子的差分约束都没打过。\n所以，重学，开写！\n差分约束系统是什么\r不要被他名字的学术性吓到了，这个“系统”字面意思理解就行，不是什么高深庞大的东西。\n一个差分约束系统形如：\n已知\n$$\r\\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}\r$$ 求这个不等式组任意的一组解。\n其实说白了，就是 $n$ 个变量，$m$ 个约束条件（$x_i-x_j\\leq y_k$）。\n怎么解决这个系统\r怎么解这个不等式？\n首先移项一手：\n$$\rx_i\\leq x_j+y_k\r$$ 你看，是不是和图论中的 $dis_v\\leq dis_u+w_i$ 很像啊？\n所以这个问题可以转换成一个最短路问题——把 $j$ 向 $i$ 连一条权值为 $y_k$ 的边。\n可是这个图并不一定连通，所以我们建一个超级源点 $0$。带入到系统中，便是增加了 $n$ 个约束条件：$x_i\\leq x_0$。如此，整个系统得到完善。\n然后就家常便饭，直接最短路。如果存在负环，不等式组无解；否则可以得到每个点的 $dis_i$。而不等式的一组可行解，正是 $x_i=dis_i$。\n负环怎么判\r这里稍微讲一手。\n首先为什么出现负环就无解？\n因为最短路算法，就是不断走边权最小的边，以更新每个点到源点的最短距离。但如果存在一个环，且总权为负，那么就可以一直走、一直走，直至边权 $=-\\infin$。\n现在，原图共 $n+1$ 个点，如果不存在负环，那么最短路中每个点肯定只会进队一次。因为没有必要经过两次去松弛它的邻接点。\n所以如果 $n$ 轮松弛结束后仍然存在可松弛的边，那就一定存在负环。\n在题目中如何用差分约束算法\r如果在模版题，就不多说了。\n我们对于题目中的关系，可以得到一些不等条件，再化简成一般形式 $x_i\\leq x_j+y_k$，就可以建立这样一个差分约束系统。\n如果是相等情况怎么办？\n简单，直接拆分成 $x_i\\leq x_j+y_k$ 与 $x_j\\leq x_i+y_k$ 这两条约束条件。\nP5960【模板】差分约束\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e4+5; int n,m; int dis[MAXN],cnt[MAXN]; bool vis[MAXN]; int su,en[MAXN],lt[MAXN],hd[MAXN],vl[MAXN]; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } bool SPFA(int s) { queue\u0026lt;int\u0026gt; q; memset(dis,0x3f,sizeof(dis)); vis[s]=1,dis[s]=0; q.push(s); while (!q.empty()) { int u=q.front();q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i]; if(dis[v]\u0026gt;dis[u]+vl[i]) { dis[v]=dis[u]+vl[i]; if(!vis[v]) { vis[v]=1,cnt[v]++; if(cnt[v]\u0026gt;n) return 0; q.push(v); } } } vis[u]=0; } return 1; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) add(0,i,0); // 超级源点 for(int i=1,u,v,w;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(v,u,w); // 注意这里是 v --w-\u0026gt; u } if(!SPFA(0)) puts(\u0026#34;NO\u0026#34;); else { for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%lld \u0026#34;,dis[i]); } return 0; } 参考文献\r[1] StudyingFather，题解 P5960 【【模板】差分约束算法】 结尾\r如果想看图论相关文章，刚好我 2 年前写了一篇。虽然年代久远，格式、文笔也很垃坤，但是得看且看吧。\n溜去做题了。\n如果你想问为什么有些题目用的差分约束是跑最长路，这个我还不能回答你（我也不知道），但是可以先放张图，等我学会后再回来更（当然也可能忘记了，如果你正在看，可以在评论区踢我）。\n图：\n（看起来是两种不同的方式罢了……）\n","date":"2024-01-24T11:13:00+08:00","image":"https://werchange.github.io/img/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/","title":"浅谈差分约束系统"},{"content":"dsu on tree\r前言\r在我认为，这个并不能说单独列出来成为一个算法，更恰当的说，是一种思想、技巧。反正挺简单的，也很有趣（谁会拒绝一个优美的暴力呢），所以写篇笔记记录一手。\ndsu 是什么\rdsu 一般指“disjoint set union”，即并查集。那么 dsu on tree 也就是指树上的合并和查询操作。\n但是 dsu on tree 的实现却跟普通并查集没有太大联系。共同点仅在于功能上都能合并集合、查询。\ndsu on tree 有什么用\rdsu on tree 可称为树上启发式合并，是一种优美的暴力，合并子树的时候，把轻儿子合并到重儿子上去。\n由于保存合并结果的是一个全局数组。所以每次计算新的字数时，都需要清空。我们可以先计算轻儿子，把重儿子留到最后，重儿子可以不用清零，直接把重儿子的信息拿去计算父亲。\n这样一来，在暴力的基础上，将重儿子留到了最后，少算了一次重儿子，时间可以来到优秀的 $O(n\\log n)$（暴力是纯粹的 $O(n^2)$）。\n从题目出发\r题目：给一棵根为1的树，每次询问子树颜色种类数。\n纯暴力\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void update(int x, int f, int flg){ cnt[col[x]] += flg; if(cnt[col[x]] == 0 \u0026amp;\u0026amp; flg == -1) cols--; if(cnt[col[x]] == 1 \u0026amp;\u0026amp; flg == 1) cols++; for(int i = fir[x]; i; i = es[i].nxt){ int tv = es[i].v; if(tv != f) update(tv, x, flg); } } void dfs(int r, int fa){// 求子树r中的信息, fa为r的父亲 for(int i = fir[r]; i; i = es[i].nxt){ // 遍历r的邻接点 int tv = es[i].v; if(tv != fa) dfs(tv, r); } update(r, fa, 1); ans[r] = cols; update(r, fa, -1); } 直接 $O(n^2)$ T 飞。\n当然你也可以把 dfs 写成这样（更接近 dsu 的打法）：\n1 2 3 4 5 6 7 8 9 10 11 void dfs(int r, int fa){// 求子树r中的信息, fa为r的父亲 for(int i = fir[r]; i; i = es[i].nxt){ // 遍历r的邻接点 int tv = es[i].v; if(tv != fa){ dfs(tv, r); update(tv, r, -1); } } update(r, fa, 1); ans[r] = cols; } dsu\r现在我们来优化一手暴力。先预处理出轻、重儿子，然后 dfs 轻儿子、再 dfs 重儿子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void dfs(int x, int f){ for(int i = fir[x]; i; i = es[i].nxt){ int tv = es[i].v; if(tv != son[x] \u0026amp;\u0026amp; tv != f){ dfs(tv, x); update(tv, x, -1); } } if(son[x]) dfs(son[x], x); cnt[col[x]]++; if(cnt[col[x]] == 1) cols++; for(int i = fir[x]; i; i = es[i].nxt){ int tv = es[i].v; if(tv != son[x] \u0026amp;\u0026amp; tv != f){ update(tv, x, 1); } } ans[x] = cols; } 时间复杂度来到优秀的 $O(n\\log n)$ ！！\n时间复杂度分析\r但是为什么呢？\n因为根据轻重链划分的思想，任何一条到根的路径上，轻边不会超过 $\\log n$ 条，重链是被轻边分隔的，数量也不会超过 $\\log n$ 条。\n每棵子树到父亲的边为轻边，做一次 update，最多做 $\\log n$ 次。\n一次 update 可以看作是轻儿子想重儿子的合并操作。\n每个节点最多合并 $\\log n$ 次，总的时间复杂度为 $O(n\\log n)$ 次。\n完整代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define MAXN 100005 int n, m, ecnt, cols, col[MAXN], fir[MAXN], sz[MAXN]; int son[MAXN], cnt[MAXN], ans[MAXN]; struct edge { int v, nxt; } es[MAXN \u0026lt;\u0026lt; 1]; void adde(int a, int b) { es[++ecnt].v = b, es[ecnt].nxt = fir[a], fir[a] = ecnt; es[++ecnt].v = a, es[ecnt].nxt = fir[b], fir[b] = ecnt; } void dfs1(int x, int f) { sz[x]++; int maxz = 0; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != f) { dfs1(tv, x); if (sz[tv] \u0026gt; maxz) maxz = sz[tv], son[x] = tv; sz[x] += sz[tv]; } } } void update(int x, int f, int flg) { cnt[col[x]] += flg; if (cnt[col[x]] == 0 \u0026amp;\u0026amp; flg == -1) cols--; if (cnt[col[x]] == 1 \u0026amp;\u0026amp; flg == 1) cols++; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != f) update(tv, x, flg); } } void dfs2(int x, int f) { for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != son[x] \u0026amp;\u0026amp; tv != f) dfs2(tv, x), update(tv, x, -1); } if (son[x]) dfs2(son[x], x); cnt[col[x]]++; if (cnt[col[x]] == 1) cols++; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != son[x] \u0026amp;\u0026amp; tv != f) update(tv, x, 1); } ans[x] = cols; } int main() { int a, b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); adde(a, b); } for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;col[i]); dfs1(1, 0); dfs2(1, 0); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;ans: %d\\n\u0026#34;, ans[a]); } return 0; } Lomsat gelral\r这个就是板题了，也可以线段树合并去做。但是 dsu on tree 明显更短，更好打。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define MAXN 100025 #define LL long long int LL sum, ans[MAXN]; int n, m, ecnt, maxcnt, col[MAXN], fir[MAXN], sz[MAXN], son[MAXN], cnt[MAXN]; struct edge { int v, nxt; } es[MAXN \u0026lt;\u0026lt; 1]; void adde(int a, int b) { es[++ecnt].v = b, es[ecnt].nxt = fir[a], fir[a] = ecnt; es[++ecnt].v = a, es[ecnt].nxt = fir[b], fir[b] = ecnt; } void dfs1(int x, int f) { sz[x]++; int maxz = 0; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != f) { dfs1(tv, x); if (sz[tv] \u0026gt; maxz) maxz = sz[tv], son[x] = tv; sz[x] += sz[tv]; } } } void update(int x, int f, int flg) { cnt[col[x]] += flg; if (flg == 1) { if (cnt[col[x]] \u0026gt; maxcnt) maxcnt = cnt[col[x]], sum = col[x]; else if (cnt[col[x]] == maxcnt) sum += col[x]; } else maxcnt = 0, sum = 0; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != f) { update(tv, x, flg); } } } void dfs2(int x, int f) { for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != son[x] \u0026amp;\u0026amp; tv != f) dfs2(tv, x), update(tv, x, -1); } if (son[x]) dfs2(son[x], x); cnt[col[x]]++; if (cnt[col[x]] \u0026gt; maxcnt) maxcnt = cnt[col[x]], sum = col[x]; else if (cnt[col[x]] == maxcnt) sum += col[x]; for (int i = fir[x]; i; i = es[i].nxt) { int tv = es[i].v; if (tv != son[x] \u0026amp;\u0026amp; tv != f) update(tv, x, 1); } ans[x] = sum; } int main() { int a, b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;col[i]); for (int i = 1; i \u0026lt; n; i++) scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b), adde(a, b); dfs1(1, 0); dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%lld \u0026#34;, ans[i]); return 0; } ","date":"2024-01-24T09:47:00+08:00","permalink":"https://werchange.github.io/p/%E4%BC%98%E7%BE%8E%E7%9A%84%E6%9A%B4%E5%8A%9B%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6dsu-on-tree/","title":"优美的暴力——树上启发式合并（dsu on tree）"},{"content":"CF1920E\r被这种题卡了，脸都不要了。\n仔细读题，发现序列可以分成两部分（$0$ 和 $1$）来考虑。\n在合法序列中，对于一个 $1$，它产生的子串贡献一定是（假设与上一个 $1$ 之间有 $x$ 个 $0$，与下一个 $1$ 之间有 $y$ 个 $0$）： $$(x+1)(y+1)$$ 如果去 DP 这 $n$ 个 $1$，易得转移方程： $$f_{i,j}=\\sum f_{i-p\\times j,p}$$ $f_{i,j}$ 表示：当前贡献了 $i$ 个合法子串，上一个 $1$ 到现在的 $1$ 的长度为 $j$ 的组成序列方案数。\n接下来考虑 $p$ 的值域。\n要使式子成立，有：$p\\in [1, \\frac{i}{j}]$。\n考虑题目限制（最长合法串长度不大于 $k$），有：$p\\in [1,k+1-j]$。\n所以 $p\\in [1,\\min{\\frac{i}{j},k+1-j}]$，即： $$f_{i,j}=\\sum\\limits_{p=1}^{\\min\\{\\frac{i}{j},k+1-j\\}} f_{i-p\\times j,p}$$ code\n","date":"2024-01-22T11:49:00+08:00","permalink":"https://werchange.github.io/p/cf1920e-%E9%A2%98%E8%A7%A3/","title":"CF1920E 题解"},{"content":"浅谈 ST 表\r这种东西还是很简单的，但是涉及左移右移，模板容易打挂，写篇笔记。\nST 表是什么\r虽然这个是通过二维数组来实现的，但是我不是很喜欢称之为“表”。我觉得完全可以看作是在一维序列上的区间，看作“表”的话关联性就会很鬼畜。\n其主要思想是：$f[i][j]$ 表示区间左端点为 $i$，区间长度为 $2^j$ 的区间信息（可以是最大值、区间和、区间 $\\gcd$ 等）。\n有人说了，那为什么不用线段树？\n我一开始也是这么想的，所以我一开始有段时间只会线段树，不会 ST 表。\nST 表的好处在于，他可以 $O(1)$ 查询区间信息。至于预处理，就是 $O(n\\log n)$ 的。\n而线段树，基本任何操作都是 $O(\\log n)$ 的。\n所以如果你想 $O(1)$ 查询，那就要学 ST 表。\n注意！ ST 表并不支持带修改。也就是说，对于不会修改的题目，并且需要查询时间优秀的题目，ST 表才有比线段树明显的优势。\n如何实现 ST 表\r预处理\r众所周知，如果一个区间的长度是 $1$，那么这个“区间”就是 $1$ 个元素。所以可以直接：\ncode\n1 for(int i=1;i\u0026lt;=n;i++) f[i][0]=a[i]; 接下来考虑区间长度为 $2^j$ 的区间。\n为什么我们要令长度是 $2^j$ 而不是 $j$ 呢？——这正是这个算法的精髓所在。\n因为长度为 $2^j$ 的区间可以看做由两个长度为 $2^{j-1}$ 组成，而当我们正要处理出 $f[i][j]$ 的时候，肯定已知 $f[i][j-1]$ （因为我们通过递推得出 $f$），所以可以直接转换。\n此处实现代码以维护区间和为例。\ncode\n1 2 3 4 5 6 7 for(int j=1;(1\u0026lt;\u0026lt;j)\u0026lt;=n;j++) { for(int i=1;i+(1\u0026lt;\u0026lt;j)-1\u0026lt;=n;i++) { f[i][j]=f[i][j-1]+f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]; } } 转换没看懂？\n看个图吧\n（图中一个“棍棍”就是一个元素）\n查询\r查询亦是同理，只不过我们 $f[i][j]$ 中的 $i$ 是开头，$l$ 就直接放进去，$r$ 就要减去区间长度再 $+1$ 来得到开头。\n这里依然是以区间和为例。\ncode\n1 2 3 4 5 int query(int l,int r) { int k=log2(r-l+1); return f[l][k]+f[r-(1\u0026lt;\u0026lt;k)+1][k]; } P3865 【模板】ST 表\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e5+5; int n,m; int a[MAXN]; int lg[MAXN]; int f[MAXN][30]; inline int rd() { int x=0,f=1; char ch=getchar(); while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;) { if(ch==\u0026#39;-\u0026#39;) f=-1; ch=getchar(); } while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;) x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+(ch^48),ch=getchar(); return x*f; } int query(int l,int r) { int k=lg[r-l+1]; int d=r-(1\u0026lt;\u0026lt;k)+1; return max(f[l][k],f[d][k]); } signed main() { n=rd(),m=rd(); for(int i=1;i\u0026lt;=n;i++) a[i]=rd(); for(int i=1;i\u0026lt;=n;i++) f[i][0]=a[i]; for(int i=2;i\u0026lt;=n;i++) lg[i]=lg[i\u0026gt;\u0026gt;1]+1; for(int j=1;j\u0026lt;=lg[n];j++) { for(int i=1;i\u0026lt;=n-(1\u0026lt;\u0026lt;j)+1;i++) { f[i][j]=max(f[i][j-1],f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } } while(m--) { int l=rd(),r=rd(); printf(\u0026#34;%lld\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2024-01-22T11:42:00+08:00","image":"https://werchange.github.io/img/ST/p1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88-st-%E8%A1%A8/","title":"浅谈 ST 表"},{"content":"浅谈 AC 自动机\r前言\r这不是第一次看到这个算法。第一次是在 OI-wiki 上瞄到的。当时我还是一个什么也不懂的初一蒟蒻，看到这个名字就十分兴奋：“‘AC 自动机’耶！是不是可以帮我自动 AC ！?”\n后来看到只是一个字符串算法，就离开了。今天上课讲了这个，感觉原理及实现没有后缀数组那么难（还没做几道应用题）。趁一节晚修，来写篇笔记吧。\n食用指南：要先学会 Trie树；KMP的话，理解到思想（$\\text{next}$ 数组）就可以了，不一定要学得透透的。\nAC 自动机到底是什么？\rAC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的自动机。\n之所以称为 AC 自动机，是因为此算法是由 Alfred V. Aho 和 Margaret J.Corasick 发明的，称为 Aho–Corasick 算法。\n所以他不是 Automation，更不是 Accepted，而是 Automaton（自动机）。\nAC 自动机可以用来干什么？\r他是处理字符串的算法。\n具体的，他可以解决多模式匹配的问题。\nKMP 算法也是解决字符串匹配的，但他处理的问题只有一个模式串（需要寻找的串）和一个文本串（在这个串里寻找）。\n而 AC 自动机，就可以解决多模式串匹配的问题。\n算法思路\r简单来说，建立一个 AC 自动机有两个步骤：\nTrie 结构：将所有的模式串构建成一棵 Trie 树。 KMP 的思想：在 KMP 中，一旦失配，就跳到 $\\text{next}$ 失配指针所指的下一个字符；所以 AC 自动机中，也要对整颗 Trie 树所有节点构造失配指针。 那我们现在就开始吧。\nTrie 树\r回忆一下 AC 自动机的思路：首先把所有的字符串全部丢进 Trie 树里面，然后再在 Trie 树上构建自动机。\n这个 Trie 树构建就很简单了，该怎么建就怎么建。详细内容可以看我的其他博客。\n这里有一些需要理解的，就是一个节点到根节点的路径正是一个（或多个）模式串的前缀。\n下文也把节点 $x$ 到根节点的路径上的字符串称为状态 $x$。\n失配指针\r首先要明确一点：这里的“指针”并不是 C++ 中真正的“指针类型”，只是一个形象化的称号。\nAC 自动机通过失配指针（下文称为 $\\text{fail}$ 指针）来辅助多模式串的匹配。\n与 KMP 的 $\\text{next}$ 失配指针关系\r相同点：两者同样是在失配的时候用于跳转的指针。 不同点：$\\text{next}$ 求的是最长的相同前后缀；而 $\\text{fail}$ 指针指向所有模式串的前缀中与当前节点“匹配”的“最长后缀”。 等等！这个“匹配”和这个“最长后缀”都是些什么东西？\n先解释一下 $\\text{fail}$ 指针吧。\n如果状态 $x$ 的 $\\text{fail}$ 值是状态 $y$，要求是：$y$ 是 $x$ 的最长后缀。\n用人话说，就是：\n先规定从节点 $x$ 到根节点路径上形成的字符串为 $\\text{sub}(x)$；这个字符串中，第一个是根节点，最后一个是 $x$ 节点上的字母。\n如果 $\\text{sub}(y)$ 正好是 $\\text{sub}(x)$ 的后缀，并且不存在任意一个 $\\text{sub}(y\u0026rsquo;)$ 的长度大于 $\\text{sub}(y)$ 的长度。\n那么 $\\text{fail}(x)=y$。\n举个例子：\n如果以 i,he,his,she,hers 这些单词构建 $\\text{fail}$ 指针：\n假设紫圈是 $3$ 号节点，红圈是 $7$ 号节点，那么 $\\text{fail}[3]=7$。\n因为 she 的最长后缀（整棵 Trie 中）是 he。\n如果你看到这里，还是看不懂与KMP的区别，不要紧；你只需知道 AC 自动机的失配指针指向当前状态的最长后缀状态即可。\n有一点提一下，AC 自动机在做匹配时，同一位上可匹配多个模式串。\n构建 $\\text{fail}$ 指针\r构建 $\\text{fail}$，可以参考 KMP 中构建 $\\text{next}$ 的思想。\n假设字典树中当前节点为 $u$，父节点为 $fa$，并且 $\\text{sub}(u)=\\text{sub}(fa)+c$（记为 $\\text{trie}[fa,c]=u$）我们考虑深度比 $u$ 小的节点的 $\\text{fail}$ 都已得到。\n如果 $\\text{trie}[\\text{fail}[fa],c]$ 存在，则 $\\text{fail}[u]=\\text{trie}[\\text{fail}[fa],c]$。相当于分别在 $fa$ 和 $\\text{fail}[fa]$ 下面加了一个字符 $c$，分别对应 $u$ 和 $\\text{fail}[u]$。 如果 $\\text{trie}[\\text{fail}[fa],c]$ 不存在，则继续寻找 $\\text{trie}[\\text{fail}[\\text{fail}[fa]],c]$。重复 1 的判断，一直跳到根节点。 一直跳到了根节点都没有，那就让 $\\text{fail}[u]$ 指向根节点。 通过以上过程就可以完成 $\\text{fail}$ 的构建。\n代码实现构建 $\\text{fail}$ 指针\r尽管网上有许多实现方式，这里我们来看一下 OI-wiki 上的一种实现。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void build() { for (int i = 0; i \u0026lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i \u0026lt; 26; i++) { if (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]); else tr[u][i] = tr[fail[u]][i]; } } } 这里的 tr[u,c] 有两种理解方式：\n字典树上的一条边，即 $\\text{trie}[u,c]$。 状态（节点） $u$ 后加一个字符 $c$ 到达的新节点（状态）。 这里采用第 2 种方式讲解。\n先讲一下这两行为什么这么写：\n1 2 for (int i = 0; i \u0026lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); 我们为什么是把根节点的儿子入队，而非直接把根节点入队呢？\n试想一下，如果将根节点入队，那么第一次 bfs 的时候根节点儿子的 $\\text{fail}$ 指针就会指向自己。\n常规 bfs 这里就不提及了，主要讲一下 for 循环中的 if 与 else 的“神仙实现”。\nfor 循环为什么这么写？——“神仙操作”，路径压缩\r先解释一下代码最基础的意思：\n如果 tr[u][i] 存在，我们就将 tr[u][i] 的 $\\text{fail}$ 指针赋值为 tr[fail[u]][i]。 否则，令 tr[u][i] 指向 tr[fail[u]][i]。 操作 1 貌似和上文讲的不太一样啊？——\n根据上文，不应该是用 while 循环不停地跳、跳、跳 $\\text{fail}$ 指针，直到存在字符 i 对应的节点后再赋值吗？而且 else 里的操作直接改变了树的结构了呀？！！\n其实这里做了一点“神仙处理”。\n这个处理就是通过 else 改变字典树的结构。但值得注意的是，尽管我们将一个不存在的节点添加了一些指向关系，但是节点所代表的的字符串还是不变的。\n由于 tr[S][c] 表示在 $S$ 后增加一个字符 $c$ 得到新字符串 $S\u0026rsquo;$，这里要考虑 $S\u0026rsquo;$ 是否存在。\n存在，说明有某个模式串的前缀为 $S\u0026rsquo;$。 不存在，让 tr[S][c] 指向 tr[fail[S]][c]。这是因为 fail[S] 对应的字符串是 $S$ 的后缀，那么 tr[fail[S]][c] 对应的字符串也就是 $S\u0026rsquo;$ 的后缀。 但为什么可以这么写？\n在 Trie 树上跳的时候，是从 $S$ 跳到了 $S\u0026rsquo;$；但是在 AC 自动机上，是从 $S$ 跳到了 $S\u0026rsquo;$ 的后缀。——因为 AC 自动机本质上是为了匹配，舍弃掉前面一些前缀也是可以匹配的，所以这里没有问题。\n溯回本源，我们这个 Build() 说到底是在构建 $\\text{fail}$，现在我们来考虑一下 $\\text{fail}$ 是否也满足“舍弃前缀依然可匹配”这一推论。\n显然可以，一旦文本串匹配 $S$，自然能匹配 $S$ 的后缀。所谓的 $\\text{fail}$ 指针其实是 $S$ 的一个后缀集合。\n什么？还是看不懂？其实还有一种简单粗暴的理解方式。\n简单粗暴的理解\r如果在位置 $x$ 失配，我们跳到 $\\text{fail}[x]$。因此有的时候需要跳、跳、跳很多次才能来到下一个匹配的位置。\n所以我们可以用 tr 数组直接记录下一个能匹配的位置，以省时间。\n本质上，与并查集路径压缩一样，这其实就是一种路径压缩。\n“神仙操作”的好处\r通过这种修改过后，匹配转移更加的完善，同时将 $\\text{fail}$ 指针跳转路径做了压缩。\n这里本来想放图的，但是画出来很乱，不美观，所以建议去 OI-wiki 上看 gif（虽然也很乱，但起码比作者画得好）。\n多模式匹配\r代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 int query(char *t) { int u = 0, res = 0, len = strlen(t + 1); for (int i = 1; i \u0026lt;= len; i++) { u = tr[u][t[i] - \u0026#39;a\u0026#39;]; // 转移 for (int j = u; j \u0026amp;\u0026amp; e[j] != -1; j = fail[j]) { res += e[j], e[j] = -1; } } return res; } $u$ 表示当前匹配到的节点，res 表示答案，e[j] 表示节点存储的信息（根据题目变化）。\n循环遍历匹配串，$u$ 则不断跟踪字符，利用 $\\text{fail}$ 指针找出所有匹配的模式串，累加到 res，然后标记已访问。\n优化代码效率\r这里可不是卡常，而是算法上的优化。\n首先，大家可以去做一下 这道题。\n发现会 T。这是因为在 AC 自动机中，每次匹配都会向 $\\text{fail}$ 边跳来找到所有的匹配。这样效率极低，即是路径压缩也没用。\n考虑一下 $\\text{fail}$ 的性质：\n一个 AC 自动机中，如果值保留 $\\text{fail}$ 边，剩余的图一定是一棵树。\n这个很显然，因为 $\\text{fail}$ 不会成环，且深度一定比现在低。\nAC 自动机的匹配就可以转化成在 $\\text{fail}$ 树上的链求和问题了。\n这里介绍拓扑排序。\n拓扑排序优化建图\r原来时间都浪费在“跳 $\\text{fail}$”上了。如果预先记录，最后一并求和，那么效率就会被优化。\n代码实现中，不需要真正的建图，记录入度就可以了。\n查询操作也只需要给找到的节点的 ans 打标记，最后拓扑排序求答案就好了。\n建图实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void getfail() // 实际上也可以叫 build { for (int i = 0; i \u0026lt; 26; i++) trie[0].son[i] = 1; q.push(1); trie[1].fail = 0; while (!q.empty()) { int u = q.front(); q.pop(); int Fail = trie[u].fail; for (int i = 0; i \u0026lt; 26; i++) { int v = trie[u].son[i]; if (!v) { trie[u].son[i] = trie[Fail].son[i]; continue; } trie[v].fail = trie[Fail].son[i]; indeg[trie[Fail].son[i]]++; // 修改点在这里，增加了入度记录 q.push(v); } } } 查询实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void query(char *s) { int u = 1, len = strlen(s); for (int i = 0; i \u0026lt; len; i++) u = trie[u].son[s[i] - \u0026#39;a\u0026#39;], trie[u].ans++; } void topu() { for (int i = 1; i \u0026lt;= cnt; i++) if (!indeg[i]) q.push(i); while (!q.empty()) { int fr = q.front(); q.pop(); vis[trie[fr].flag] = trie[fr].ans; int u = trie[fr].fail; trie[u].ans += trie[fr].ans; if (!(--indeg[u])) q.push(u); } } 主函数\r1 2 3 4 5 6 7 8 9 int main() { // do_something(); scanf(\u0026#34;%s\u0026#34;, s); query(s); topu(); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; vis[rev[i]] \u0026lt;\u0026lt; std::endl; // do_another_thing(); } 完整代码就不挂了，洛谷题解区有一堆。\n参考文献\r[1] OI-wiki，《AC 自动机》 [2] DengDuck，《AC 自动机 ACAM 学习笔记》 结尾\r一节晚修写完，除了板题，其他的题还没做，作者溜去做题了。\n如有侵权，联系作者解决。\n希望能帮到你，Thank you!\n","date":"2024-01-16T22:24:00+08:00","image":"https://werchange.github.io/img/AC/p1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88-ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/","title":"浅谈 AC 自动机"},{"content":"浅谈 Trie 树\r什么是 Trie 树？\rTrie 树，又称字典树，可用于存储单词。\nTrie 树的根节点不表示任何字母，但是除了根节点的所有字母都表示一个字母。\n任何一个单词，都可以用一条从根节点出发的路径表示。在路径的终点做一个“结束”标记，对应一个单词的结尾。\n举个例子：要存储 work,word,world,hello 这些单词。\n红色节点表示“结束”标记。\n可以看到，叶子节点都是一个单词的结尾；但是并不是所有的单词结尾都是叶子节点。\n再举个例子：假如要多存储一个 worker 单词。\nTrie 树的好处之一，如果两个单词有公共前缀，则有公共路径，可以节省空间。\n存储结构\rTrie 树中的每个节点都可以用一个结构体来存储。\ncode\n1 2 3 4 struct node{ bool flg; // 结束标记 int son[MAXC]; // 儿子们的“指针”，MAXC表示字符集的大小 }Trie[MAXN]; // MAXN表示Trie树的节点数 节点的字母（值）怎么表示？\n一般在程序中，都是去枚举节点 $i$，所以一般不用结构体来表示节点的字母。\n构建 Trie 树\r先分配足够大的空间（Trie 树），也就是定义足够大的 node 数组。\n然后每读入一个单词，就插入在 Trie 树当中。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define MAXC 26 struct node{ bool flg; int son[MAXC]; }Trie[MAXN]; int root=1,tot=1; void ins(int r,char *s){ int len=strlen(s),val; for(int i=0;i\u0026lt;len;i++){ val=s[i]-\u0026#39;a\u0026#39;; if(Trie[r].son[val]==0) Trie[r].son[val]=++tot; r=Trie[r].son[val]; } Trie[r].flg=1; } 查询节点\r1 2 3 4 5 6 7 8 9 bool query(int rt,char *s){ int len=strlen(s),val; for(int i=0;i\u0026lt;len;i++){ val=s[i]-\u0026#39;a\u0026#39;; rt=Trie[rt].son[val]; if(rt==0) return 0; } return Trie[rt].flg; } 此代码可以返回“查询串”（char *s）的结尾的信息。\n这里返回了 Trie[rt].flg，仅作示范。在实践中，可以返回 Trie[rt].cnt 等等定义的变量。\n例 1 ：单词查找树\rP5755 [NOI2000] 单词查找树\n算法分析\r就是裸的 Trie 树，模板题。\ncode（这里直接复制了 Alex_Wei 的代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int cnt,q[1\u0026lt;\u0026lt;15][26];//cnt为节点个数，q为儿子编号 int main(){ while(cin\u0026gt;\u0026gt;s){ int pos=0; for(int i=0;i\u0026lt;s.size();i++){ int ch=s[i]-\u0026#39;A\u0026#39;; if(!q[pos][ch])q[pos][ch]=++cnt;//如果没有这个节点，就新建一个 pos=q[pos][ch]; } } cout\u0026lt;\u0026lt;cnt+1\u0026lt;\u0026lt;endl;//本题中root也算一个节点，别忘了+1 return 0; } ","date":"2024-01-16T09:54:00+08:00","image":"https://werchange.github.io/img/trie/1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88-trie-%E6%A0%91/","title":"浅谈 Trie 树"},{"content":"浅谈基数排序\r前言\r注意，本贴的算法是基数排序而不是计数排序。这两者差别不大，但是存在着一定差异。\n一句话做法\r从低位到高位，每次都把所有要排序的数（含前导 $0$）丢入相应的桶（$0$~$9$），再从小到大（对于桶的编号而言从小到大）取出来，一定次数后，原数组有序。\n数据模拟\r假如要对以下几个数排序。\n1 103 7 65 234 932 45 第一轮，看个位\r此刻数组为：\n1 932 103 234 45 65 7 第二轮，看十位\r此刻数组为：\n1 7 103 932 234 45 65 第三轮，看百位\r此刻数组为：\n1 7 45 65 103 234 932 此时尽管数组已经有序，但过程并未完整。因为对于一些数据是不一定如此凑巧提前就能排好序的。\n第四轮，看千位\r此刻数组为：\n1 7 45 65 103 234 932 数组已经有序。\n证明\r注：以下考虑正整数。“数字”是 $[0,9]$ 之间的，“数”是 $[0,+\\infty)$。\n在小学一年级的时候，我们就已学过如何比较数之间的大小。\n首先看数的位数，位数大的，肯定较大。\n其次从高到低比较每位上的数字大小，一直到不等的时候，哪个数字大，那个数就大。\n因此，基数排序的原理也是一样的。\n首先从最低位开始放，就可以确定当前位的数字的相对大小关系。\n然后考虑再高一位的时候（不妨称为“升位”），那些位数不够的数就会全部放入 $0$ 的桶里。\n由于我们是按从小到大的顺序将不同的桶的元素放入 $0$ 号桶，所以保证了“桶底”的一定是最小的。\n","date":"2024-01-15T22:09:00+08:00","image":"https://werchange.github.io/img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/p1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","title":"浅谈基数排序"},{"content":"超级简单的后缀数组（SA）！！\r前言\r这里选择当一手标题党。\n由于刚学完这个字符串算法，本人字符串算法又比较薄弱，好不容易这一次在晚修看各种资料看得七七八八，决定趁脑子清醒的时候记录下来。\n免得自己不久后忘了后又要痛苦地再看各种资料。希望这篇博客能帮到你。\n前置知识：RMQ 问题、基数排序、lcp 问题\n使用指南：在抽象的时候，可以选择先不看证明；先记住结论，顺一遍后再返回来补证明也是可以的。如果有草稿本和笔，是最佳的选择。\n到底什么是“后缀数组”？\r后缀，顾名思义，即为 $[i,..,n]$ 的区间。以 $S$ 的第 $i$ 个字符开始的后缀定义为 $\\text{Suffix}(i)$，下文简写为 $\\text{suf}(i)$。\n如果这玩意儿（后缀）碰上了字符串，那么后缀也就成了特殊的字串。\n后缀数组又是什么呢？\n“后缀数组——处理字符串的有力工具。”——国集选手罗穗骞\n说到底，这是一个处理字符串的基础算法。\n学会 后缀自动机（SAM） 之后是不是就可以不学 后缀数组（SA） 了？不！虽然 SAM 更为强大和全面，但是有些问题 SA 将体现出优势，只单方面地掌握 SAM 是远远不够的。\n例子：求一个串后缀的 lcp 方面的应用，SA 可以直接用 RMQ，但是 SAM 还要求出 LCA。等等。\n那现在让我们开始吧。\n后缀数组与名次数组\r此“后缀数组”非彼“后缀数组”，此二级标题中的“后缀数组”是一个实打实的数组。定义为：$\\text{SA}[i]$，存储的是 $1,\u0026hellip;,n$ 的一个排列。\n他保证 $\\text{suf}(\\text{SA}[i])\u0026lt;\\text{suf}(\\text{SA}[i+1])$，就是将 $S$ 的后缀从小到大排序后把后缀的开头按序放入 $\\text{SA}$ 中。\n名次数组 $\\text{Rank[i]}$ 存储的是 $\\text{suf}(i)$ 在所有后缀中排序后的名次。\n一言了之，$\\text{SA}[i]$ 表示原串中从小到大排名为 $i$ 的是哪个后缀；$\\text{Rank}[i]$ 表示原串中后缀 $i$ 从小到大排名后的名次。\n“简单的说，后缀数组是‘排第几的是谁？’，名次数组是‘你排第几？’。”——罗穗骞\n显然，这俩玩意儿就是双映射关系，说白了就是运算互逆。\n怎么求出这两个数组？——倍增算法\r大家都可以想到的朴素算法或时间复杂度不优秀的算法这里就不再提及了。\n由于过于复杂的 $\\text{DC3}$算法 本人又不会，所以这里只提及 $\\text{O}(n \\log n)$ 的倍增算法。\n主要思路：对每个字符开始长度为 $2^k$ 的子串进行排序，求出 $\\text{Rank}$ 值。\n$k$ 从 $0$ 开始，每次不断 $+1$ 直到长度超过了原串的长度（$2^k\u0026gt;n$）。当达到限制后，每个字符开始的长度为 $2^k$ 的子串便相当于所有的后缀。并且此时肯定已经得到了互不相等的 $\\text{Rank}$ 值。\n此刻要解决的是如何排序。\n如果采用 sort 快排，时间复杂度并没有利用字符串后缀的性质。\n我们在处理长为 $2^k$ 的问题时，肯定是已经知道 $2^{k-1}$ 的 $\\text{Rank}$ 值。那我们就可以利用这些值，把一个子串 $\\text{Sub}(i,2^k)$ （从 $i$ 开始长度为 $2^k$ 的串），看作由两个关键字组成：$\\text{Sub}(i,2^{k-1})+\\text{Sub}(i+2^{k-1},2^{k-1})$。由此，可用基数排序。\n举个例子：\n以字符串“aabaaaab”为例，整个过程如图所示。其中 $x,y$ 是表示长度为 $2^k$ 的字符串的两个关键字 。\n怎么样？这个图看不懂？静下心来，细细揣摩。这里要嚼透了（尤其是 $\\text{SA},\\text{Rank}$ 数组的差别），才能理解后面更为抽象的代码实现。\n求 SA 代码具体实现\r以往很多算法都是贴个模板 code 就走人了，但今天不行。\n放一下板子，你们就明白（为什么不行）了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int sa[MAXN],rk[MAXN],oldrk[MAXN\u0026lt;\u0026lt;1],id[MAXN],key1[MAXN],cnt[MAXN]; bool cmp(int x,int y,int w) {return oldrk[x]==oldrk[y]\u0026amp;\u0026amp;oldrk[x+w]==oldrk[y+w];} void SA() { for(int i=1;i\u0026lt;=n;i++) ++cnt[rk[i]=s[i]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[rk[i]]--]=i; int p; for(int w=1;;w\u0026lt;\u0026lt;=1,m=p) { p=0; for(int i=n;i\u0026gt;=n-w+1;i--) id[++p]=i; for(int i=1;i\u0026lt;=n;i++) if(sa[i]\u0026gt;w) id[++p]=sa[i]-w; for(int i=1;i\u0026lt;=m;i++) cnt[i]=0; for(int i=1;i\u0026lt;=n;i++) ++cnt[key1[i]=rk[id[i]]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[key1[i]]--]=id[i]; for(int i=1;i\u0026lt;=n;i++) oldrk[i]=rk[i]; p=0; for(int i=1;i\u0026lt;=n;i++) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; if(p==n) break; } } 如果你能直接看懂此代码是如何求出 $\\text{SA}$ 数组——\n那么您可以直接离开此寒舍了。并接受在下一膜拜~ Orz\n如果你留了下来，别着急，我来分步讲解。\n对长度为 $1$ 的子串排序\r1 2 3 for(int i=1;i\u0026lt;=n;i++) ++cnt[rk[i]=s[i]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[rk[i]]--]=i; 第 1 行，就是把长为 $1$ 的子串（就是字符啦）全部扔进桶里。\n第 2 行，把这个桶转换成前缀和，就可以知道字符 $i$ 在原串是第几个了。\n第 3 行，由于桶内的元素也要分个排名，所以这里的写法选择了倒序循环、cnt--。\n其实这 3 行就是在做基数排序\n对长度为 $w$ 的子串排序\r先搞定第二关键字的排序\r1 2 3 p=0; for(int i=n;i\u0026gt;=n-w+1;i--) id[++p]=i; for(int i=1;i\u0026lt;=n;i++) if(sa[i]\u0026gt;w) id[++p]=sa[i]-w; 第 2 行，先把那些以自己开头，长度不足 $w$ 的 $i$ 放在排序数组 $id$ 的前端。这是因为他们根本没有第二关键字，可视为 $0$，自然是最小的。这里倒不倒序是一样的，你也可以正序写。\n第 3 行，把那些有第二关键字的，记录他们第一关键字的开头，即 sa[i]-w。\n分析一下，第 2 行的操作其实也是在记录第一关键字的开头。\n处理出新的 SA 数组\r1 2 3 4 for(int i=1;i\u0026lt;=m;i++) cnt[i]=0; for(int i=1;i\u0026lt;=n;i++) ++cnt[key1[i]=rk[id[i]]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[key1[i]]--]=id[i]; 第 1 行，置空 $\\text{cnt}$，当然可以 memset(cnt,0,sizeof(cnt))。\n第 2-3 行，性质上是等价于对单个字符处理出 $\\text{SA}$ 的操作的，都是在做基数排序。这里的 key1[i]=rk[id[i]] 是一个减少访问空间来节约时间的小 Trick（因为第 4 行再次出现 key1[i]）。注意这里 $key1[i]\\neq i$，这是因为此刻的 $\\text{Rank}$ 并非此轮的新值，而是上一轮的旧值。\n第 4 行，处理出新的 $\\text{SA}$ 数组。\n根据新的 SA 得出新的 Rank\r1 2 3 4 for(int i=1;i\u0026lt;=n;i++) oldrk[i]=rk[i]; p=0; for(int i=1;i\u0026lt;=n;i++) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; if(p==n) break; 第 1 行，之所以要拷贝一份上一轮的 $\\text{Rank}$，这是因为在得到新的 $\\text{Rank}$ 时，需要上一轮的值。但是为了避免冲突，这里才会拷贝出一份。当然，代码你也可以写成 memcpy(oldrk+1,rk+1,n*sizeof(int))。\n第 2-3 行，得出新值。注意，由于 $\\text{Rank}$ 是可能有相同的，所以需要比较两个字符串是否完全相同。即 cmp(sa[i],sa[i-1],w)。\n第 4 行，由于 $p$ 表示不同的字符串的个数，所以一旦 $p=n$，意味着再没有相同的字符串，再往下做排序已不会改变 $\\text{Rank}$ 值。例如下图，第 4 次排序就是没有必要的。\nfor 循环为什么这么写？\r1 for(int w=1;;w\u0026lt;\u0026lt;=1,m=p) 变量 $w$ 代表长度，这里不多说了。至于这个 m=p，首先要明确的一点是，$m$ 表示桶可装的元素最大值。而排序后，$\\text{Rank}$ 数组中的最大值小于 $p$，所以可以改变最大值。也就是优化基数排序值域。\n一些常数优化 Trick\r第二关键字无需基数排序。正如代码中所打，按照他的实质，把无第二关键字的丢到最前面，再把剩下的依次放入。 优化基数排序的值域。代码中的 $p$ 即是 $\\text{Rank}$ 的值域，可以优化值域。 利用 $\\text{key1}$ 数组存储，减少不连续内存访问。这个在大数据效果明显。 利用 $\\text{cmp}()$ 代替计算。原理同 3。 利用指针直接交换的性质。 在 $\\text{oldrank}$ 数组拷贝时，是循环拷贝，常数较大。如果在定义时定义成指针形式，那就可以直接 t=x,x=y,y=t 进行一步交换。（但是这玩意儿很容易打错，编译器的警告也奇奇怪怪，慎用！！） 注：本贴提供的局部代码，除第 5 点外，其余 4 点均已运用。\n这个后缀数组能干什么？\r在上文，我们用了大量的篇幅来介绍什么是后缀数组、怎么代码实现求出后缀数组。那我们学会了后缀数组后，能用它解决什么问题呢？\n现在回答这个问题还为之过早。要想理解后缀数组的应用，先来了解一下 $\\text{height}$ 数组。\n什么是 $\\text{height}$ 数组\r定义 $\\text{height}[i]=\\text{lcp}(\\text{suf}(\\text{SA}[i-1]),\\text{suf}(\\text{SA}[i]))$，$\\text{lcp}(a,b)$ 即为 $a$ 和 $b$ 的最长公共前缀。\n对于 $j,k(\\text{Rank}[j]\u0026lt;\\text{Rank}[k])$，有以下性质：\n$$\r\\text{lcp}(\\text{suf}(j),\\text{suf}(k))=\\min\\{\\text{height}[\\text{Rank}[j]+1],...,\\text{height}[\\text{Rank}[k]]\\}\r$$ 以字符串 aabaaaab，求 abaaaab 和 aaab 的最长公共前缀为例：\n如何高效得到 $\\text{height}$ 数组？\r如果直接从 $\\text{height}[2]$ 计算到 $\\text{height}[n]$，时间复杂度是 $\\text{O}(n^2)$ 的。并没有利用上字符串的一些性质。\n如果我们定义数组 $\\text{h}[i]=\\text{height}[\\text{Rank}[i]]$，也就是 $\\text{suf}(i) $ 和他前一名的后缀的最长公共前缀。将有以下性质：\n$$\r\\text{h}[i]\\geq \\text{h}[i-1]-1\r$$ 考虑证明（这里借鉴了 oi-wiki）：\n如果你不想看证明，或者看不懂，可以跳到 一个方向 部分。\n当 $\\text{height}[\\text{Rank}[i-1]]\\leq 1$ 时，不等式成立（右边 $\\leq 0$）。\n当 $\\text{height}[\\text{Rank}[i-1]] \u0026gt;1$ 时：\n根据定义，转化为：\n$$\r\u003e \\text{lcp}(\\text{SA}[\\text{Rank}[i-1]],\\text{SA}[\\text{Rank}[i-1]-1]) \u003e 1\r\u003e $$ 既然 $\\text{suf}(i),\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1])$ 有长度为 $\\text{height}[\\text{Rank}[i-1]]$ 的最长公共前缀。\n不妨设这个前缀为 $aA$，即一个字符和一个长为 $\\text{height}[\\text{Rank}[i-1]]-1$ 的非空字符串。\n那么 $\\text{suf}(i-1)=aAD$，$\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1])=aAB$。（$B\u0026lt;D$，$B$ 或为空串，$D$ 非空）\n因此，$\\text{suf}(i)=AD$，$\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1]+1)=AB$。\n因为 $\\text{suf}(\\text{SA}[\\text{Rank}[i]-1])$ 在大小排名上仅比 $\\text{suf}(\\text{SA}[\\text{Rank}[i]]))$（即 $\\text{suf}(i)$）少一位，而 $AB\u0026lt;AD$。\n所以 $AB\\leq \\text{suf}(\\text{SA}[\\text{Rank}[i]-1])\u0026lt;AD$，显然 $\\text{suf}(i)$ 与 $\\text{suf}(\\text{SA}[\\text{Rank}[i]-1])$ 有公共前缀 $A$。\n于是可得，$\\text{lcp}(i,\\text{SA}[\\text{Rank}[i-1]])$ 至少是 $\\text{height}[\\text{Rank}[i-1]]-1$。\n即 $\\text{height}[\\text{Rank}[i]]\\geq \\text{height}[\\text{Rank}[i-1]]-1$。\n令 $\\text{h}[i]=\\text{height}[\\text{Rank}[i]]$，则\n$$\r\\text{h}[i]\\geq \\text{h}[i-1]-1\r\u003e $$ 证毕。\n一个方向\r得知此性质后，我们就有了明确的方向。按照 $\\text{h}[1],\u0026hellip;,\\text{h}[n]$ 的顺序计算，并利用 $\\text{h}$ 数组的性质。时间复杂度为 $\\text{O}(n)$。\n代码实现获得 $\\text{height}$ 数组\r1 2 3 4 5 6 for (i = 1, k = 0; i \u0026lt;= n; ++i) { if (rk[i] == 0) continue; if (k) --k; while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; height[rk[i]] = k; } 这里 $k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次，复杂度 $\\text{O}(n)$。\n$\\text{height}$ 数组能干些什么——后缀数组算法的应用\r文章到这里，就是后缀算法的应用了。\n先简单介绍一下能应用在什么问题之上。\n最长公共前缀 单个字符串的相关问题 重复子串 字串的个数 回文子串 连续重复子串 两个字符串的相关问题 公共子串 字串的个数 多个字符串的相关问题 由于本人还没有做相关练习，这里先只介绍问题 1。其他的我先溜去做题了。\n例 1：最长公共前缀\r给定一个字符串，每次询问某两个后缀的最长公共前缀。\n分析：\r根据性质\n$$\r\\text{lcp}(\\text{suf}(j),\\text{suf}(k))=\\min\\{\\text{height}[\\text{Rank}[j]+1],...,\\text{height}[\\text{Rank}[k]]\\}\r$$ 可以将问题转化成 RMQ 问题。如果用 ST 表，那么 $\\text{O}(n\\log n)$ 预处理， $\\text{O}(1)$ 查询。\n如果用 $\\text{O}(n)$ 预处理 RMQ 问题，那么本题可以做到 $\\text{O}(n)$。（虽然作者不会 $\\text{O}(n)$ 预处理）\n参考文献\r[1] 罗穗骞，IOI2009 国家集训队论文《后缀数组——处理字符串的有力工具》\n[2] OI-Wiki，《后缀数组简介》\n[3] YxuanwKeith，《五分钟搞懂后缀数组！后缀数组解析以及应用(附详解代码)》\n结尾\r这篇笔记写得匆匆忙忙，昨天晚修开始写，写到今天早上。\n有错误时不可避免的，欢迎读者指出我的错误。如有疑问或高见，也可以评论。\n由于一上完课就来写笔记，还没做多少题目，这里只讲了最长公共前缀的算法分析，实在抱歉。\n本人版权意识薄弱，如有侵权部分，请联系作者解决。\n希望这篇笔记能帮到你，Thank you~\n","date":"2024-01-14T22:00:00+08:00","image":"https://werchange.github.io/img/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/p1.png","permalink":"https://werchange.github.io/p/%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84sa/","title":"超级简单的后缀数组（SA）！！"},{"content":"题目跳转\nFake_Solution\r前言\r[warning]: 本题解的做法是错法，但是正确概率贼高。离谱的是正确率还可以叠加。\n正解是记搜，时间复杂度可以证明。正解看文末。\n思考\r众所周知一个公式：\n$$\ra\\times b=\\operatorname{lcm}(a,b)\\times \\gcd(a,b)\r$$ 如果你不知道——自证吧，不难。\n于是，移一下项可得\n$$\r\\operatorname{lcm}(a,b)=\\frac{ab}{\\gcd(a,b)}\r$$ 那本题就是求这个玩意儿（设 $g(a,b)=\\gcd(a,b)$， $g(X)=g(x_1,\\dots,x_n)$）\n$$\r\\frac{g(X)\\times g(Y)}{g(g(X),g(Y))}\r$$ 关键是，我们怎么求得这个分数呢？\n观察一手分母，实际上就是\n$$\rg(g(x_1,\\dots,x_m),g(x_1,\\dots,x_m))\\\\\\Downarrow\\\\g(x_1,\\dots,x_m,y_1,\\dots,y_m)\\\\\\Downarrow\\\\g(a_1,\\dots,a_n)\r$$ 也就是说无论怎么放置卡片，分母是始终不变的。都可以根据给出的值求得。\n分子怎么办呢？\n由于是 $g(X)\\times g(Y)$，我们可以试着贪心去取较大值。然后一路 $O(n)$ 下去就好了。\n但是会有问题（极小概率），给个 hack。\n1 2 3 4 3 7175 27378 9184 26427 29992 7190 但是，数据出现这种卡贪心的情况概率极低。Atcoder 的 70 组数据也就一组。\n为了提高正确率，我们可以倒着再跑一次。\n是的，你没听错，就是贪心 + 乱搞。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 50 + 5; int n; int a[MAXN], b[MAXN]; int solve() { int x = a[1], y = b[1]; for (int i = 2; i \u0026lt;= n; i++) { int nx = __gcd(x, a[i]); int ny = __gcd(y, b[i]); int mx = __gcd(x, b[i]); int my = __gcd(y, a[i]); if (nx * ny \u0026gt; mx * my) x = nx, y = ny; else x = mx, y = my; } return x * y / gcd(x, y); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); int ans1 = solve(); for (int i = 1, j = n; i \u0026lt;= j; i++, j--) swap(a[i], a[j]), swap(b[i], b[j]); int ans2 = solve(); printf(\u0026#34;%lld\\n\u0026#34;, max(ans1, ans2)); return 0; } Solution\r还是补一个正解做法。其实直接记忆化爆搜就好了，时间复杂度可以证明通过本题限制~~（虽然我不会）~~。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 50 + 5; int n; int a[MAXN], b[MAXN]; struct node { int x, ga, gb; node(int a = 0, int b = 0, int c = 0) { x = a; ga = b; gb = c; } bool operator\u0026lt;(const node \u0026amp;T) const { if (x != T.x) return x \u0026lt; T.x; if (ga != T.ga) return ga \u0026lt; T.ga; return gb \u0026lt; T.gb; } }; int ans; map\u0026lt;node, bool\u0026gt; vis; int lcm(int a, int b) { return a * b / __gcd(a, b); } void dfs(int x, int ga, int gb) { if (vis[node(x, ga, gb)]) return; vis[node(x, ga, gb)] = 1; if (x == n + 1) { ans = max(ans, lcm(ga, gb)); return; } dfs(x + 1, __gcd(ga, a[x]), __gcd(gb, b[x])); dfs(x + 1, __gcd(ga, b[x]), __gcd(gb, a[x])); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); dfs(2, a[1], b[1]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-12-16T11:48:00+08:00","permalink":"https://werchange.github.io/p/arc124c-lcm-of-gcds-%E9%A2%98%E8%A7%A3/","title":"[ARC124C] LCM of GCDs 题解"},{"content":"提供二分+DP做法。\nSolution\r题意\r给出 $n(\\le 2\\times 10^5)$ 个单调递增偶整数 $a_i$，求最小的 $k$ 满足每一个 $i$ 都可以在 $k$ 时刻之前（含）与相邻的数相遇。每个单位时间可以移动一个单位距离。\n思路\r启发式思考\r在想到正解之前，我们可以想想类正解。\n显然，在时间一单位一单位过去的时候，一个元素如果愣着不动，肯定不是最优的策略——因为无论它去追随相邻的、或是去相遇相邻的，时间都可以尽可能更优。\n所以我们看做元素是不断运动的。\n如果它乱走，没有遇到任意一个相邻的元素的情况下，随便改变方向，好像也不优。所以我们也规定一个元素就只有两个阶段：第一、第二阶段——要么先左再右，要么先右再左。\n想到这里，对我们有了些许启发。来看看下面这个能拿 80pts 的错解：\n就考虑两种情况：\n奇（ji）左偶右：黑色表示第一阶段、红色表示第二阶段 奇（ji）右偶左：同上 当然 $n$ 的奇偶也要考虑。\n像这样，是不是以为可以直接 $O(n)$ 直接跑就解决了？\n显然，这太天真了 （像我一样） ，提供一组 hack 数据：\ninput\r1 2 10 12 12 24 26 56 70 98 124 124 178 answer\r1 34 output\r1 36 至于模拟过程自己模拟吧，这是我能对出来的最小数据了。\n贴一个错误代码，可以自己对拍对数据。\n正解\r我们可以直接二分答案 $k$。\n接下来考虑怎么扩缩范围。\n设 $f(i,0)$ 表示元素 $i$ 先左走，调头后最多还可走多少步。\n设 $f(i,1)$ 表示元素 $i$ 先右走，最多可以走多少步再掉头。\n然后就是小学学过的相遇问题，自己在纸上画画就出来了，这里不做赘述。要是不会的话，可以私信。\n方程不好整理 （因为我懒） 自己看代码吧。挺具象的。\n代码\r马蜂抽象就随便看看吧，溜了\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5; int n; int a[MAXN]; int d[MAXN]; int f[MAXN][2]; bool check(int md) { memset(f, -1, sizeof(f)); f[1][1] = md; for (int i = 2; i \u0026lt;= n; i++) { if (f[i - 1][1] != -1) { int k = f[i - 1][1]; if (k - d[i] / 2 \u0026gt;= 0) { f[i][0] = max(f[i][0], md - d[i] / 2); f[i][1] = max(f[i][1], k - d[i] / 2); } } if (f[i - 1][0] != -1) { int k = f[i - 1][0]; if (k - d[i] / 2 \u0026gt;= 0) { f[i][0] = max(f[i][0], k - d[i] / 2); f[i][1] = max(f[i][1], k - d[i] / 2); } } } return f[n][0] != -1 || f[n][1] != -1; } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); for (int i = 2; i \u0026lt;= n; i++) d[i] = a[i] - a[i - 1]; int l = 1, r = 1e9, mid, ans = -1; while (l \u0026lt;= r) { mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-12-04T20:14:00+08:00","permalink":"https://werchange.github.io/p/arc120e-1d-party-%E9%A2%98%E8%A7%A3/","title":"[ARC120E] 1D Party 题解"},{"content":"题解\r前言\r个人认为官方题解写得最为详细、干净、清楚，如果有意向阅读外文版的题解的话，还是推荐去读一读：\nEditorial - AtCoder Regular Contest 117\n本文属于转载（？），有一些自己的思考过程，希望有帮助。\n题意\r有多少个长度为 $2N$ 的序列 $A$ 满足：\n序列$A$ 包含 $N$ 个 $+1$ 和 $N$ 个 $-1$。 刚好有 $K$ 对下标 $l,r(1\\leq l\u0026lt;r\\leq 2N)$，满足 $\\sum\\limits_{i=l}^{r} = 0$，我们把形如 $[l,r]$ 这样的区间称为“零和区间”。 给出 $N,K$，求满足条件的序列个数。\n$1\\leq N\\leq 30,1\\leq K\\leq N^2$。\n分析\rPart 1\r我们考虑用最暴力的做法，那就是二进制枚举 $A$ 的状态。然后枚举 $l,r$ 采用前缀和相减判断是否为零和区间。\n时间复杂度：$O(2^n)$，预计：34 pts。\nPart 2\r显然 Part 1 的做法超时，那我们能不能得到一些启发呢？\n显然是前缀和。\n我们期望得到的是 $sum_r-sum_{l-1}=0$，实际上，我们也就是想得到 $sum_r=sum_{l-1}$。由于原数组为 $\\pm 1$，所以当我们把前缀和数组看做是关于 $i$ 的函数 $sum_i$ 的话，得到的图像，必定是每一段都为 45° 的折线图。而起点与终点都将是 $0$。\n我们可以想象一条 $y=k$ 的一条横线从上往下扫。我们就可以分别考虑放置所有二维平面上的点了。\n我们发现两个相等且“相邻”的元素之前是可以放下一个或多个更小的元素的。“相邻”怎么解释？“相邻”代表着当只考虑当前的元素 $y$ 与大于 $y$ 的元素时，如果两个元素 $y$ 之间没有再多一个元素 时，则称之为“相邻”。我们把“相邻”的元素之间的空隙，称之为“洞”。\n如果考虑到当前这个“洞”（下文不再加括号），我们先考虑当前要放的元素都是相同的值。\n那就可以自然地想到采用 dp。\n设 $f[x][y][z]$ 表示放了 $x$ 个元素，得到了 $y$ 个零和区间，还有 $z$ 个洞的方案数。\n如何转移？设当前放进洞里的元素数量为 $p$，则转移方程为：\n$$\rf[x][y][z]\\to f[x+p][y+C_p^2][p-(z+2)]\r$$ $$\\Downarrow$$ $$\rf[x][y][z]\\to f[x+p][y+\\frac{p\\times(p-1)}{2}][p-(z+2)]\r$$ 为什么剩下的洞的数量是 $p-(z+2)$ 呢？因为原来有 $z$ 个洞，每个洞需要放一个元素，同时最左边与最右边又需要各放一个元素，就共放了 $z+2$ 个元素。\n在此基础上，每多放一个元素，就可以多增加一个洞。自然就是 $p-(z+2)$。\n值得一提的是，上式并没有采用等号连接，因为方程还需要再乘上一个 $C_{p-1}^{z+1}$（读者自证）。所以方程应该是这样：\n设 $x\u0026rsquo;=x+p,y\u0026rsquo;=y+\\frac{p(p-1)}{2},z\u0026rsquo;=p-(z+2)$，则\n$$\rf[x'][y'][z']=\\sum\\limits_{x,y,z} f[x][y][z]\\times C_{p-1}^{z+1}\r$$ 最后答案需要记录 $x$ 轴上、下方的贡献，总共就是\n$$\rans=\\sum\\limits_{x,y,z} f[x][y][z]\\times f[2n-x][k-y][z-1]\r$$ 至于为什么是 $z-1$ 呢？这个显然，请读者联系一下上图思考。（提示，$x$ 轴下方可以翻转过来相似地考虑。）\n到这里就结束了，可以开码了。\n时空复杂度：$O(n^5)$，预计：100 pts。\n代码\r马蜂有点抽象，将就看看吧（\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 60 + 5, MAXM = 1800 + 5; int n, m; int f[MAXN][MAXM][MAXN]; int ans; int c[2 * MAXN + 5][2 * MAXN + 5]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt;= 2 * n; i++) { c[i][0] = 1; for (int j = 1; j \u0026lt;= i; j++) { if (j != i) c[i][j] += c[i - 1][j]; c[i][j] += c[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n + 1 \u0026amp;\u0026amp; i * (i - 1) / 2 \u0026lt;= m; i++) f[i][i * (i - 1) / 2][i - 1] = 1; for (int i = 1; i \u0026lt;= 2 * n + 1; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int k = 0; k \u0026lt;= n; k++) { if (f[i][j][k] == 0) continue; for (int p = k + 2; i + p \u0026lt;= 2 * n + 1 \u0026amp;\u0026amp; p \u0026lt;= n + 1; p++) { if (j + p * (p - 1) / 2 \u0026gt; m) break; f[i + p][j + p * (p - 1) / 2][p - (k + 2)] += f[i][j][k] * c[p - 1][k + 1]; } } } } ans = f[2 * n + 1][m][0]; for (int i = 0; i \u0026lt;= 2 * n + 1; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int k = 1; k \u0026lt;= n; k++) { ans += f[i][j][k] * f[2 * n + 1 - i][m - j][k - 1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-11-24T17:28:00+08:00","permalink":"https://werchange.github.io/p/arc117e-zero-sum-ranges-2%E9%A2%98%E8%A7%A3/","title":"[ARC117E] Zero-Sum Ranges 2题解"},{"content":"Success Rate\n（提供二分做法）\n前言\r听说是史上最简单蓝题，做了一下。\n题意\r已知 $x,y,p,q$，通过只让 $y$ 加 $1$ 或 $x,y$ 同时加 $1$，使得满足： $$\r\\frac{x'}{y'}=\\frac{p}{q}\r$$ 思考\r目标状态为 $\\frac{p}{q}$，考虑到这是个比值，自然 $\\frac{x\u0026rsquo;}{y\u0026rsquo;}=\\frac{kp}{kp}$。\n明显地，这里的 $k$ 如果合法，那就一定有更小的 $k$。\n所以考虑二分。\n限制条件呢？\n因为无论如何决策，$y$ 都会加 $1$；而 $x$ 不一定每一次决策都加 $1$。即 $\\Delta y\\geq \\Delta x$。\n所以保证 $\\Delta x \\leq \\Delta y$ 就好了。即 $kp-x\\leq kq-y$。\n需要注意的是，有一点需要特判：\n$p=0$ 时 $x\u0026gt; 0$，输出 $-1$ $x=0$，输出 $0$ 代码\r考虑到数据范围均小于 $10^9$，所以右端点不可以取太大，否则越界变成负数，右端点取 $10^{10}$，开个 long long 就好了。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int x,y,p,q; bool check(int md) { return p*md-x\u0026lt;=q*md-y \u0026amp;\u0026amp; p*md\u0026gt;=x; } void solve() { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;p,\u0026amp;q); if(p==0) { if(x) puts(\u0026#34;-1\u0026#34;); else puts(\u0026#34;0\u0026#34;); return; } int l=1,r=1e10,mid,ans=-1; while(l\u0026lt;=r) { mid=l+r\u0026gt;\u0026gt;1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } if(ans==-1) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;,ans*q-y); } signed main() { signed T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) solve(); return 0; } ","date":"2023-11-02T20:10:00+08:00","permalink":"https://werchange.github.io/p/cf773a-success-rate-%E9%A2%98%E8%A7%A3/","title":"CF773A Success Rate 题解"},{"content":"CSP2023 总结\r前言\r这次 CSP2023 并没有考出水平。经过深刻反思，我总结了个人目前存在的一些问题与改进的方案。\n上午 CSP-J\r开始后，手忙脚乱地建好了目录文件、配置好了 DEV-C++ 的语法环境、切换好了 ENG 输入法。\nT1\r看到 T1 发现不如去年简单，有些慌张。\n努力冷静下来后，推了一下，就得出了结论，码完之后测了大样例，都过了。还是不放心，又搓了几手小数据，没什么问题，检查完文操后就过了。\n但是由于第一题的小心检查，不仅耗去了不少时间，也使得接下来我陷入了“小心猜想”的怪圈。\nT2\rT2 是今年最遗憾的一题。不是因为不会做、没做出来，而是因为在 T2 消耗了太多时间。\n本应是很快就应该切掉的一题，我却复杂化了题目。\n第一遍猜想时，其实就想到了贪心正解。但是我陷入了“小心猜想、大胆求证”的错误思维怪圈，导致当时不知为什么就直接否了这个猜想。\n过程中跑去看了 T3,T4。\n后面不知过了多久重新读一遍题时，才反应过来这题被我复杂化了。\n此时时间已经超出了我对切 T1,T2 的计划。\nT3\r与去年一样，T3 还是大模拟。一看到还是有信心的，毕竟这题用不着太多思考，尤其是在已经消耗了太多时间的情况下。\n码完之后大样例没过，小调一手就都过了。搓了两组很小的小数据。匆匆检查完文操后就跳了 T4。\nT4\r看到 T4 的时候已经没有时间思考了。虽然卡在 T2 的时候看了一眼题面，但是没有思考过。\n思考一会儿后，只得到一些小性质。\n现在我还有 3 个选择：\n跑去完整检查一遍 T1,T2,T3 ，放弃 T4。 死磕 T4，相信之前的“平推检查”。 打 T4 部分分，再返回检查文操等细节问题 本来我是想着选择死磕，如果前面一分不挂、今年 T4 像去年一样简单，那我的检查就没有效益。\n但是出于之前模拟赛的经验，我知道这种压力环境下是很难想的。所以我选择了放弃 AK 梦。\n我决定看着数据范围打拼盘。（相信数据！）\n由于样例都没有特殊性质的数据，自己搓了一些，打了文操就过了。\n估分\r$100+100+80+5=285$\nT3 是 T 了两个点，我觉得应该是有一部分卡死了。可惜的是，考场上没有检查 T3 代码，只检查了细节。T4 不知道实际到底能骗多少分，应该不止 5 分。\n下午 CSP-S\r下午开始前，整个人的状态是很好的，好到有些飘。因为自以为拿了 300+ pts，所以莫名信心++。为后面“暴毙”埋下伏笔。\n开始后，有了上午的经验，飞快地完成了硬性要求操作。开始读题。\nT1\r简单看了两眼，有点难。\n再看一眼，怎么就 5 位密码？\n再看一眼数据，$n\\leq 8$，直接 $O(10^5n)$ 走起！\n飞快地打完了，再次严谨地检查了时间复杂度，确认不会 T，检查完文操、搓了一手数据后跑路。\nT2\r区间？试一下线段树/分治。\n思考了很久，不知道怎么处理两个区间相邻部分。赛后听 cjx 说是 cdq 分治。没学，幸好当时没有继续往分治想。\n现在看我的代码，我已经说不清当时怎么想的了。总之糊了一个类似正确的做法。\n一测大样例，直接错误。\n由于大样例很大，很难判断，我尽可能的举出小并且能证伪的数据。幸运的是举了几个出来、答案也越来越接近大样例的 .ans；不幸的是，再往后就举不出来了，可是始终有两个大样例过不了。\n此时时间已经超过预计了。按理，我不会 T，是 WA，但是有些数据下是可以过的、不会 0 pts，例如大样例3 就惊奇的被我糊过了。所以我应该跳题。去打部分分。\n但是，出于上午 J组的自信。我做了最愚蠢的决定——死磕 T2。\n这一死磕，就真的是没有尽头了。\n等我反应过来的时候，想上个厕所冷静一下。上厕所的人很多，我抬头看了一眼，总有人进进出出。我想我是排不到了，所以没有申请上厕所。但是我注意到，外面的天都已经黑了。——我慌了。\n我犹豫过，要不要跳 T3，我看到一眼就知道了是大模拟。但是我执迷不悟，看了一眼后不打算跳。T4 我题目都没看懂（匆匆看了两眼），想起去年最后一题是紫题，所以没有勇气去花时间看懂。\n但是最后我慌了，要是再打不出来，200+ pts 是无望了。一等也就无望了。我选择认怂。\n跳题。\nT3\r看了题目，按理来说照着题面打就能打A。毕竟是大模拟。但是我连看懂题目的时间也没有了。我清楚这道题是要丢了。\n看到 opt 4 有无解情况。又有了去年“总司令”的经验，那就试试。即使这次的数据全部输出无解情况非常渺茫，但总比 0 pts 好。\nT4\r随便看了一眼，输出了 $n+1$。打上文操，回去检查。\n估分\r洛谷：$100+25+0+0=125$\n小图灵：$100+35+0+0=135$\n今年 S组是我第一次打进 S组复赛，所以没有任何经验。\n但是今年我看是没有奇迹般的一等了。\n总结\r两场都没有发挥好。\nJ组：反映出来我很容易陷入“小心猜想、大胆求证”的惰性思维。不勤于思考。\nS组：反映出来我策略不当、心里防线薄弱。很容易因处境改变心里想法。\n以上也都反映了最近乃至前段时间我模拟赛成绩垫底的原因——不勤于思考、总是随便推翻自己却又找不到严谨理由、心里防线薄弱、心态崩溃后大脑宕机。\n计划\r不能一味地批判，要提建设性计划。\n改变思考方式，大胆猜想、小心求证。 多于思考，勤于思考，善于思考。 调整考试策略，找到合适自己的思考时间与代码实现时间。 要善于调整合理心理状态、建设强大的心理防线。 总结经验，相同错误不犯第二遍。 End\r今年是有遗憾的。\n最后一年 J组破碎了 AK梦。\n初三的 S组不见了一等梦。\nNOIP2023 估计是没机会去了。今年的赛季也大多与我无关了。\n夯实基础、勤学善思，明年还是有很大机会的！\n查分\rCSP-J：$100+100+100+0=300$，一等。\nCSP-S：$100+30+0+0=130$，二等。\n寄了，135pts才能去NOIP，150pts才有一等。。\n赛季报销。。\n","date":"2023-10-28T16:27:00+08:00","permalink":"https://werchange.github.io/p/csp2023-%E6%80%BB%E7%BB%93/","title":"CSP2023 总结"},{"content":"题意很清晰，直接跑 SPFA 求最短路。\n只是我们在松弛操作时，需要注意从 $u$ 是否可以到达 $v$。\n怎么判断呢？\n请移步下面三个部分。\nPart 1\r先解释一下，下面点 $i$ 的信息分别为以下变量：\ncolor 表示颜色， 1 表示蓝色，0 表示紫色 num 表示初始状态持续时间 t1 表示蓝色状态持续时间 t2 表示紫色状态持续时间 我们写一个函数 getcolor(int i,int tim)，表示点 $i$ 在 $tim$ 时刻的下一个颜色状态是什么。\n分一下情况：\n$tim\u0026lt;num[i]$，直接返回 color[i]^1。 $tim\\geq num[i]$ $color[i]$ 为紫色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t1[i]$，返回 color[i]。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t1[i]$，返回 color[i]^1。 $color[i]$ 为蓝色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t2[i]$，返回 color[i]。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t2[i]$，返回 color[i]^1。 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool getcolor(int i,int tim) { bool color=a[i].color^1; if(tim\u0026lt;a[i].num) return color; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return color^1; return color; } else { if(tim\u0026lt;a[i].t2) return color^1; return color; } } Part 2\r得到一个函数，仅仅只能求第 $tim$ 时刻的下一个颜色状态是远远不够的。\n我们还需要与这个函数类似功能的函数 gettim(int i,int tim)。\n意义为：\n得到一个值，这个值表示点 $i$ 在 $tim$ 时刻变成下一个状态还需要多少时间。\n与上一 Part 类似的，可以分讨一下：\n$tim\u0026lt;num[i]$，直接返回 num[i]-tim。 $tim\\geq num[i]$ $color[i]$ 为紫色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t1[i]$，返回 t1[i]-tim。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t1[i]$，返回 t1[i]+t2[i]-tim。 $color[i]$ 为蓝色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t2[i]$，返回 t2[i]-tim。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t2[i]$，返回 t1[i]+t2[i]-tim。 代码也很类似。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int gettim(int i,int tim) { if(tim\u0026lt;a[i].num) return a[i].num-tim; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return a[i].t1-tim; return a[i].t1+a[i].t2-tim; } else { if(tim\u0026lt;a[i].t2) return a[i].t2-tim; return a[i].t1+a[i].t2-tim; } } Part 3\r得到了这两个函数，一切都变得简单多啦~\n现在思考在松弛中面对 $u$ 和 $v$ 两个点时的情况。\n先是用变量 cu 和 cv 分别表示 $u$ 的下一个颜色与 $v$ 的下一个颜色。\n如果 $cu=cv$，直接松弛。 如果 $cu\\neq cv$，多拿一个变量 tmp 负责接下来记录要等待多少时间才能从 $u$ 走到 $v$。 现在讨论 $cu\\neq cv$ 的情况。\n先分别得到 $u$ 和 $v$ 变成下一个状态所需要的时间 tu 和 tv。\n如果 $tu=tv$，则 tmp=min(tu,tv)。 如果 $tu\\neq tv$，说明接下来要看周期性的颜色变换是否可以让 $u$ 走到 $v$。 现在讨论周期性的颜色变换。\n由于是周期性的，所以如果 $u$ 注定永远走不到 $v$，说明它们的周期总是交叉相等。\n什么意思呢？举个例子。\n1 2 u: B 6 10 70 v: P 6 70 10 上面这两个点，总是同时变换状态，所以永远不能到达。所以我们判断周期是否交叉相等就可以筛掉无法到达的情况。直接 continue 松弛下一个 $v\u0026rsquo;$。\n那接下来就注定可以到达，直接分讨一下就可以得到 tmp 了。\ntmp 一出，有手就行。只需要在松弛的判断中加上一个 tmp 就好了。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=400+5,MAXM=14000+5,INF=1e18; int s,t; int n,m; int su,hd[MAXN],vl[MAXM\u0026lt;\u0026lt;1],lt[MAXM\u0026lt;\u0026lt;1],en[MAXM\u0026lt;\u0026lt;1]; int dis[MAXN]; bool vis[MAXN]; struct node { bool color; int num,t1,t2; }a[MAXN]; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } bool getcolor(int i,int tim) { bool color=a[i].color^1; if(tim\u0026lt;a[i].num) return color; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return color^1; return color; } else { if(tim\u0026lt;a[i].t2) return color^1; return color; } } int gettim(int i,int tim) { if(tim\u0026lt;a[i].num) return a[i].num-tim; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return a[i].t1-tim; return a[i].t1+a[i].t2-tim; } else { if(tim\u0026lt;a[i].t2) return a[i].t2-tim; return a[i].t1+a[i].t2-tim; } } void SPFA() { for(int i=1;i\u0026lt;=n;i++) dis[i]=INF; queue\u0026lt;int\u0026gt; q; q.push(s); vis[s]=1,dis[s]=0; while(!q.empty()) { int u=q.front();q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i]; int tmp=0; bool cu=getcolor(u,dis[u]); bool cv=getcolor(v,dis[u]); if(cu^cv) { int tu=gettim(u,dis[u]); int tv=gettim(v,dis[u]); // simple turn once if(tu==tv) // hard turn more { if(a[u].t2==a[v].t1\u0026amp;\u0026amp;a[u].t1==a[v].t2) continue; if(cu==0) // now u is purple { if(a[u].t2==a[v].t1) tmp=a[u].t2+min(a[u].t1,a[v].t2); else tmp=min(a[u].t2,a[v].t1); } else // now u is blue { if(a[u].t1==a[v].t2) tmp=a[u].t1+min(a[u].t2,a[v].t1); else tmp=min(a[u].t1,a[v].t2); } tmp+=tu; } else tmp=min(tu,tv); } if(dis[v]\u0026gt;dis[u]+tmp+vl[i]) { dis[v]=dis[u]+tmp+vl[i]; if(!vis[v]) vis[v]=1,q.push(v); } } vis[u]=0; } } signed main() { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;s,\u0026amp;t,\u0026amp;n,\u0026amp;m); for(int i=1,num,t1,t2;i\u0026lt;=n;i++) { char ch; scanf(\u0026#34;%s%lld%lld%lld\u0026#34;,\u0026amp;ch,\u0026amp;num,\u0026amp;t1,\u0026amp;t2); a[i]={(ch==\u0026#39;B\u0026#39;),num,t1,t2}; } for(int i=1,u,v,w;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w); add(v,u,w); } SPFA(); if(dis[t]==INF) dis[t]=0; printf(\u0026#34;%lld\\n\u0026#34;,dis[t]); return 0; } ","date":"2023-08-22T21:12:00+08:00","permalink":"https://werchange.github.io/p/usaco-jan-2011%E4%BA%A4%E9%80%9A%E7%81%AF-%E9%A2%98%E8%A7%A3/","title":"[USACO JAN 2011]交通灯 题解"},{"content":"01 分数规划\r什么是 01 分数规划\r用人话说，就是：\n有 $n$ 个玩意儿，每个都有两个属性 $(x,y)$。现在要从中选出几个玩意儿，使得 $\\frac{\\sum x}{\\sum y}$ 最大\n但是有些人仍然不懂。没关系，可以用数学语言表示：\n有三个序列 $x,y,z$ 长度为 $n$。\n$z$ 满足 $\\forall i\\in [1,n],z_i\\in(1,0)$\n然后得到一种合法的 $z$ 的取值，最大化： $$\\frac{\\sum\\limits_{i=1}^{n} x_i\\times z_i}{\\sum\\limits_{i=1}^{n} y_i\\times z_i}$$ 怎么解这个问题\r解法：二分法。\n首先先转移：\n令 $L=\\frac{\\sum\\limits_{i=1}^{n} x_i\\times z_i}{\\sum\\limits_{i=1}^{n} y_i\\times z_i}$， 则 $$\rL\\times \\sum\\limits_{i=1}^{n} y_i\\times z_i=\\sum\\limits_{i=1}^{n} x_i\\times z_i \\\\\r\\Downarrow\\\\\r\\sum\\limits_{i=1}^{n} x_i\\times z_i-L\\times \\sum\\limits_{i=1}^{n} y_i\\times z_i=0 \\\\\r\\Downarrow\\\\\r\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i=0\r$$ 相当于拥有了一个数组 $a,a_i=x_i-y_i\\times L$，从$a$中选一些数使得总和最大。\n显然，选择所有的正数即可。\n这个 $L$ 就是二分中的 $mid$ 了。\n由于这个 $L$ 是二分得到的，所以每一次不一定都是 $$\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i=0$$ 而是 $$\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i\\geq0$$ 也就是在代码的二分中判断此刻的 $mid$ 可不可行时，在 if 里面写上这个。\n板题\r这个不算很板的题目，贴一下吧。 P4377 [USACO18OPEN] Talent Show G\n这里附一份代码：\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e5+5; const double eps=1e-6; int n,W; int w[MAXN],t[MAXN],maxz; double a[MAXN]; double f[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;W); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;w[i],\u0026amp;t[i]),maxz+=t[i]; double l=0,r=maxz; while(r-l\u0026gt;eps) { double mid=(l+r)/2; for(int i=1;i\u0026lt;=n;i++) a[i]=t[i]-w[i]*mid; for(int i=1;i\u0026lt;=W;i++) f[i]=-1e9; for(int i=0;i\u0026lt;=n;i++) { for(int j=W;j\u0026gt;=0;j--) f[min(j+w[i],W)]=max(f[min(j+w[i],W)],f[j]+a[i]); } if(f[W]\u0026gt;=eps) l=mid; else r=mid-eps; } printf(\u0026#34;%lld\\n\u0026#34;,(int)floor(1000*l)); return 0; } ","date":"2023-08-14T21:07:00+08:00","permalink":"https://werchange.github.io/p/01-%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","title":"01 分数规划"},{"content":"提供一种思路，可以做到 $O(n)$。\nupdate 2023.08.13 修改了 Latex 滥用问题。\nupdate 2023.08.12 修改了空格问题。\nupdate 2023.08.11 修改了空格问题。\nupdate 2023.07.29 完工，期望无 bug （暑假快乐吖）\nupdate 2023.07.27 （要原题检测了，先占个坑，有时间再补）\n原题大意\r有 $n$ 张牌，每次取出 $m ;(m\u0026lt;n)$ 张牌进行置换操作。操作完一轮后会出第 $1$ 张牌，并再加入 $1$ 张牌继续进行新一轮的置换操作。\n最后无法再进行操作时，则按现顺序不断出牌。\n求倒数第 $x$ 次出牌的原编号是多少。\n暴力解法\r如果没有思考直接开码的话，得到的暴力代码是 $O(nq)$ 的。这个时间复杂度 2013 年的老机器是过不了的。\n预计： 73pts\n倍增解法\r这是正解的一种。通过倍增优化后，时间复杂度是 $O(n \\log n)$。\n此处不展开讲倍增解法，原因有三：\n本题已有大量倍增解法的题解。 虽然是 $O(n \\log n)$，可以通过本题，但还不是最优解，本帖主要讲最优解 $O(n)$ 做法。 本人只会不熟练的运用倍增求 LCA 问题（虽然现在还是用树链剖分求 LCA ），倍增还能优化是我听教练讲解后才知道的。 预计： 100pts\n$O(n)$ 解法\r[warning]： 前方请准备好草稿纸，有演算过程……\nPart 0 思考性质\r首先我们考虑普通的置换。\n例如下面的这个情景：\n有 5 个学生要换位置。\n原位置： $$1\\;2\\;3\\;4\\;5$$ 目标位置： $$4\\;3\\;1\\;5\\;2$$ 推论：如果我们把原位置上的数与目标位置上的数进行建边，会得到一些（可能一个）环或点。\n如上例： $$1\\to 4\\to 5\\to 2\\to 3\\to 1$$ 多举几个例子，会发现都符合推论。\n那我们再来看本题的置换。\n但是本题的置换有一个很大的特色——每次置换后都会推出第 $1$ 个数，加入第 $m+1$ 个数。\n这样的特色带来了一个性质：那就是本题置换不会出现环，只会出现链。\n为什么呢？因为有一个都被推出了，相当于下一次的置换就再也找不到那一个。因此不会形成环。\n那现在，就对我们的置换操作，来分些 Part 吧。\nPart 1 “直接走”操作\r为什么叫“直接走”？这个操作用来得到被推出来的 $n-m+1$ 张牌。\n$n-m+1$ 是因为最多只会做 $n-m+1$ 次置换。\n因此，可以用 dfs 染色的方法先把含$1$的链得出。那么按 dfs 顺序得到的一些 $x_i$ 代表着正数第 $i$ 次原编号为 $x$ 的牌就被推出了。\n但是要一点要注意，因为有的时候置换的操作不多，所以可能有一些残留的、与答案不符的。\n所以需要做个判断，假设得到的 $x$ 数组长度为 $len$。\n若 $len\u0026lt; n-m+1$，则将 $x_i$ 其中 $i\\in [1,len]$ 一个一个地压入答案的 $ans[]$ 数组里。 否则，直接将 $i\\in [1,n-m+1]$ 的所有 $x_i$ 压入 $ans[]$ 即可。 但是，第一种情况时，还有一些 $(n-m+1-len)$ 的元素还没压入怎么办？如何考虑这些元素？\n请移步 Part 2\nPart 2 “直接走没走完”操作\r这里，我们如何思考？\n考场上，可以通过打表法来观察。即我们手搓样例，再模拟出牌过程。\n[warning]： 如果你不想思考、不想自己动手，可以直接跳到一个结论部分。\n这里可以提供一组样例，十分建议大家手搓一下：\n输入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 10 5 10 4 1 3 5 2 10 9 8 7 6 5 4 3 2 1 输出\r1 2 3 4 5 6 7 8 9 10 2 3 1 5 6 7 10 8 9 4 这个样例，是属于“直接走没走完”的情况。因为含 $1$ 的链，只有 $$2\\to 3\\to 1\\to 5$$ 这也正是样例输出的前四个。\n但是 $n-m+1=10-5+1=6$，现在只得到了“直接走”部分的前 $4$ 个，还有俩没输出呢，怎么办？\n仔细看看样例输出，$6$ 和 $7$ 是接下来的这俩。\n有啥规律吗？如果你再多搓几组样例，就会发现一个结论。\n一个结论\r$$\rx_i=m+i\\;\\;\\;\\;\\; i\\in [len+1,n-m+1-len]\r$$ 但是道理是什么？\n因为我们这 $m$ 个位置的置换可以分成两部分：\n从入口 $0$ 到 $m$ 的一条链（路径） 其余部分 而这个其余部分是各种大小不一的环，而置换后，本质上数的位置就是环中不断变换的位置。\n结论已出，那此 Part 结束。现在，我们剑指 Part 3。\nPart 3 “走不完”操作\r为什么叫“走不完”？\n因为剩下的部分数量 $\u0026lt; m $ 无法进行置换操作。故称“走不完”。\n此处要注意的是，有些人一开始会认为：“这些牌做不了置换，那就没有发生过位置变动，直接一个一个按原顺序压入 $ans[]$ 好了。”\n错误的。\n因为有一些部分“经历过”置换，可能是被换过来的。所以上面的说法并不正确。\n那这一部分怎么处理呢？\n先假设从入口 $0$ 到 $m$ 的链（路径）长度为 $l$。\n因为这是最后的 $m-1$ 个数，所以链（路径）中留下来的就是最后进入链（路径）的 $l-1$ 个数。因为没有第 $m$ 个数了（数量都 $\u0026lt; m$ 了嘛），意味着没有新的数加入进来。其余位置也就是环了（这里解释过，在 Part 2 末），那么可以用同余的方式得出每个位置上的数。\nPart 4 查询操作\r那现在，我们把置换分成的这 3 个部分全分析清楚了，那么出牌顺序就可以存下来 $ans[]$ 。询问的时候，$O(1)$ 输出就好了。\n时间复杂度： $O(n)$。\n预计： 100pts\n代码实现\r虽然时间复杂度降下来了，但是这个方法的思考难度、实现难度都比倍增法更难一些。\n所以这里贴一份全代码，各位奆奆洁身自好、不要 COPY。\n此处贴一份原题检测时AC的代码，因为是原题检测，为了手速就丢掉快读、快写了。79ms的评测代码是加了快读、快写的。\n评测下来是 90ms，这仍比 $O(n\\log n)$ 的倍增做法快了不止一点。\n[warning]： 码风丑的话喷轻一点（逃\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN=1e5+5; int n,m,q; int p[MAXN],f[MAXN]; int tot,cnt,len=-1; int rk[MAXN]; int col[MAXN],ans[MAXN],b[MAXN],c[MAXN]; bool vis[MAXN]; struct node { vector\u0026lt;int\u0026gt; v; }a[MAXN]; void dfs(int x,int co) { if(col[x]) return; if(co==1) b[++len]=x; col[x]=co; rk[x]=a[co].v.size(); a[co].v.pb(x); if(x\u0026gt;=m) return; dfs(f[x+1],co); } void work1(int x) { if(col[x]==1) { if(rk[x]\u0026gt;=n-m+1) c[a[1].v[rk[x]-n+m-1]]=x; } else { int co=col[x]; int l=a[co].v.size(); c[a[co].v[((rk[x]-n+m-1)%l+l)%l]]=x; } } void work2(int x,int y) { if(vis[x]) return; if(rk[m]\u0026gt;=y) c[a[1].v[rk[m]-y]]=x; } signed main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;q); for(int i=1;i\u0026lt;=m;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;p[i]),f[p[i]]=i; for(int i=0;i\u0026lt;=m;i++) if(!col[i]) dfs(i,++tot); if(len\u0026lt;n-m+1) { for(int i=1;i\u0026lt;=len;i++) ans[++cnt]=b[i]; for(int i=1;i\u0026lt;=n-m+1-len;i++) ans[++cnt]=m+i,vis[m+i]=1; } else for(int i=1;i\u0026lt;=n-m+1;i++) ans[++cnt]=b[i]; for(int i=1;i\u0026lt;=m;i++) work1(i); for(int i=m+1,j=n-m;i\u0026lt;=n;i++,j--) work2(i,j); for(int i=1;i\u0026lt;m;i++) ans[++cnt]=c[i]; while(q--) { int x; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;x); printf(\u0026#34;%lld\\n\u0026#34;,ans[n-x+1]); } return 0; } ","date":"2023-07-29T11:42:00+08:00","permalink":"https://werchange.github.io/p/usaco13dec-the-bessie-shuffle-s-%E6%B4%97%E7%89%8C-%E9%A2%98%E8%A7%A3/","title":"[USACO13DEC] The Bessie Shuffle S 洗牌 题解"},{"content":"07.12\u0026amp;07.14模拟赛总结\r前言：\n这是最戏剧性的一集，两场都是同级第一，只不过一场正数、一场倒数。\n07.12——Day 1\rT1\rP8093 [USACO22JAN] Searching for Soulmates S\n正解\r以下除以 $2$ 操作、加 $1$ 操作、乘以 $2$ 操作分别为操作 1、2、3。\n思考发现，如果我们先前一直进行操作 1 和操作 2，那等到我们再进行操作 3 时，就不会再进行操作 1，（因为不会更优）。\n换句话说，我们操作的步骤大约分为两个部分：\n前半段：进行操作 1、2 后半段：进行操作 2、3 容易想到处理出前后半段中间的一个中间值 $t$。\n由于后半段的操作不是乘以 $2$ 就是加 $1$，所以这个 $t$ 一定是 $b$ 的前缀（二进制中）。\n那就很清晰了，直接枚举 $t$，在记录步数即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int d(int x) { for (int i = 63; i \u0026gt;= 0; --i) if (x \u0026gt;\u0026gt; i) return i + 1; return 0; } int get(int num, int x, int len) { return num \u0026gt;\u0026gt; (len - x); } void solve() { int a, b; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b); if (a == b) { puts(\u0026#34;0\u0026#34;); return; } int len = d(b); int ans = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= len; i++) { int cnt = 0; int t = get(b, i, len); int ta = a; while (ta != t) { if (ta \u0026gt; t) { if (ta \u0026amp; 1) ++ta; else ta /= 2; ++cnt; } else { cnt += t - ta; ta = t; } } for (int j = i + 1; j \u0026lt;= len; j++) { t = get(b, j, len); ta \u0026lt;\u0026lt;= 1; ++cnt; if (t != ta) ++ta, ++cnt; } ans = min(ans, cnt); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } signed main() { int n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n--) solve(); return 0; } T2\rP8094 [USACO22JAN] Cow Frisbee S\n正解\r直接枚举、用栈维护即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 3e5 + 5; int n, ans; int h[MAXN], x[MAXN]; stack\u0026lt;int\u0026gt; s; signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;h[i]), x[h[i]] = i; for (int i = 1; i \u0026lt;= n; i++) { while (!s.empty()) { int t = s.top(); ans += abs(x[h[i]] - x[t]) + 1; if (h[i] \u0026lt;= t) break; s.pop(); } s.push(h[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP8095 [USACO22JAN] Cereal 2 S 正解\r对于这道题，一眼二分图最大匹配，直接匈牙利带走。\n结果发现 $\\Omicron(nm)$ 把匈牙利带走。\n但是没有关系！直接建超级源点和超级汇点，dinic 网络流直接 $\\Omicron(\\sqrt{n}m)$ 带走。\n但是，这样非常难打，而且在输出排队顺序是也异常繁琐，可以说是拿考场时间换代码运行时间了……\n怎么办呢？还好这场比赛这道题最难，所以应该没有人会 A，打点部分分也是不错的选择【大拇指d(￣▽￣)b】。\n实际上这道题数据很水，匈牙利+卡常+优秀的代码逻辑是可以 A 的。\n至于输出方案，这个想想就出来了，这里不做过多赘述。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN = 2e6 + 5; int n, m; int a[MAXN]; int f[MAXN], s[MAXN]; int lk[MAXN], ilk[MAXN]; bool vis[MAXN]; vector\u0026lt;int\u0026gt; v[MAXN], vec[MAXN]; bool dfs(int x) { for (auto i : v[x]) { if (!vis[i]) { vis[i] = 1; if (!lk[i] || dfs(lk[i])) { lk[i] = x, ilk[x] = i; vis[i] = 0; return 1; } } } return 0; } int MXMC() { int re = 0; for (int i = 1; i \u0026lt;= n; i++) re += dfs(i); return re; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;f[i], \u0026amp;s[i]); v[i].pb(f[i]), v[i].pb(s[i]); vec[f[i]].pb(i); } int ans = MXMC(); printf(\u0026#34;%lld\\n\u0026#34;, n - ans); queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { if (ilk[i] != f[i]) continue; printf(\u0026#34;%lld\\n\u0026#34;, i); for (auto j : vec[f[i]]) { if (ilk[j] == s[j]) q.push(j); } } while (!q.empty()) { int u = q.front(); q.pop(); printf(\u0026#34;%lld\\n\u0026#34;, u); for (int j : vec[s[u]]) { if (ilk[j] == s[j]) q.push(j); } } for (int i = 1; i \u0026lt;= n; i++) if (!ilk[i]) printf(\u0026#34;%lld\\n\u0026#34;, i); return 0; } 总结\r$8+27+7=42/rk12$ 同级倒一、直接趋势。\n总结发现是答题时心态没有调整好，导致陷入思维怪圈，进一步导致简单题做不对、难题不会做的情况。\n07.13——Day 2\r原题检测，没打比赛。\n一早上复习，复习了上一周打过的模拟赛。幸好我都写了总结、方便复习。\n结果：\n我：（开始啦开始啦！）咦？这个“旅行商简化版”是个什么东西？\n隔壁的新初一：好像是我们作业里的一道题。\n隔壁同级：教练，这个我们要做吗？\n教练：新初三的也要做，注意一下啊。\n新初三的我们：……\n顺提，我们原题检测里的题，一题没A跑2圈……\n但成绩挺可观的：\n$100+100+52+100+71+0=423/rk2$\n好吧，跑6圈。遗憾的是期望得到 $500$ 分，可惜有两题打挂了……\n07.14——Day 3\rT1\rP9186 [USACO23OPEN] Milk Sum S\n正解\r容易想到肯定先排序嘛，那么就会得到新数组。\n发现用二分找到查询数据在新数组位置时，答案的增加与减少可以用一个后缀和来搞定。（当然，前缀和应该没问题，可是赛时我先想到了后缀和）。\n那就很容易做了，二分可以写 lower_bound，减少码量。因为近期用 set 用得比较多，所以我就干脆丢进了 set 里进行 lower_bound 操作。\n代码\r好不容易第一次赛时切绿，这里放一下我的赛时代码（无格式化、码风为本人码风）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=2e5+5,INF=1e9; int n,ans; struct node { int x,id; bool operator\u0026lt;(const node \u0026amp;T)const { if(x!=T.x) return x\u0026lt;T.x; return id\u0026lt;T.id; } }a[MAXN],b[MAXN]; int sum[MAXN]; multiset\u0026lt;node\u0026gt; s; signed main() { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i].x); b[i].x=a[i].x; b[i].id=i; } sort(a+1,a+n+1); for(int i=n;i\u0026gt;=1;i--) { ans+=a[i].x*i; sum[i]=sum[i+1]+a[i].x; a[i].id=i; s.insert(a[i]); } s.insert({-1,0}),s.insert({INF,0}); int tmp=ans,Q; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;Q); while(Q--) { ans=tmp; int x,y; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y); auto it=s.lower_bound({b[x].x,0}); node t=*it; ans-=t.x*t.id; auto it2=s.upper_bound({y,0}); node t2=*it2; if(t2.x==INF) { ans-=sum[t.id+1]; ans+=y*n; printf(\u0026#34;%lld\\n\u0026#34;,ans); continue; } if(t2.id==t.id) { ans+=y*t.id; printf(\u0026#34;%lld\\n\u0026#34;,ans); continue; } if(t2.id\u0026lt;t.id) { ans+=sum[t2.id]-sum[t.id]; ans+=y*t2.id; } else { ans+=y*(t2.id-1); ans-=sum[t.id+1]-sum[t2.id]; } printf(\u0026#34;%lld\\n\u0026#34;,ans); } return 0; } T2\rP9187 [USACO23OPEN] Field Day S\n正解\r这个一看就是可以转成二进制，比较就是异或操作了。\n这是个很好的思路，如果赛时没想到的话那就是能力问题了。\n因为他要求找最大不同，那脑海中可以有这样的思路： $$\r最大不同\\to 最小相同\\to 可以对其一取反\\to 最小不同\r$$ 那就很容易了，我们可以用一个非常简单的dp实现：\n设 $f_i$ 为得到 $i$ 的最小不同，最后输出答案时就是 $$\rc-f_{(2^c-1) \\oplus a_i}\r$$ 怎么转移呢？预处理一下就好了\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 1e6 + 5; int n, c; int a[MAXN]; int f[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;c, \u0026amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= c; j++) { char ch; cin \u0026gt;\u0026gt; ch; a[i] \u0026lt;\u0026lt;= 1; a[i] += (ch == \u0026#39;G\u0026#39;); } f[a[i]] = 0; } for (int j = 1; j \u0026lt;= c; j++) { for (int i = 1; i \u0026lt;= (1 \u0026lt;\u0026lt; c) - 1; i++) f[(1 \u0026lt;\u0026lt; (j - 1)) ^ i] = min(f[(1 \u0026lt;\u0026lt; (j - 1)) ^ i], f[i] + 1); } for (int i = 1; i \u0026lt;= n; i++) { int ans = c - f[((1 \u0026lt;\u0026lt; c) - 1) ^ a[i]]; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } T3\rP9188 [USACO23OPEN] Pareidolia S\n正解\r考虑DP。\n设 $f_i$ 为这样一个 $[1,i]$ 的区间出现 bessie 的个数。\n怎么转移呢？可以利用一下辅助数组 $lst_i$，其中 $i\\in [1,6]$。\n这是什么？\n如果出现了一个序列 bessie，那第 $i$ 位前面的 bessie 的起始位（b 的位置）\n例如 bessie，那么 $lst_i=1 ; (1\\leq i\\leq 6)$\n那么考虑转移 $f$：\n提供贡献的只有：\n前面的转移过来 当前贡献了多少 1 情况怎么处理呢？显然是 $f_{lst_6-1}$\n2 情况呢？因为当前 bessie 的出现，所以对于 $[l,lst_6] ; (l\\in [1,lst_6])$ 这些区间，答案都会 +1，所以转移量就是 $lst_6$\n综上， $$\rf_i=f_{lst_6-1}+lst_6\r$$ 因为答案是所有区间，所以答案就为: $$\r\\sum_{i=1}^n f_i\r$$ 代码\r有些许改动：\n（$dp_i \\to f_i$）\n（$f_i \\to lst_i$）\n括号里左边为代码变量，右边为思路变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; #define int long long const int MAXN = 3e5 + 5; char s[MAXN]; int f[10],dp[MAXN]; signed main() { scanf(\u0026#34;%s\u0026#34;,s+1); int n=strlen(s+1); // bessie for(int i=1;i\u0026lt;=n;i++) { if(s[i]==\u0026#39;b\u0026#39;) f[1]=i; if(s[i]==\u0026#39;e\u0026#39;) f[6]=f[5],f[2]=f[1]; if(s[i]==\u0026#39;s\u0026#39;) f[4]=f[3],f[3]=f[2]; if(s[i]==\u0026#39;i\u0026#39;) f[5]=f[4]; dp[i]=dp[f[6]-1]+f[6]; } int ans=0; for(int i=1;i\u0026lt;=n;i++) ans+=dp[i]; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } 总结\r$100+25+17=142/rk1$\n这次 $rk1$ 不只是同级，还是同机房。\n再接再厉。\n","date":"2023-07-19T20:04:00+08:00","permalink":"https://werchange.github.io/p/07.1207.14%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"07.12\u002607.14模拟赛总结"},{"content":"07.06\u0026amp;07.11模拟赛总结\r前言：\n之前学了些新东西，所以只比了两场模拟赛，一场 Atcoder，一场 USACO。\n改完题了，趁有空总结一下。\n07.06——Day 1\rT1\r[ABC218D] Rectangles 正解\r对于每个点，都令他是矩形中左下角的点。我们可以用数组把这个点同横坐标的点都存下来，纵坐标同理。那么再判断右上角那个点是否存在即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; #define pii pair\u0026lt;int, int\u0026gt; #define ft first #define sd second #define pb push_back const int MAXN = 2e3 + 5; int n; pii a[MAXN]; map\u0026lt;int, map\u0026lt;int, bool\u0026gt;\u0026gt; vis; int cnt; vector\u0026lt;int\u0026gt; fx[MAXN]; vector\u0026lt;int\u0026gt; fy[MAXN]; bool cmp(pii aa, pii bb) { if (aa.ft != bb.ft) return aa.ft \u0026lt; bb.ft; return aa.sd \u0026lt; bb.sd; } signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); a[i] = { x, y }; vis[x][y] = 1; } sort(a + 1, a + n + 1, cmp); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = i + 1; j \u0026lt;= n; ++j) { if (a[i].ft == a[j].ft) fx[i].pb(j); if (a[i].sd == a[j].sd) fy[i].pb(j); } } for (int i = 1; i \u0026lt;= n; ++i) { for (auto i1 : fx[i]) { for (auto i2 : fy[i]) { if (vis[a[i2].ft][a[i1].sd]) ++cnt; } } } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } T2\r[ABC218E] Destruction 正解\r直接 kruskal 带走。对于负权边我们也不需要，所以也计算一下花费。\n考场忘记 kruskal 怎么打了，直接趋势\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5, INF = 0x3f3f3f3f; int n, m, tot, ans; struct edge { int u, v, w; bool operator\u0026lt;(const edge \u0026amp;t) const { return w \u0026lt; t.w; } } e[MAXN]; int fa[MAXN]; int tp[MAXN], hea; bool vis[MAXN \u0026lt;\u0026lt; 1]; inline int rd() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } inline int max(int a, int b) { return a \u0026gt; b ? a : b; } int gfa(int x) { return x == fa[x] ? x : gfa(fa[x]); } int kru() { int val = 0; for (int i = 1; i \u0026lt;= m; ++i) { int rx = gfa(e[i].u), ry = gfa(e[i].v); if (e[i].w \u0026lt; 0) { val += e[i].w; if (rx \u0026lt; ry) fa[ry] = rx; else fa[rx] = ry; } else if (rx == ry) continue; else { if (rx \u0026lt; ry) fa[ry] = rx; else fa[rx] = ry; val += e[i].w; } } return val; } signed main() { n = rd(), m = rd(); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; for (int i = 1; i \u0026lt;= m; ++i) { int u = rd(), v = rd(), w = rd(); e[i] = { u, v, w }; tot += w; } sort(e + 1, e + m + 1); ans = tot - kru(); write(max(ans, 0ll)); putchar(\u0026#39;\\n\u0026#39;); return 0; } T3\r[ABC218F] Blocked Roads 正解\r可以跑一遍堆优化 Dijkstra，然后找出最短路径（主干路径），对于删掉的边，判断是否为主干路径。如果不是，那对最优答案无影响；否则再跑一遍。\n时间复杂度可以证明。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #define int long long const int MAXN = 400 + 5, MAXM = 2e5 + 5, INF = 0x3f3f3f3f3f3f3f3f; int n, m; int su, en[MAXM], lt[MAXM], hd[MAXN]; int dis[MAXN]; bool viz[MAXM], vis[MAXN]; int nxt[MAXN][2]; bool isok[MAXM]; struct node { int ix, vl; bool operator\u0026gt;(const node \u0026amp;t) const { if (vl != t.vl) return vl \u0026gt; t.vl; return ix \u0026lt; t.ix; } }; inline int rd() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } inline void add(int u, int v) { en[++su] = v, lt[su] = hd[u], hd[u] = su; } inline int Dij(int x) { priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= m; ++i) viz[i] = (i == x) ? 1 : 0; for (int i = 1; i \u0026lt;= n; ++i) vis[i] = 0, dis[i] = INF; q.push({ 1, 0 }); vis[1] = 1; dis[1] = 0; while (!q.empty()) { int u = q.top().ix; q.pop(); for (int i = hd[u]; i; i = lt[i]) { if (viz[i]) continue; int v = en[i]; if (dis[v] \u0026gt; dis[u] + 1) { nxt[v][0] = u, nxt[v][1] = i; dis[v] = dis[u] + 1; if (!vis[v]) vis[v] = 1, q.push({ v, dis[v] }); } } } return dis[n]; } signed main() { n = rd(), m = rd(); for (int i = 1; i \u0026lt;= m; ++i) { int u = rd(), v = rd(); add(u, v); } int Max = Dij(0); Max = (Max == INF) ? -1 : Max; int tmp = n; while (tmp != 0) { isok[nxt[tmp][1]] = 1; tmp = nxt[tmp][0]; } for (int x = 1, ans; x \u0026lt;= m; ++x) { if (isok[x]) { ans = Dij(x); if (ans == INF) ans = -1; } else ans = Max; write(ans), putchar(\u0026#39;\\n\u0026#39;); } return 0; } T4\r[ABC218G] Game on Tree 2\n正解\r你以为是博弈论，然后开始推 SG，其实并没有什么 SG 函数。\n因为两人的目标不同，所以对待选择儿子节点时，一个人要最大、另一个人要最小。可以考虑 DP。 仔细想想，发现两人是回合制的，所以对待不同的人操作，有不同的转移方程。\n选最大的人： $$\rf_i=max\\{ f_j \\}\r$$ 选最小的人： $$\rf_i=min\\{f_j\\}\r$$ 其中 $j$ 为 $i$ 的儿子节点。\n如何维护中位数呢？方法很多，上至平衡树、下至对顶堆，甚至平板电视。这里给出两个 multiset 维护的办法。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define pb push_back const int MAXN = 2e5 + 5, INF = 0x3f3f3f3f; int n; int a[MAXN], f[MAXN]; vector\u0026lt;int\u0026gt; G[MAXN]; struct node { multiset\u0026lt;int\u0026gt; s, t; void update() { if (s.size()) { auto it = s.end(); --it; t.insert(*it), s.erase(it); } while (s.size() \u0026lt; t.size()) { auto it = t.begin(); s.insert(*it), t.erase(it); } } void ins(int x) { s.insert(x); update(); } void era(int x) { auto it = s.end(); --it; if (x \u0026lt;= *it) s.erase(s.lower_bound(x)); else t.erase(t.lower_bound(x)); update(); } int query() { auto it = s.end(); --it; if (s.size() \u0026gt; t.size()) return *it; return ((*it) + (*t.begin())) / 2; } } S; void dfs(int x, int fa, int dep) { S.ins(a[x]); bool isok = 0; int minz = INF, maxz = 0; for (auto y : G[x]) { if (y == fa) continue; isok = 1; dfs(y, x, dep + 1); minz = min(minz, f[y]); maxz = max(maxz, f[y]); } if (!isok) f[x] = S.query(); else { if (dep \u0026amp; 1) f[x] = maxz; else f[x] = minz; } S.era(a[x]); } signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].pb(v), G[v].pb(u); } dfs(1, 1, 1); printf(\u0026#34;%d\\n\u0026#34;, f[1]); return 0; } 总结\r174pts/rk11（同级倒数第二）\n怎么说呢，本来应该 300pts 是没问题的。可是 T2 被 kruskal 卡住了，一直在回忆。以至于没有深入思考T3。\n这告诉我们，学过的算法知识一定要复习！！\n07.11——Day 2\rT1\rP7990 [USACO21DEC] Closest Cow Wins S\n正解\r有感：其实这道题是最难的（蓝）。结果考场死磕这道题，以至于T3（黄）都没仔细想。\n解法1\r因为有 $m$ 个敌对奶牛，所以道路被分成了 $m+1$ 个部分。因为我们放奶牛可以放在小数位上而敌对奶牛不行、且敌对奶牛不和草场重合。\n所以对于每个部分，我们都只需要两只奶牛就可以将这个部分所有草场的美味度“包揽”。\n那如果只是一只奶牛呢？\n显然，有一些草场就无法“包揽”。如果我们在这个范围 $(f_{i-1},f_i)$ 内随便找一个点 $q$ 来放置奶牛，那这只奶牛可以“包揽”的草场只有 $(\\frac{f_{i-1}+q}{2},\\frac{q+f_i}{2})$ 范围内的草场。\n但是我们发现，如果我们进行一下 $r-l$ 的操作，可得 $\\frac{f_i-f_{i-1}}{2}$。所以这个范围的长度与奶牛放置点无关。\n可以想到什么？一个区间且长度没有变换……\n滑动窗口！！\n正确的。但是我写了解法2，并且考场也想到了解法 2，只是打挂了。\n解法2\r对于每个草场，左边或右边肯定有一个敌对奶牛，那么我们以草场为圆心求出一个最大半径，使得这个范围内没有敌对奶牛。\n那就很容易了，可以得到类似于一条条的线段。将有重合部分的变为同一块“草场”。然后排下序就可以输出了。\n代码\r此处为解法 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN = 2e5 + 5; int n, m, k; struct node { int p, t; bool operator\u0026lt;(const node \u0026amp;A) const { return p \u0026lt; A.p; } } a[MAXN]; int f[MAXN]; int d[MAXN]; vector\u0026lt;node\u0026gt; ans; bool cmp(node a, node b) { if (a.t != b.t) return a.t \u0026gt; b.t; return a.p \u0026lt; b.p; } signed main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;k, \u0026amp;m, \u0026amp;n); for (int i = 1; i \u0026lt;= k; i++) { int p, t; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;p, \u0026amp;t); a[i] = { p, t }; } for (int i = 1; i \u0026lt;= m; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;f[i]); sort(f + 1, f + m + 1); sort(a + 1, a + k + 1); memset(d, 0x3f, sizeof(d)); for (int i = 1; i \u0026lt;= k; i++) { int it = lower_bound(f + 1, f + m + 1, a[i].p) - f; if (it != m + 1) d[i] = min(d[i], f[it] - a[i].p); if (it != 1) d[i] = min(d[i], a[i].p - f[it - 1]); } ans.pb({ a[1].p + d[1] - 1, a[1].t }); for (int i = 2; i \u0026lt;= k; i++) { if (a[i].p - d[i] \u0026lt; ans.back().p) { node tmp = ans.back(); ans.pop_back(); ans.pb({ tmp.p, tmp.t + a[i].t }); } else ans.pb({ a[i].p + d[i] - 1, a[i].t }); } sort(ans.begin(), ans.end(), cmp); int cnt = 0; for (int i = 0; i \u0026lt; n; i++) cnt += ans[i].t; printf(\u0026#34;%lld\\n\u0026#34;, cnt); return 0; } T2\r题目描述\rFarmer John 的农场由 $N$ 块田地（$1 \\leq N \\leq 10^5$）组成，编号为 $1 \\ldots N$。在这些田地之间有 $M$ 条双向道路（$0 \\leq M \\leq 10^5$），每条道路连接两块田地。\n农场有两个牛棚，一个在田地 1 中，另一个在田地 $N$ 中。Farmer John 希望确保有一种方式可以沿着一组道路在两个牛棚之间行走。 他愿意建造至多两条新道路来实现这一目标。由于田地的位置因素，在田地 $i$ 和 $j$ 之间建造新道路的花费是 $(i-j)^2$。\n请帮助 Farmer John 求出使得牛棚 $1$ 和 $N$ 可以相互到达所需要的最小花费。\n输入格式\r每个测试用例的输入包含 $T$ 个子测试用例（$1\\le T\\le 20$），所有子测试用例必须全部回答正确才能通过整个测试用例。\n输入的第一行包含 $T$，之后是 $T$ 个子测试用例。\n每个子测试用例的第一行包含两个整数 $N$ 和 $M$。以下 $M$ 行，每行包含两个整数 $i$ 和 $j$，表示一条连接两个不同田地 $i$ 和 $j$ 的道路。输入保证任何两个田地之间至多只有一条道路，并且所有子测试用例的 $N+M$ 之和不超过 $5 \\cdot 10^5$。\n输出格式\r输出 $T$ 行。第 $i$ 行包含一个整数，为第 $i$ 个子测试用例的最小花费。\n样例输入 #1\r1 2 3 4 5 6 7 8 2 5 2 1 2 4 5 5 3 1 2 2 3 4 5 样例输出 #1\r1 2 2 1 正解\r因为只会最多建 $2$ 条边，所以我们有两种方法：\n直接连接 $1$ 所在连通块与 $n$ 所在连通块，只需连 $1$ 条边 通过一个“媒介”连通块来使得 $1$ 与 $n$ 连通，需要连 $2$ 条边 那通过并查集可以搞定连通块，通过 set 的二分找出边权尽可能小的。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define int long long #define po(x) ((x) * (x)) const int MAXN = 5e5 + 5, INF = 1e14; int T, n, m; int fa[MAXN]; set\u0026lt;int\u0026gt; s1, s2; int a[MAXN], b[MAXN]; int gf(int x) { return x == fa[x] ? x : gf(fa[x]); } void un(int u, int v) { int rx = gf(u), ry = gf(v); if (rx \u0026gt; ry) fa[rx] = ry; else fa[ry] = rx; } bool cmp(int x, int y) { int rx = gf(x), ry = gf(y); if (rx != ry) return rx \u0026lt; ry; return x \u0026lt; y; } void solve() { int ans = INF; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; for (int i = 1; i \u0026lt;= m; i++) { int u, v; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;u, \u0026amp;v); un(u, v); } int r1 = gf(1), rn = gf(n); if (r1 == rn) { puts(\u0026#34;0\u0026#34;); return; } s1.clear(), s2.clear(); int tmp = 0, cnt = 0; s1.insert(0), s1.insert(n + 1); s2.insert(0), s2.insert(n + 1); for (int i = 1; i \u0026lt;= n; i++) { int rt = gf(i); if (rt == r1) s1.insert(i); else if (rt == rn) b[++cnt] = i, s2.insert(i); else a[++tmp] = i; } for (int i = 1; i \u0026lt;= cnt; i++) { int v = b[i]; auto it1 = s1.lower_bound(v); --it1; auto it2 = s1.upper_bound(v); int t1 = (*it1), t2 = (*it2); if (t1 != 0) ans = min(ans, po(v - t1)); if (t2 != n + 1) ans = min(ans, po(v - t2)); } sort(a + 1, a + tmp + 1, cmp); int min1 = INF, min2 = INF; for (int i = 1; i \u0026lt;= tmp; i++) { if (i \u0026gt; 1 \u0026amp;\u0026amp; gf(a[i]) != gf(a[i - 1])) { ans = min(ans, min1 + min2); min1 = min2 = INF; } auto it1 = s1.lower_bound(a[i]); --it1; auto it2 = s1.upper_bound(a[i]); int t1 = (*it1), t2 = (*it2); if (t1 != 0) min1 = min(min1, po(a[i] - t1)); if (t2 != n + 1) min1 = min(min1, po(a[i] - t2)); it1 = s2.lower_bound(a[i]); --it1; it2 = s2.upper_bound(a[i]); t1 = (*it1), t2 = (*it2); if (t1 != 0) min2 = min(min2, po(a[i] - t1)); if (t2 != n + 1) min2 = min(min2, po(a[i] - t2)); } ans = min(ans, min1 + min2); printf(\u0026#34;%lld\\n\u0026#34;, ans); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } T3\rP7992 [USACO21DEC] Convoluted Intervals S\n正解\r用到了差分。\n发现 $m$ 老小了，那就思考从这方面做文章。\n我们发现，这个一组 $i$ 与一组 $j$ 可以给出贡献为 $a_i\\times a_j$，$a[i]$为桶，统计起点 $i$ 出现了几遍。\n如果你打过 25pts 部分分的暴力的话，你就明白为什么要用差分。这里不展开了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5; int n, m; int a[MAXN], b[MAXN]; int f[MAXN \u0026lt;\u0026lt; 1]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); a[x]++, b[y]++; } for (int i = 0; i \u0026lt;= m; i++) { for (int j = 0; j \u0026lt;= m; j++) { f[i + j] += a[i] * a[j]; f[i + j + 1] -= b[i] * b[j]; } } for (int i = 0, ans = 0; i \u0026lt;= m + m; i++) { ans += f[i]; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 总结\r124pts/rk6\n还不错，可是还不是我能到达的最大高度，这可能是个良好开端。\n总总结\r用日日新的态度来学竞赛，收获真的很大！\n借这次良好开端，下次“扶摇直上九万里”！\n怎么说AKCSP-J、CSP-S拿个一等吧\n","date":"2023-07-11T21:36:00+08:00","permalink":"https://werchange.github.io/p/07.0607.11%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"07.06\u002607.11模拟赛总结"},{"content":"2023.7月初模拟赛总结\r前言：\n近期（约）3天比了3场模拟赛，都源于USACO。但是这3场我的成绩都很低，赛后一看题解被自己的智商哭死，实在看不下去了，决定要写一篇总结\nDay 1\rT1\rP3132 [USACO16JAN] Angry Cows G 正解\rDP，设 $f_i$ 为使第 $i$ 个干草堆左边的所有干草堆爆炸的最小力度。\n考虑转移方程。\n找一个 $j$，满足：\n$j\u0026lt;i$ $a_i-a_j\u0026gt;f_j+1$ 会有很多个 $j$，我们需要最后一个，即最靠近 $i$ 的那一个。\n易得： $$\rf_i=min(a_i-a_j,f_{j+1}+1)\r$$ 其中 $f_1=0$\n类似的，我们可得使右边的爆炸的 $g[]$ 的状态转移方程。\n最后我们枚举爆炸点，显然： $$\rans=min\\{max(\\frac{a_j-a_i}{2},max(f_i,g_j)+1) \\}\r$$ 其中，$i$ 和 $j$ 的互相推进用到了贪心策略。\n还有一点，因为最优情况爆炸点只可能在整点或两个整点中间，所以为了避免double精度问题，我们可以都乘以一个 $2$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 5e4 + 5, INF = 0x3f3f3f3f; ll n; ll f[MAXN], g[MAXN]; ll a[MAXN]; int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]), a[i] *= 2; sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); ll t = 1; f[1] = 0; rp(i, 2, n) { while (t + 1 \u0026lt; i \u0026amp;\u0026amp; a[i] - a[t + 1] \u0026gt; f[t + 1] + 2) ++t; f[i] = min(a[i] - a[t], f[t + 1] + 2); } t = n; g[n] = 0; pr(i, n - 1, 1) { while (t - 1 \u0026gt; i \u0026amp;\u0026amp; a[t - 1] - a[i] \u0026gt; g[t - 1] + 2) --t; g[i] = min(a[t] - a[i], g[t - 1] + 2); } ll ans = INF; for (ll i = 1, j = n; i \u0026lt; j;) { ans = min(ans, max((a[j] - a[i]) / 2, max(f[i], g[j]) + 2)); if (f[i + 1] \u0026lt; g[j - 1]) ++i; else --j; } printf(\u0026#34;%.1lf\u0026#34;, (double)ans / 2); return 0; } T2\rP3133 [USACO16JAN] Radio Contact G 正解\rdp,设 $f_{i,j}$ 为在 $(i,j)$ 时最小代价。对于他们的行动串，分别用两个递推数组储存他们的横坐标与纵坐标。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define po(x) ((x) * (x)) const ll MAXN = 1e3 + 5; ll n, m; ll fx, fy, cx, cy; ll f[MAXN][MAXN]; ll ax[MAXN], bx[MAXN], ay[MAXN], by[MAXN]; ll d(ll i, ll j) { return po(fx + ax[i] - (cx + bx[j])) + po(fy + ay[i] - (cy + by[j])); } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;fx, \u0026amp;fy, \u0026amp;cx, \u0026amp;cy); rp(i, 1, n) { char ch; cin \u0026gt;\u0026gt; ch; ax[i] = ax[i - 1], ay[i] = ay[i - 1]; if (ch == \u0026#39;N\u0026#39;) ay[i]++; if (ch == \u0026#39;S\u0026#39;) ay[i]--; if (ch == \u0026#39;W\u0026#39;) ax[i]--; if (ch == \u0026#39;E\u0026#39;) ax[i]++; } rp(i, 1, m) { char ch; cin \u0026gt;\u0026gt; ch; bx[i] = bx[i - 1], by[i] = by[i - 1]; if (ch == \u0026#39;N\u0026#39;) by[i]++; if (ch == \u0026#39;S\u0026#39;) by[i]--; if (ch == \u0026#39;W\u0026#39;) bx[i]--; if (ch == \u0026#39;E\u0026#39;) bx[i]++; } memset(f, 0x3f, sizeof(f)); f[0][0] = 0; rp(i, 0, n) { rp(j, 0, m) { if (i != 0) f[i][j] = min(f[i][j], f[i - 1][j] + d(i, j)); if (j != 0) f[i][j] = min(f[i][j], f[i][j - 1] + d(i, j)); if (i != 0 \u0026amp;\u0026amp; j != 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + d(i, j)); } } printf(\u0026#34;%lld\\n\u0026#34;, f[n][m]); return 0; } T3\rP3134 [USACO16JAN] Lights Out G\n正解\r按照题意所说，枚举每个点出发的情况。再把路径记录下来，看看这条路径是否唯一。若唯一，则“觉醒”。\n我们可以用map储存，路径可以压成 string。\n其中对于路径储存问题，我们需要知道这条边的长度与这个角的角度。由于这里的角度不是 270° 就是 90°，所以判断旋转方向即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 200 + 5; ll n; struct node { ll x, y; } a[MAXN]; map\u0026lt;string, ll\u0026gt; ma; ll ans; ll len[MAXN], dis[MAXN]; string ang[MAXN], ls[MAXN]; bool got(ll i, ll j, ll k) { bool op; if (a[i].x == a[j].x) { if (a[j].y \u0026gt; a[i].y) { if (a[k].x \u0026gt; a[j].x) op = 1; else op = 0; } else { if (a[k].x \u0026gt; a[j].x) op = 0; else op = 1; } } else { if (a[j].x \u0026gt; a[i].x) { if (a[k].y \u0026gt; a[j].y) op = 0; else op = 1; } else { if (a[k].y \u0026gt; a[j].y) op = 1; else op = 0; } } return op; } inline string work(ll x) { string s; ll a[10], hd = 0; while (x) { a[++hd] = x % 10; x /= 10; } pr(i, hd, 1) s += a[i] + 48; return s; } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].y); rp(i, 1, n) { ll i0 = i - 1, i1 = i + 1; if (i0 \u0026lt; 1) i0 = n - i0; if (i1 \u0026gt; n) i1 = i1 - n; ang[i] = got(i0, i, i1) ? \u0026#34;A\u0026#34; : \u0026#34;B\u0026#34;; len[i] = abs(a[i0].x - a[i].x) + abs(a[i0].y - a[i].y); } rp(i, 1, n) { ls[i] = work(len[i]); ll t1 = len[1], t2 = len[2]; if (i == 1) continue; rp(j, i + 1, n) t1 += len[j]; pr(j, i - 1, 2) t2 += len[j + 1]; dis[i] = min(t1, t2); } rp(i, 2, n) { string s; s += ang[i]; ma[s]++; rp(j, i + 1, n) { s = s + ls[j] + ang[j]; ma[s]++; } } rp(i, 2, n) { ll now = -1; string s; s += ang[i]; if (ma[s] == 1) continue; ll sum = 0; rp(j, i + 1, n) { s = s + ls[j] + ang[j]; sum += len[j]; if (ma[s] == 1) { now = j; break; } } if (now == -1) ans = max(ans, sum + len[1] - dis[i]); else ans = max(ans, dis[now] + sum - dis[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 总结\r同年级rk12，倒数第一……\n其实题都不难，可能是脑子抽了……\nDay 2\rT1\rP8901 [USACO22DEC] Circular Barn S\n正解\r这是巴什博奕。\n上来先筛一遍质数，欧拉筛 $O(n)$ 搞定。\n经过打表找规律会发现一个房间内只要是对于 $4$ 的倍数，则先手必输。（可以证明，但这里不展开了）\n对于先手而言，肯定自己占优时希望能快则快、占劣时能拖则拖。\n所以我们记录一下轮数（两人都进行一次操作称为一轮）。\n如果是 $4$ 的倍数，两人最优策略都只能不停出 $2$，所以我们这一个房间结束时，经历了 $i/4+1$ 轮。\n如果不是，那先手可以取走一个数使得剩下的数右边为 $4$ 的倍数。记录一下 $i \\mod 4$ 最大数 $i$。\n那么怎么知道答案呢？记录先手获胜时最小轮数 $min_1$ 与这个房间号 $pos_1$，后手同理。\n然后比较 $min_1$ 与 $min_2$ 的大小，谁更小，意味着谁更快赢得游戏。\n想等的话比较谁的房间号更小。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u0026lt;cstdio\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 2e5 + 5, MAXM = 5e6 + 5, INF = 0x7f7f7f7f; ll T, n; ll a[MAXN], pri[MAXM], pinum; bool ispr[MAXM]; ll s[4]; ll ans[MAXM]; inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } inline void write(ll x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } void getprime(ll n) { ans[1] = 1; s[1] = 1; for (ll i = 2; i \u0026lt;= n; ++i) { if (!ispr[i]) { pri[++pinum] = i; if (i % 4) s[i % 4] = i; } for (ll j = 1; j \u0026lt;= pinum; ++j) { if (i * pri[j] \u0026gt; n) break; ispr[i * pri[j]] = 1; if (i % pri[j] == 0) break; } if (i % 4 == 0) ans[i] = i / 4 + 1; else ans[i] = (i - s[i % 4]) / 4 + 1; } } int main() { getprime(MAXM - 5); T = read(); while (T--) { n = read(); ll min1 = INF, pos1, min2 = INF, pos2; rp(i, 1, n) { a[i] = read(); if (a[i] % 4 == 0) { if (min2 \u0026gt; ans[a[i]]) { min2 = ans[a[i]]; pos2 = i; } } else { if (min1 \u0026gt; ans[a[i]]) { min1 = ans[a[i]]; pos1 = i; } } } if (min1 \u0026lt; min2) puts(\u0026#34;Farmer John\u0026#34;); else if (min1 \u0026gt; min2) puts(\u0026#34;Farmer Nhoj\u0026#34;); else { if (pos1 \u0026lt; pos2) puts(\u0026#34;Farmer John\u0026#34;); else puts(\u0026#34;Farmer Nhoj\u0026#34;); } } return 0; } T2\rP8903 [USACO22DEC] Bribing Friends G 正解\rdp，但是需要优化。\n$O(n^3)$ 的朴素dp这里不说了，直接说正解。\n设 $f_{i,j}$ 为遍历了前 $i$ 个人，花了 $j$ 个雪糕可以得到的最大利润。\n设 $g_{i,j}$ 为花了 $j$ 元的最大利润。\n然后我们枚举在哪一个人身上既花雪糕又花钱。\n这显然可以证明只会有一个人既花雪糕又花钱，那他前面的就都用雪糕、后面的就都用钱来支付。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 2e3 + 5; ll n, A, B; ll f[MAXN][MAXN]; ll g[MAXN][MAXN]; struct node { ll p, c, x, xc; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN]; int main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;A, \u0026amp;B); rp(i, 1, n) { ll x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); a[i] = { x, y, z, y * z }; } sort(a + 1, a + n + 1); rp(i, 1, n) { rp(j, 0, B) f[i][j] = f[i - 1][j]; pr(j, B, a[i].xc) f[i][j] = max(f[i][j], f[i - 1][j - a[i].xc] + a[i].p); } pr(i, n, 1) { rp(j, 0, A) g[i][j] = g[i + 1][j]; pr(j, A, a[i].c) g[i][j] = max(g[i][j], g[i + 1][j - a[i].c] + a[i].p); } ll ans = 0; rp(i, 1, n) { ans = max(ans, max(f[i - 1][B] + g[i][A], f[i][B] + g[i + 1][A])); for (ll j = 0; j \u0026lt;= min(A, a[i].c); ++j) { if (B \u0026lt; (a[i].c - j) * a[i].x) continue; ans = max(ans, f[i - 1][B - (a[i].c - j) * a[i].x] + g[i + 1][A - j] + a[i].p); } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP8904 [USACO22DEC] Mountains G\n正解\r暴力膜你模拟。\n我们每个山峰都建一个set，记录他右边能看到的山有哪些。\n在修改一座山 $x$ 的数据后，判断山 $x$ 会不会挡住山 $i$ 本来能看见的一些山。若挡住，则将山 $x$ 右边的山从 $s_i$ 中删掉。\n对于山 $x$ 本身，重构就好了。\n能互相看到的山的对数在这个过程中也可以统计出来。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define ins insert #define era erase #define upp upper_bound #define low lower_bound const ll MAXN = 2e3 + 5; ll n, ans; ll a[MAXN]; set\u0026lt;ll\u0026gt; s[MAXN]; double gotk(ll i, ll j) { return 1.0 * (a[j] - a[i]) / (j - i); } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); rp(i, 1, n) { s[i].ins(0), s[i].ins(n + 1); double k = -1e9; rp(j, i + 1, n) { if (gotk(i, j) \u0026gt;= k) { k = gotk(i, j); s[i].ins(j); ++ans; } } } ll Q; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;Q); while (Q--) { ll ix, h; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;ix, \u0026amp;h); a[ix] += h; rp(i, 1, ix - 1) { auto it = s[i].low(ix); it--; ll y = *it; if (y \u0026amp;\u0026amp; gotk(i, y) \u0026gt; gotk(i, ix)) continue; if (s[i].find(ix) == s[i].end()) s[i].ins(ix), ++ans; for (y = *s[i].upp(ix); y \u0026lt;= n; y = *(s[i].upp(y))) { if (gotk(i, y) \u0026gt;= gotk(i, ix)) break; s[i].era(y), --ans; } } ans -= s[ix].size() - 2; s[ix].ins(0), s[ix].ins(n + 1); double k = -1e9; rp(i, ix + 1, n) { if (gotk(ix, i) \u0026gt;= k) { k = gotk(ix, i); s[ix].ins(i); ++ans; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 总结\r同级rk5，但是大家都没打好，太难了，没有人A。\n可能是我这次比较走运。\nDay 3\r补题去了。\n顺便一提，一道绿题做了一天……\n其实还是很简单的，但是我的脑细胞却死了不少。。\n罪魁祸首：\nDay 4\rT1\rP3090 [USACO13NOV] Empty Stalls G 正解\r签到题，但是我没做出来。\n赛后看了题解，只要扫一遍就好了，注意要再扫一轮，以免一些特殊情况。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;set\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; #define int long long #define rp(i, o, p) for (int i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (int i = o; i \u0026gt;= p; --i) const int MAXN = 3e6 + 5, MAXK = 1e4 + 5; int n, k; int num[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); rp(i, 1, k) { int x, y, a, b; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;a, \u0026amp;b); rp(j, 1, y) { int t = a * j % n + b % n; t %= n; num[t] += x; } } rp(i, 0, n - 1) { if (num[i]) { num[(i + 1) % n] += num[i] - 1; num[i] = 1; } } if (num[0]) for (int i = 0; i \u0026lt; n; ++i) { if (num[i]) { num[(i + 1) % n] += num[i] - 1; num[i] = 1; } } rp(i, 0, n - 1) if (!num[i]) { printf(\u0026#34;%lld\\n\u0026#34;, i); break; } return 0; } T2\rP3088 [USACO13NOV] Crowded Cows S 正解\r又是签到题，可是我又傻了。\n单调队列维护最大值，然后判断即可。\n注意正反都做一遍，可以做到 $O(n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; #define int long long #define rp(i, o, p) for (int i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (int i = o; i \u0026gt;= p; --i) const int MAXN = 1e5 + 5; int n, d; struct node { int x, h; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN], q[MAXN]; bool l[MAXN], r[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;d); rp(i, 1, n) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].h); sort(a + 1, a + n + 1); int lf = 1, rg = 0; rp(i, 1, n) { while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[rg].h \u0026lt; a[i].h) --rg; q[++rg] = a[i]; while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[lf].x \u0026lt; a[i].x - d) ++lf; if (q[lf].h \u0026gt;= a[i].h * 2) l[i] = 1; } memset(q, 0, sizeof(q)); lf = 1, rg = 0; pr(i, n, 1) { while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[rg].h \u0026lt; a[i].h) --rg; q[++rg] = a[i]; while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[lf].x \u0026gt; a[i].x + d) ++lf; if (q[lf].h \u0026gt;= a[i].h * 2) r[i] = 1; } int ans = 0; rp(i, 1, n) if (l[i] \u0026amp;\u0026amp; r[i])++ ans; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP3089 [USACO13NOV] Pogo-Cow S\n正解\rdp，容易想到设 $f_{i,j}$ 为第 $i$ 点，从第 $j$ 点跳过来的最大分值。\n可得 $$\rf_{i,j}=f_{j,k}+p_i\r$$ 但是会爆。 若 $i\\to i-1$\n得 $$\rf_{i-1,j}=f_{j,k}+p_{i-1}\r$$ 结合一下，得 $$\rf_{i,j}=f_{i-1,j}-p_{i-1}+p_i\r$$ 好像没 $k$ 什么事了。\n我们思考一下，如果固定 $j$ 点，$i$ 点与 $k$ 点的变换类似于共同进行，所以我们可以在同一个循环中搞定。\n时间复杂度 $O(n^2)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 1e3 + 5; int n; struct node { int x, p; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN]; int ans; int f[MAXN][MAXN]; signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].p); sort(a + 1, a + n + 1); for (int j = 1; j \u0026lt;= n; ++j) { f[j][j] = a[j].p; int k = j + 1; for (int i = j + 1; i \u0026lt;= n; ++i) { f[i][j] = f[i - 1][j] - a[i - 1].p; while (k \u0026gt; 1 \u0026amp;\u0026amp; a[j].x - a[k - 1].x \u0026lt;= a[i].x - a[j].x) f[i][j] = max(f[i][j], f[j][--k]); f[i][j] += a[i].p; ans = max(ans, f[i][j]); } ans = max(ans, f[j][j]); } for (int j = n; j \u0026gt;= 1; --j) { f[j][j] = a[j].p; int k = j - 1; for (int i = j - 1; i \u0026gt;= 1; --i) { f[i][j] = f[i + 1][j] - a[i + 1].p; while (k \u0026lt; n \u0026amp;\u0026amp; a[k + 1].x - a[j].x \u0026lt;= a[j].x - a[i].x) f[i][j] = max(f[i][j], f[j][++k]); f[i][j] += a[i].p; ans = max(f[i][j], ans); } ans = max(ans, f[j][j]); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结\r同级倒数第一，有两个人AK……\n总总结\r“开动脑筋。”这是教练常说的话。\n确实，这个暑假如果不改变不勤思考的习惯，只会被淘汰。\n","date":"2023-07-07T07:27:00+08:00","permalink":"https://werchange.github.io/p/2023.7%E6%9C%88%E5%88%9D%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"2023.7月初模拟赛总结"},{"content":"二分图最大匹配\r前言：其实老早就学了，但是之前学的时候不透彻，稀里糊涂背背模板就过去了。果然，在最近一次原题检测上找到了我，然后就“暴毙”了。\n我就意识到学算法不能这么学，要摸清楚规律、掌握证明方法、思考推论过程。\n俗话说“温故而知新”，的确，我也在复习的过程中有了更透彻的理解。所以我决定写一篇笔记。\n本文有很多地方直接搬用了一些参考资料，所以本篇笔记原创部分主要为对关键部分进行解释。\n建议：草稿纸和笔永远是最好的工具。在看本文过程中，要仔细思考任何一部分，不要囫囵吞枣。\n注：本篇文章是我这个小蒟蒻写的，真正的dalao请看个玩笑便好，不必争论对错（但是欢迎指出文章存在的小错误）。\n二分图初步\r建议：如果你已对此有些许了解，可以根据目录直接跳到二分图匹配部分\n什么是二分图\r参考资料是这样介绍的：\n二分图又称作二部图，是图论中的一种特殊模型。 设 $G=(V, E)$ 是一个无向图。如果顶点集 $V$ 可分割为两个互不相交的子集 $X$ 和 $Y$，并且图中每条边连接的两个顶点一个在 $X$ 中，另一个在 $Y$ 中，则称图 $G$ 为二分图。 但其实可以简化成一张图去理解：\n上图就是一个二分图。\n二分图性质\r参考资料：\n定理：当且仅当无向图 $G$ 的每一个回路的边数均是偶数时，$G$ 才是一个二分图。如果无回路，相当于任一回路的边数为 $0$，故也视为二分图。 二分图判定\r参考资料这里写得太复杂了，简单的话描述一下：\n如果是一个连通图 从顶点 $1$ 开始宽度遍历整个图（$BFS$） 对遍历到的点进行染色，只染黑、白两色 染色过程中做到相邻点的颜色不同 如果不是一个连通图 在每个连通块中作判定，判定方法与上面相似 如下图，可判定为一个二分图：\n为了观察方便，这里用红、蓝两色代替了黑、白两色。\n二分图匹配\r什么是匹配\r先看看参考资料怎么说：\n给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。\n图中加粗的边是数量为 $2$ 的匹配。\n这里讲得很清楚，不过多赘述（下文当资料讲得很简单明了时，也不会再过多解释）。\n什么是最大匹配\r选择边数最大的子图称为图的最大匹配问题。\n如图加粗的边是一个最大匹配：\n可以简单理解为使 $X$ 部的顶点和 $Y$ 部的顶点匹配尽可能多。\n什么是增广路径\r设 $M$ 为二分图 $G$ 已匹配边的集合，若 $P$ 是图 $G$ 中一条连通两个未匹配顶点的路径（$P$ 的起点在 $X$ 部，终点在 $Y$ 部，反之亦可），并且属 $M$ 的边和不属 $M$ 的边(即已匹配和待匹配的边)在 $P$ 上交替出现，则称 $P$ 为相对于 $M$ 的一条增广路径。\n增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有……最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行，显然 $P$ 有奇数条边。\n为什么 $P$ 会有奇数条边呢？\n根据定义，$P$ 路径的起点和终点不在同一个部，所以必然是奇数条边。\n下面来根据这个图找一下增广路：\n易得一条路径： $$\rx_4 \\rightarrow y_3 \\rightarrow x_2 \\rightarrow y_1\\rightarrow x_1\\rightarrow y_2\r$$ 因为 $y_2$ 是 $Y$ 部中未匹配的点，所以此路径是增广路径。\n其中 $\\in M$ 的边有 $(x_2,y_3),(x_1,y_1)$，不属于匹配的边有 $(x_4,y_3),(x_2,y_1),(x_1,y_2)$。\n可见不属于匹配的边要多一条。\n如果我们想让情况变成匹配边会多一条，那就思考一下“取反”操作，即将匹配边变为非匹配边，反之同理。\n可得：\n可以得到这样的匹配 $M\u0026rsquo;=((x_3,y_4),(x_4,y_3),(x_2,y_1),(x_1,y_2))$。\n仔细思考，发现匹配仍然合法。交错轨也还存在。\n可以证明，当不能再找到增广路时，就已经得到了一个最大匹配。\n为什么？\n假设还能再找到一条增广路，那经过取反操作必定可以多增加一条匹配边。那最大匹配是最终形态，必定不会再有一条增广路。\n而这，就是匈牙利算法的思路。\n增广路径性质\r$P$ 的路径长度必定为奇数，第一条边和最后一条边都不属于 $M$，因为两个端点分属两个集合，且未匹配。 $P$ 经过取反操作可以得到一个更大的匹配 $M\u0026rsquo;$。 $M$ 为 $G$ 的最大匹配当且仅当不存在相对于 $M$ 的增广路径。 以上很好理解，根据定义可推出。\n匈牙利算法\r为什么要用匈牙利算法\r匈牙利算法就是用增广路求最大匹配问题，由匈牙利数学家 Edmonds 于1965年提出。\n匈牙利算法长什么样\r置 $M$ 为空 找出一条增广路径 $P$，通过取反操作获得更大的匹配$M\u0026rsquo;$代替$M$ 重复步骤2，直至再也找不出新增广路 怎么找增广路\r第一个想法肯定是用 dfs：\n从 $X$ 部一个未匹配的顶点 $u$ 开始，找一个未访问的邻接点 $v$（$v$ 一定是 $Y$ 部顶点）。\n对于 $v$，分两种情况：\n如果 $v$ 未匹配，则已找到一条增广路。 如果 $v$ 已匹配，设 $v$ 的匹配顶点为 $w$（$w$ 一定属 $X$ 部）。此时边 $(w,v)$ 为匹配边，根据“取反”思想，要将 $(w,v)$ 改为未匹配，$(u,v)$ 改为匹配。怎样才能实现这一点？要看从 $w$ 为起点出发能不能找到一条新增广路 $P\u0026rsquo;$。如果成功，那 $u\\rightarrow v\\rightarrow P\u0026rsquo;$ 就是以 $u$ 为起点的增广路径。 那么我们就成功地把匈牙利算法核心部分搞懂了，可以上代码了。\n代码实现匈牙利算法\r寻找增广路部分\rcode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // cx[i]表示与X部i点匹配的Y部顶点编号，cy[i]表示与Y部i点匹配的X部顶点编号 bool dfs(ll x) { for (auto y : v[x]) { if (!vis[y]) { vis[y] = 1; if (cy[y] == -1 || dfs(cy[y])) { cx[x] = y, cy[y] = x; return 1; } } } return 0; } 匈牙利算法主函数\rcode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define mem(a,b) memset(a,b,sizeof(a)) ll maxmatch() { ll ans = 0; mem(cx, -1); mem(cy, -1); rp(i, 1, n) { if (cx[i] == -1) { mem(vis, 0); ans += dfs(i); } } return ans; } 板题\u0026amp;后记\r前几天原题检测，考了一些最大匹配的原题。复习时才发现有很多纰漏平时没注意到，所以写了这篇文章。\n还是挺耗费精力的，因为这种知识和图片打交道比较多，制作图片和上传都挺麻烦的。\n挂个板子吧。\n[USACO4.2]完美的牛栏The Perfect Stall\n这里挂两个代码，在连接$X$部与$Y$部方面有些不同，根据个人习惯取舍咯……\n本人主要是按照题目意思及时变通，并没有什么常用的版本。\n版本 1：用一个数组存下两种关系（个人较常用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define mem(a, b) memset(a, b, sizeof(a)) const ll MAXN = 1e4 + 5; // 这里要注意一下，不然会RE ll n, m; ll s[MAXN]; bool vis[MAXN]; ll c[MAXN]; ll sum, en[MAXN \u0026lt;\u0026lt; 1], hed[MAXN], lst[MAXN \u0026lt;\u0026lt; 1]; void add(ll x, ll y) { en[++sum] = y; lst[sum] = hed[x]; hed[x] = sum; } bool dfs(ll x) { for (ll i = hed[x]; i; i = lst[i]) { ll y = en[i]; if (!vis[y]) { vis[y] = 1; if (!c[y] || dfs(c[y])) { c[y] = x; return 1; } } } return 0; } ll maxmatch() { ll ans = 0; rp(i, 1, n) { mem(vis, 0); if (dfs(i)) ++ans; } return ans; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); rp(i, 1, n) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); rp(j, 1, s[i]) { ll t; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;t); add(i, t); } } printf(\u0026#34;%lld\\n\u0026#34;, maxmatch()); return 0; } 版本 2：不同部用不同数组（根据题目不同偶尔采用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define pb push_back #define mem(a, b) memset(a, b, sizeof(a)) const ll MAXN = 200 + 5; ll n, m; vector\u0026lt;ll\u0026gt; v[MAXN \u0026lt;\u0026lt; 1]; ll cx[MAXN], cy[MAXN \u0026lt;\u0026lt; 1]; bool vis[MAXN \u0026lt;\u0026lt; 1]; bool dfs(ll x) { for (auto y : v[x]) { if (!vis[y]) { vis[y] = 1; if (cy[y] == -1 || dfs(cy[y])) { cx[x] = y, cy[y] = x; return 1; } } } return 0; } ll maxmatch() { ll ans = 0; mem(cx, -1); mem(cy, -1); rp(i, 1, n) { if (cx[i] == -1) { mem(vis, 0); ans += dfs(i); } } return ans; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); rp(i, 1, n) { ll x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); rp(j, 1, x) { ll y; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;y); v[i].pb(y + n), v[y + n].pb(i); } } printf(\u0026#34;%lld\\n\u0026#34;, maxmatch()); return 0; } ","date":"2023-05-21T00:05:00+08:00","image":"https://werchange.github.io/img/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/p2.png","permalink":"https://werchange.github.io/p/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/","title":"二分图最大匹配匈牙利算法"},{"content":"可持续化线段树\r前言：\n“这个数据结构是属于比较抽象的一类。并且代码实现比较繁琐复杂。”\n别人都这么说，我却觉得挺好理解、也挺好写的（可能是因为我曾经与多道线段树毒瘤题抗争多次）。\n为了避免以后我突然脑子抽了不记得了，可以拿出来看看。所以写下这篇笔记，希望也能帮到大家。\n建议：带上一个清晰的脑子（草稿纸和笔是没有用的，因为理解过程中会用三维的叠加操作）。\n注：本篇文章是我这个小蒟蒻写的，真正的dalao请看个玩笑便好，不必争论对错（但是欢迎指出文章存在的小错误）。\n什么是可持续化线段树\r可持续化线段树，就是一种能保存历史版本信息的线段树。\n“可持续化”——可以返回之前的某个状态，并在该基础上进行修改。\n可持续化线段树就是这样的一种结构。\n为什么要用可持续化线段树\r我们先考虑一个一般场景：\n此时你要实现一个可持久化的线段树，你会怎么做？\n一般人想到的、最朴素的做法就是每一次操作都新建一棵线段树。\n但是无论从空间还是时间上看，这种算法都是一种非常差的算法。\n仔细思考：\n我们每次更新肯定不会一整棵树进行修改，那么我们每次都要新建一棵树吗？\n显然不用。所以我们无需重新建树。\n什么是主席树\r主席树是可持续化线段树的一种。\n因为这种结构由黄嘉泰同学发明，而名字拼音缩写又恰好与曾经的一位提出科学发展观的主席的名字拼音缩写相同，所以称为主席树。\n主席树是以时间轴将（不同时刻状态的线段树的）根节点串起来的多层的权值线段树。\n每一层的根节点都代表一个历史时刻的入口，每一层可以共用之前层的节点。\n为什么要使用主席树\r主席树最初发明时，是为了解决区间第$k$小的问题。\n主席树\r主席树是权值线段树（上文有提），那么插入数据的时候，我们将得到一条链。\n例如我们数组元素的值域在$[1,10^3]$之间，插入的第一个数据是$100$，那通过“往左往右”（类似分治）的方法就可以找到代表$100$的叶子节点。\n详见图一：\n而类似的，我们在下一次插入新数据的时候，也会得到一条从根节点到叶子结点的一条链。\n当插入$666$时，如图二：\n注意！\n此时我们已经插入了两次数据，那么我们在插入第二次数据的同时，也要将第二棵树某些节点连向第一棵树“已开拓的边”。\n也就是说，插入第二次数据后，我们得到的线段树不会仅仅是上图的一条链，而是如图三所示的一棵树： 一个结论 那么我们可以将主席树简单理解成一个可以排开竖着放小玻璃片的暗箱。然后每一次插入数据，可以理解成每次放一张小玻璃片（按插入时间顺序依次有序放），而小玻璃片上面印着从根到叶子节点的链的图案。\n当我们想查询第$n$次的线段树状态时，可以理解成在第$n$张与第$n+1$张玻璃片之间放一个不透光的白布；然后用一束光从第一张玻璃片打过去，在白布上呈现的图案，就是第$n$次历史时刻的图案。\n如图四：\n那么主席树的实现原理也就搞清楚了。\n怎样使用主席树\r现在搞清楚了原理，那么我们具体落实到查找区间第$k$小的数该怎么找呢？\n按照我们上面解释的那样去思考，我们按从先到后的顺序在不同的玻璃片后面放白布，呈现出来的树是“一棵比一棵大”的。思考一下会发现，如果我们在每个时期的每个节点处增加一个成员——$cnt$，表示统计该节点下有多少子节点，那么结合所有玻璃片来看，这个$cnt$有了一点前缀和的味道。\n现在我们再看这个问题：\n求：长度为$n$的数组$[l,r]$区间中第$k$小的数\n分析：\n我们把每一个元素都进行一次“数据插入”，那我们可以得到$n$棵树（玻璃片） 我们选取第$l$棵树和第$r$棵树 先比较左子树，如果新增的元素大于等于$k$，证明这个区间中第$k$小的元素一定在左子树 如果步骤3发现是小于$k$，那么反之，第$k$小在右子树 重复步骤3和步骤4 当到叶子节点时，我们就已找到了答案（第$k$小的数） 注意：在步骤4时，假设左子树新增$x$个节点，那么我们在右子树找的是第$(k-x)$小的节点。\n现在抽象和具体部分都讲清楚了，可以上代码了。\n代码中的$sz$变量等同于上文所提$cnt$变量。\n主席树代码实现\r插入操作\rcode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define ll long long void update(ll r) { tr[r].sz=tr[tr[r].lc].sz+tr[tr[r].rc].sz; } void ins(ll \u0026amp;rt,ll lst,ll l,ll r,ll val) { rt=++tot; tr[rt]=tr[lst]; if(l==r) tr[rt].sz++; else { ll mid=(l+r)\u0026gt;\u0026gt;1; if(val\u0026lt;=mid) ins(tr[rt].lc,tr[lst].lc,l,mid,val); else ins(tr[rt].rc,tr[lst].rc,mid+1,r,val); update(rt); } } 查询操作\rcode:\n1 2 3 4 5 6 7 8 9 10 11 ll query(ll r1,ll r2,ll l,ll r,ll k) { if(l==r) return l; ll lc1=tr[r1].lc,lc2=tr[r2].lc; ll mid=(l+r)\u0026gt;\u0026gt;1; ll tmp=tr[lc2].sz-tr[lc1].sz; if(tmp\u0026gt;=k) return query(lc1,lc2,l,mid,k); return query(tr[r1].rc,tr[r2].rc,mid+1,r,k-tmp); } main函数\rcode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const ll INF=1e3; #define rp(i,o,p) for(ll i=o;i\u0026lt;=p;++i) int main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); rp(i,1,n) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); ins(rts[i],rts[i-1],1,INF,a[i]); } rp(i,1,m) { ll x,y,z; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z); printf(\u0026#34;%lld\\n\u0026#34;,query(rts[x-1],rts[y],1,INF,z)); } return 0; } 板题\u0026amp;后记\r突发奇想想写这篇笔记是因为在学这个新知识的时候，我脑子突然出现了文中“暗箱”的想法。以致于我一下就理解了抽象的部分。\n发现同机房同学不理解那个部分，所以我就打算写下来这种想法。\n主席树还是挺好学的，主要是要抽象出那个模型就好了。\n本片题解写得比较仓促，目前只写了主席树，还有一些没有写到（下次再补了）。\n挂一个板子吧。\n（不要问我为什么没有链接，因为luogu的板题还没做，只做了校内OJ的题）\n题意：\n给定一个长度为$n$的序列，$m$个询问，每个询问的形式为：$l，r，k$表示在$[l,r]$间中的第$k$小元素。\n数据范围：\n$n\\leq 10^5，m\\leq 10^5，1\\leq l\\leq r\\leq n， 1\\leq k\\leq r-l+1，1\\leq a_i\\leq 10^9$\ncode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i,o,p) for(ll i=o;i\u0026lt;=p;++i) #define pr(i,o,p) for(ll i=o;i\u0026gt;=p;--i) const ll MAXN=1e5+5,INF=1e9; ll n,m,tot; ll a[MAXN]; ll rts[MAXN]; struct TREE { ll lc,rc,sz; }tr[MAXN\u0026lt;\u0026lt;2]; void update(ll r) { tr[r].sz=tr[tr[r].lc].sz+tr[tr[r].rc].sz; } void ins(ll \u0026amp;rt,ll lst,ll l,ll r,ll val) { rt=++tot; tr[rt]=tr[lst]; if(l==r) tr[rt].sz++; else { ll mid=(l+r)\u0026gt;\u0026gt;1; if(val\u0026lt;=mid) ins(tr[rt].lc,tr[lst].lc,l,mid,val); else ins(tr[rt].rc,tr[lst].rc,mid+1,r,val); update(rt); } } ll query(ll r1,ll r2,ll l,ll r,ll k) { if(l==r) return l; ll lc1=tr[r1].lc,lc2=tr[r2].lc; ll mid=(l+r)\u0026gt;\u0026gt;1; ll tmp=tr[lc2].sz-tr[lc1].sz; if(tmp\u0026gt;=k) return query(lc1,lc2,l,mid,k); return query(tr[r1].rc,tr[r2].rc,mid+1,r,k-tmp); } int main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); rp(i,1,n) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); ins(rts[i],rts[i-1],1,INF,a[i]); } rp(i,1,m) { ll x,y,z; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z); printf(\u0026#34;%lld\\n\u0026#34;,query(rts[x-1],rts[y],1,INF,z)); } return 0; } ","date":"2023-05-16T20:54:00+08:00","image":"https://cdn.luogu.com.cn/upload/image_hosting/xq5tpo51.png","permalink":"https://werchange.github.io/p/%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/","title":"可持续化线段树"},{"content":"质数\r质数，又称素数。如果一个数 $a \\in \\N^+（a\\neq 1）$ 的因子有且仅有$1$和它本身，则称数 $a$ 为质数。\n普通筛法\r过程\r枚举 $[2,n-1]$，如果 $n$ 在这个范围内有因子，则 $n$ 不是因数。 因为 $n$ 的因子成对出现，所以我们可以枚举 $[2,\\sqrt{n}]$。 Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool isprime(int n) { for(int i=2;i*i\u0026lt;=n;i++) if(n%i==0) return 0; return 1; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=2;i\u0026lt;=n;i++) //将i=1排除掉。 if(isprime(i)) printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } 时间复杂度\r时间复杂度为 $\\Omicron(N\\sqrt{N})$，因为太慢了，所以有以下两种更快的筛法。\n埃式筛法\r过程\r循环从 $2$ ~ $n$，判断当前的下标 $i$ 是否曾经被确认为合数。 如果 $i$ 不是合数，那么将质数 $i$ 放进质数集合里并不断成倍增加，再将增加所得的数标记为合数，直至大于 $n$ 为止。如果 $i$ 为合数，重复找下一个 $i$。 Code\r1 2 3 4 5 6 7 8 9 10 11 void getprime(int n) { for(int i=2;i\u0026lt;=n;i++) { if(flgs[i]==1) // flgs[i]表示i是否为合数 continue; primes[++cnt]=i; // primes[]表示质数集合 for(int j=i;j\u0026lt;=n/i;j++) flgs[j*i]=1; } } 时间复杂度\r时间复杂度为 $\\Omicron(N \\log N)$。\n欧拉筛法\r过程\r循环从 $2$ ~ $n$，判断当前的下标 $i$ 是否曾经被确认为合数。 如果 $i$ 不是合数，把质数 $i$ 放进质数的集合里。 无论 $i$ 是不是合数，都遍历一遍质数集合，并将集合中遍历到的当前元素 $p_j$ 乘以 $i$ 后标记为合数，直至 $p_j\\times i \u0026gt;n$。 执行步骤 3 时，如果 $p_j\\mid i$，先将 $p_j\\times i$ 标记为合数，再重新找下一个 $i$。 Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void getprime(int n) { for(int i=2;i\u0026lt;=n;i++) { if(flgs[i]==0) primes[++cnt]=i; for(int j=1;j\u0026lt;=cnt;j++) { if(primes[j]*i\u0026gt;n) break; flgs[primes[j]*i]=1; if(i%primes[j]==0) break; } } } 时间复杂度\r时间复杂度为 $\\Omicron(N)$。\n","date":"2023-04-25T20:49:00+08:00","permalink":"https://werchange.github.io/p/%E8%B4%A8%E6%95%B0%E5%8F%8A%E5%85%B6%E7%AD%9B%E6%B3%95/","title":"质数及其筛法"},{"content":"平衡树\r是一种二叉查找树，其平衡性使得树的深度在$\\log n$以内，增加、删除等操作可以做到 $O(\\log n)$.\n平衡树的实现有多种，本文主要介绍 AVL，Treap，FHQ Treap 与 Splay .\nAVL\r介绍\rAVL 是这些算法中时间复杂度最优秀的，也是码量最大的.\n其原因在于：AVL 是维护绝对平衡，即左子树高度与右子树高度之差 $\\leq 1$\n所以每一次维护造就了优秀的时间复杂度 与超大的码量 .\n平衡维护\r可以说，平衡维护是铸造二叉平衡树最关键的一步，也是最难理解的一步.\n如何维护？\n1.先判断左子树与右子树高度之差.\r2.再判断较高的那一棵子树是它的左子树高还是右子树高.\r3.最后再进行旋转操作使其平衡.\r相信第1步很容易理解，这里不作过多解释.\n为什么会有第2步的判断？\n因为可能出现不同的情况，我们也需要做出不同的旋转.\n如下图，左子树根节点（节点3）的左儿子（节点2）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 再如下图，左子树根节点（节点15）的右儿子（节点18）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 同理，也有右子树高度高于左子树的情况. 明显可见，当多出来的那个节点与它的父亲、父亲的父亲（祖父）成一条线时，只需要通过一次旋转. 当不成一条线时，需要通过两次旋转.\n单旋转分为两种，左旋（zag）与右旋（zig）.\n如下图，为左旋. 如下图，为右旋. 双旋转则多为先进行一次方向旋转，使其呈链状后，再进行一次反方向旋转.\n如下图，为需要维护的不平衡状态. 又如下图，为进行旋转（左旋A，B）使三点共链的状态. 再如下图，为进行反方向旋转（右旋C，B）使其平衡的状态. 最后保持平衡.\n因为其不同方向两次旋转的特性，所以双旋转分为左右旋（zagzig）和右左旋（zigzag）.\n代码实现平衡维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void mountain(ll \u0026amp;r) // 注意引用\u0026amp; { ll lf=ls(r),rg=rs(r); // ls(r)为表示r的左儿子的函数，rs(r)反之 if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); // 单旋转，1表示zig，0反之 else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); // 双旋转，0表示zagzig，1反之 } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } 代码实现旋转操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct AVL { ll ch[2],sz,val,hi,cnt; }tr[MAXN]; ll rt,pcnt; void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } void mountain(ll \u0026amp;r) { ll lf=ls(r),rg=rs(r); if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } void ins(ll \u0026amp;r,ll x) { if(!r) { tr[++pcnt].val=x,r=pcnt; pushup(r); return; } if(x\u0026lt;tr[r].val) ins(ls(r),x); else ins(rs(r),x); mountain(r); } ll del(ll \u0026amp;r,ll x) { ll tmp; if(tr[r].val==x||x\u0026lt;tr[r].val\u0026amp;\u0026amp;!ls(r)||x\u0026gt;tr[r].val\u0026amp;\u0026amp;!rs(r)) { tmp=tr[r].val; if(!ls(r)||!rs(r)) { r=ls(r)+rs(r); return tmp; } tr[r].val=del(ls(r),x); } else { if(x\u0026lt;tr[r].val) tmp=del(ls(r),x); else tmp=del(rs(r),x); } mountain(r); return tmp; } ll grank(ll r,ll x) { if(!r) return 1; if(x\u0026lt;=tr[r].val) return grank(ls(r),x); return tr[ls(r)].sz+1+grank(rs(r),x); } ll xth(ll r,ll x) { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll pre(ll r,ll x) { if(!r) return -INF; if(tr[r].val\u0026gt;=x) return pre(ls(r),x); return max(tr[r].val,pre(rs(r),x)); } ll nxt(ll r,ll x) { if(!r) return INF; if(tr[r].val\u0026lt;=x) return nxt(rs(r),x); return min(tr[r].val,nxt(ls(r),x)); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } } Treap\r介绍\r虽然 AVL 敲可爱哒~ 但是在考场上真的来得及打吗？\n其实只要你练得够多，最快可在10min内打完，一般人也可以练进12min.\n明显地，维护平衡操作太长了，可不可以省去？\n或许我们用一些随机值赋值给不同节点，使其成为节点的优先级，在构造二叉查找树时使其满足点权有序性与优先级（随机值）有序性.\n如果这样，随机生成的数字一般可以使二叉查找树接近平衡.可理解为相对平衡但不是绝对平衡.\n当然，除非你考前被奆佬%而rp\u0026ndash;， 一般随机值不会刚好使其变成一条链. 在大数据下更具有代表性，即维护平衡树平衡的成功概率与数据大小成正比.\n所以，就有了时间复杂度不如 AVL 优秀，但是足够的—— Treap ！！\n$Treap$=$Tree+Heap$.\n从名字上可见它满足点权有序性（二叉查找 tree ），和优先级（随机值）有序性（大根或小根 heap ）.\n平衡维护\r其实 Treap 的维护与 AVL 很像，这里就不放图了.\n它们之间的区别或许只是维护时的条件不同.\nAVL 是当左右子树高度相差超过1时进行维护 Treap 是当左右子树优先级小于（或大于，这里不作定性要求，但是同一代码中必须都是小于或大于）根节点优先级时进行维护 还有一点，因为 Treap 讲究好写，所以只需要在插入数据的时候维护一下就可以了，删除后不用再次维护.\n代码实现插入数据与维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); // 旋转操作见AVL } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN = 5e5 + 5, INF = 0x3f3f3f3f; struct Treap { ll ch[2], sz, val, pri; } tr[MAXN]; ll rt, pcnt; ll fa[MAXN]; void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void rote(ll \u0026amp;r, ll op) { ll t = tr[r].ch[!op]; tr[r].ch[!op] = tr[t].ch[op]; tr[t].ch[op] = r; pushup(r), pushup(t); r = t; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } ll del(ll \u0026amp;r, ll x) { ll tmp; // 解释一下，因为平衡树是一种二叉查找树， // 所以可以把叶子结点与“要删除节点”换一下位置， // 这样的话二叉查找树的性质不会被改变， // 也成功地删除了节点（其他版本的平衡树删除维护同理） if (x == tr[r].val || x \u0026lt; tr[r].val \u0026amp;\u0026amp; !ls(r) || x \u0026gt; tr[r].val \u0026amp;\u0026amp; !rs(r)) { tmp = tr[r].val; if (!ls(r) || !rs(r)) { r = ls(r) + rs(r); return tmp; } tr[r].val = del(ls(r), x); } else { if (x \u0026lt; tr[r].val) tmp = del(ls(r), x); else tmp = del(rs(r), x); } pushup(r); return tmp; } ll grank(ll r, ll x) { if (!r) return 1; if (x \u0026lt;= tr[r].val) return grank(ls(r), x); return tr[ls(r)].sz + 1 + grank(rs(r), x); } ll xth(ll r, ll x) { if (tr[ls(r)].sz \u0026gt;= x) return xth(ls(r), x); if (tr[ls(r)].sz + 1 \u0026gt;= x) return tr[r].val; return xth(rs(r), x - 1 - tr[ls(r)].sz); } ll pre(ll r, ll x) { if (!r) return -INF; if (tr[r].val \u0026gt;= x) return pre(ls(r), x); return max(tr[r].val, pre(rs(r), x)); } ll nxt(ll r, ll x) { if (!r) return INF; if (tr[r].val \u0026lt;= x) return nxt(rs(r), x); return min(tr[r].val, nxt(ls(r), x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n--) { ll op, x; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;op, \u0026amp;x); if (op == 1) ins(rt, x); if (op == 2) del(rt, x); if (op == 3) printf(\u0026#34;%lld\\n\u0026#34;, grank(rt, x)); if (op == 4) printf(\u0026#34;%lld\\n\u0026#34;, xth(rt, x)); if (op == 5) printf(\u0026#34;%lld\\n\u0026#34;, pre(rt, x)); if (op == 6) printf(\u0026#34;%lld\\n\u0026#34;, nxt(rt, x)); } return 0; } FHQ Treap\r介绍\r可以说，旋转操作是占主流算法的大多数.\n但是一旦牵扯到可连续性等方面乃至理解方面，旋转操作是不太可取的.\n于是范浩强奆佬就发明了不用旋转的 Treap 算法—— FHQ Treap ！！\n也称作无旋 Treap.\n不旋转，怎么维护平衡？\n分裂！！\n合并！！\n分裂操作与合并操作\r分裂split\r分裂操作split是最难理解的也是最关键的一步.\n我们在插入数据和删除数据需要找到一个合适的点.\n而找这个点的路径，可以把树分裂成两部分，把小于等于插入值的分裂到左树，大于的就分裂到右树.\n就这样，我们可以得到两棵树（也有可能是空树）.\n合并merge\r合并操作的对象是两棵树，这两棵树一定满足，左边的树权最大值小于右边的树的权值最小值.\n我们根据其优先级来合并.\n为了描述方面，我们设左边的树为 $L$，右边的树为 $R$.\n首先比较两棵树的树根，谁优先级小，谁就作为新的树根.\n假设 $L$ 的优先级较小，那么 $L$ 的根做新的树根，则问题转换为 $L$ 的右子树与 $R$ 的合并问题了；否则就是 $R$ 的根作为新树的根，问题转换为 $L$ 和 $R$ 的左子树的合并问题了.\n明显地，可以写成递归.\n这样递归下去，直到某棵树为空，则递归结束。\n代码实现split与merge\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { // r为需要分裂的树的根 // xrt为分裂后将得到左树的树根 // yrt反之 if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); // 等于v的节点分到左树里 } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { // r为合并后的新根 // xrt为参与合并的左子树的根 // yrt反之 if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rep(c,i,a,b) for(c i=a;i\u0026lt;=b;++i) #define per(c,i,a,b) for(c i=a;i\u0026gt;=b;--i) #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+3,INF=0x3f3f3f3f; struct FHQ_Treap { ll ch[2]; ll sz; ll val; ll pri; }tr[MAXN]; ll pcnt,rt,rt1,rt2; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } void ins(ll \u0026amp;r,ll x) { split(r,rt1,rt2,x); tr[++pcnt].val=x,tr[pcnt].pri=rand(),tr[pcnt].sz=1,r=pcnt; merge(rt1,rt1,pcnt); merge(r,rt1,rt2); } void del(ll \u0026amp;r,ll x) { ll rt3; split(r,rt1,rt2,x); split(rt1,rt1,rt3,x-1); merge(rt1,rt1,rt3); merge(r,rt1,rt2); } ll getrank(ll r,ll x) // 数x的排名 { if(r==0) return 1; if(tr[r].val\u0026lt;x) return tr[ls(r)].sz+1+getrank(rs(r),x); return getrank(ls(r),x); } ll xth(ll r,ll x) // 第x个数 { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll getpre(ll r,ll x) // x的前驱 { if(r==0) return -INF; if(x\u0026lt;=tr[r].val) return getpre(ls(r),x); return max(tr[r].val,getpre(rs(r),x)); } ll getnxt(ll r,ll x) // x的后继 { if(r==0) return INF; if(x\u0026gt;=tr[r].val) return getnxt(rs(r),x); return min(tr[r].val,getnxt(ls(r),x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } return 0; } Splay\r介绍\rSplay 也称为伸展树，它也满足二叉查找树的性质.\n即一个节点的左子树的所有点权都会小于当前节点，右子树反之.\n它和其他平衡树算法最大不同的是，它不需要主动维护平衡，我们只需要在每个操作结束后进行一次splay(x,goal)的操作，它就可以自己维护了.\n当然splay(x,goal)里面还是有旋转操作的.\nsplay(x,goal)伸展操作\rsplay(x,goal)操作也就是伸展操作.\n通过一系列旋转使得 x 转到 goal 节点，旋转也需要分情况而论.\n以下 goal 节点为 root 根节点举例.\n情况一：节点 x 的父节点 y 是根节点. 这时如果 x 是 y 的左儿子，则进行一次 zig 操作；反之同理. 如图 1 所示.\r情况二：节点x的父节点y还有一个父节点z. 且此时三点成链，则进行一次zigzig操作或zagzag操作（是的，此处旋转不需要维护平衡，只是为了将x旋转到目标节点），如图2所示.\r情况三：节点x的父节点y还有父节点z. 且此时三点呈“之”字形，则进行一次zagzig操作或zigzag操作，如图3所示.\r如图5，是一次splay(2,rt)的操作.\n明显地，经过 splay() 操作后，平衡树明显“平衡”了许多.\n所以我们在一些插入、查询等操作后就做一遍 splay().\n这样做的话，时间复杂度可以下降. 但是同样地，常数也就增加了. 所以 Splay 算法是本文 4 个算法中最慢的.\n代码实现 splay(x,goal)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x,ll goal) // 这里goal==0时，表示将x转到根节点 { // 这里3行包含了旋转的3种情况，请自行理解，这里不作过多解释 for(ll y;(y=fa[x])!=goal;rote(x)) if(fa[y]!=goal) rote( ( ( rs(fa[y])==y) == (rs(y)==x) ) ? y : x); if(goal==0) // 如果目标是根节点，那根节点需要更新为x rt=x; } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct Splay { ll ch[2],sz,val,cnt; }tr[MAXN]; ll rt,pcnt; ll fa[MAXN]; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x) { for(ll y;(y=fa[x]);rote(x)) if(fa[y]) rote(((rs(fa[y])==y)==(rs(y)==x))?y:x); rt=x; } void ins(ll x) { if(!rt) { tr[++pcnt].val=x; tr[pcnt].cnt++; rt=pcnt; pushup(rt); return; } ll cur=rt,f=0; while(1) { if(tr[cur].val==x) { tr[cur].cnt++; pushup(cur); pushup(f); splay(cur); return; } f=cur; cur=tr[cur].ch[tr[cur].val\u0026lt;x]; if(!cur) { tr[++pcnt].val=x; tr[pcnt].cnt++; fa[pcnt]=f; tr[f].ch[tr[f].val\u0026lt;x]=pcnt; pushup(pcnt); pushup(f); splay(pcnt); return; } } } ll grank(ll x) { ll res=0,cur=rt; while(1) { if(tr[cur].val\u0026gt;x) cur=ls(cur); else { res+=tr[ls(cur)].sz; if(tr[cur].val==x) { splay(cur); return res+1; } res+=tr[cur].cnt; cur=rs(cur); } } } ll xth(ll x) { ll cur=rt; while(1) { if(ls(cur)\u0026amp;\u0026amp;tr[ls(cur)].sz\u0026gt;=x) cur=ls(cur); else { x-=tr[ls(cur)].sz+tr[cur].cnt; if(x\u0026lt;=0) { splay(cur); return tr[cur].val; } cur=rs(cur); } } } ll pre() { ll cur=ls(rt); if(!cur) return 0; while(rs(cur)) cur=rs(cur); splay(cur); return cur; } ll nxt() { ll cur=rs(rt); if(!cur) return 0; while(ls(cur)) cur=ls(cur); splay(cur); return cur; } void del(ll x) { grank(x); if(tr[rt].cnt\u0026gt;1) { tr[rt].cnt--; splay(rt); return; } if(!rs(rt)\u0026amp;\u0026amp;!ls(rt)) { rt=0; return; } if(!ls(rt)||!rs(rt)) { rt=ls(rt)+rs(rt); fa[rt]=0; return; } ll cur=rt; ll y=pre(); fa[rs(cur)]=y; rs(y)=rs(cur); pushup(rt); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(x); if(op==2) del(x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(x)); if(op==5) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[pre()].val),del(x); if(op==6) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[nxt()].val),del(x); } return 0; } 最后\r本文写得还是很仓促的，有些漏洞大家原谅一下.(^^)\n本文还有很多不完善的地方，例如 AVL 代码没有指针版、图片模糊等.\n欢迎大家在评论区留下建议或疑问、收藏、转发学习.\n转载请注明出处.\n仅供参考、学习用，不商用.\nThe End\n","date":"2023-01-11T09:21:00+08:00","image":"https://werchange.github.io/img/%E5%B9%B3%E8%A1%A1%E6%A0%91/p12.png","permalink":"https://werchange.github.io/p/%E5%B9%B3%E8%A1%A1%E6%A0%91%E8%AF%A6%E8%A7%A3/","title":"平衡树详解"},{"content":"凸透镜成像原理\r前言\r凸透镜成像原理是个有意思的知识。初二教科书会以实验的方式告诉我们原理。\n快要参加中考了，复习的时候老师说了一条公式：\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 但它为什么是对的，所以来证明一下。\n几何法\r要点：三角形相似。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ $证：$\n$\\because\\triangle ABO\\triangle A\u0026rsquo;B\u0026rsquo;O$ $\\qquad$ (三角形ABO相似于三角形A\u0026rsquo;B\u0026rsquo;O)\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=u:v$\n$\\because\\triangle COF∽\\triangle A\u0026rsquo;B\u0026rsquo;F$\n$\\therefore CO:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$\n$\\because 四边形ABOC为矩形$\n$\\therefore AB=CO$\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$ $\\therefore u:v=f:(v-f)$\n$\\therefore u(v-f)=vf$\n$\\therefore uv-uf=vf$\n$\\because uvf\\neq 0$\n$\\therefore \\frac{uv}{uvf}-\\frac{uf}{uvf}=\\frac{vf}{uvf}$\n$\\therefore \\frac{1}{f}-\\frac{1}{v}=\\frac{1}{u}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕$.\n函数法\r要点：一次函数，正比例函数。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 步骤\n（一）为便于用函数法解决此问题，将凸透镜的主光轴与平面直角坐标系的横坐标轴（$x$ 轴）关联（即重合），将凸透镜的理想折射面与纵坐标轴（$y$ 轴）关联，将凸透镜的光心与坐标原点关联.则：点 $A$ 的坐标为 $(-u,c)$，点 $F$ 的坐标为 $(f,0)$，点 $A\u0026rsquo;$ 的坐标为 $(v,-d)$，点 $C$ 的坐标为 $(0,c)$.\n（二）将 $AA\u0026rsquo;$，$A\u0026rsquo;C$ 双向延长为直线 $l_1$,$l_2$，视作两条函数图象.由图象可知：直线 $l_1$ 为正比例函数图象，直线 $l_2$ 为一次函数图象.\n（三）设直线 $l_1$ 的解析式为 $y=k_1x$，直线 $l_2$ 的解析式为 $y=k_2x+b$.\n依题意，将 $A(-u,c)$，$C(0,c)$，$F(f,0)$ 代入相应解析式，得\n$$\r\\begin{cases}\rc=-uk_1\\\\\rc=b\\\\\r0=k_2f+b\r\\end{cases}\r$$ 得\n$$\r\\begin{cases}\rk_1=-\\frac{c}{u}x\\\\\rk_2=-\\frac{c}{f}\r\\end{cases}\r$$ $\\therefore 两函数解析式为$\n$$\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r$$ $\\therefore 两函数交点 A\u0026rsquo;(x,y) 满足方程组$\n$$\r\\begin{cases}\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r\\end{cases}\r$$ $\\because A\u0026rsquo;(v,-d)$\n$$\\therefore\r\\begin{cases}\r-d=-\\frac{c}{u}v\\\\-d=-\\frac{c}{f}v+c\r\\end{cases}$$ $\\therefore -\\frac{c}{u}v=-\\frac{c}{f}v+c=-d$\n$\\therefore \\frac{c}{u}v=\\frac{c}{f}v+c=d$\n$\\therefore \\frac{cv}{u}=\\frac{cv}{f}+c$\n$\\therefore cvf=cuv-cuf$（两边同乘 $uf$）\n$\\therefore vf=uv-uf$\n$\\because uvf\\neq0$\n$\\therefore \\frac{vf}{uvf}=\\frac{uv}{uvf}-\\frac{uf}{uvf}$\n$\\therefore \\frac{1}{u}=\\frac{1}{f}-\\frac{1}{v}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕.$\n结尾\r这篇文章之前写过了，2024.6.6 进行了修改，使其更加可读。\n","date":"2022-11-29T19:23:00+08:00","image":"https://werchange.github.io/img/%E5%87%B8%E9%80%8F%E9%95%9C/p1.png","permalink":"https://werchange.github.io/p/%E5%87%B8%E9%80%8F%E9%95%9C%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86/","title":"凸透镜成像原理"},{"content":"update:2023.07.19 更新了堆优化版本的 Dijkstra\nupdate:2023.09.21 更新了时间复杂度讨论并修改了堆优化 Dij\nDijkstra\r什么是Dijkstra\rDijkstra采用了贪心的策略。\n在一张连通图中，我们将点分类为已知点和未知点。\n什么是已知点？就是已经遍历过的，例如原点（出发点）就是一个已知点。\n什么是未知点？顾名思义，就是未遍历到的点（除了已知点，剩下的就是未知点）\n理解贪心策略\r这里举一个简单的栗子：\n夏福要去 supermarket，他面前可以选择 3 个商店：\n1.壹加壹超市，据夏福 1000m 2.美宜佳商店，据夏福 500m 3.711超市，据夏福 200m 他该去哪个超市呢？\n这里很容易看出来，肯定是选择第 3 种方案。\n没错，这就是从夏福（原点）到超市（终点）的最短路径。也就是贪心策略。\n思考实现代码\r因为贪心只能保证局部最优，不能保证全局最优，所以我们还是需要去遍历，但是我们可以缩小遍历的范围。\n假想现在从已知点可以到达三个中转站，最后都可以到终点。\n那么从起点到终点的路径就是：起点到中转站的路径 + 中转站到终点的路径\n我们想让起点到中转站的距离尽可能的小，那肯定是选择据起点最近的中转站作为新的起点（新的已知点）\n我们就可以把那个点当作起点，继续找最短路径就好了。\n原来那个点怎么办？\n丢进垃圾桶里~\n代码实现\r题目： 输出从 $s$ 到 $t$ 的最短路，并换行输出最短路径 Input\n1 2 3 4 5 6 7 8 9 5 7 1 2 10 1 4 30 1 5 100 2 3 50 3 5 10 4 3 20 4 5 60 1 5 Output\n1 2 60 1 4 3 5 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int edge[505][505]; int ss, tt; bool vis[505]; pair\u0026lt;int, int\u0026gt; dis[505]; // 相当于一个变量里有两个成员：一个是距离，另一个是数组下标所连接的点 vector\u0026lt;int\u0026gt; q[505]; vector\u0026lt;int\u0026gt; ans; bool cmp(int a, int b) { return a \u0026lt; b; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 输入点的个数n，边的数量m for (int i = 1; i \u0026lt;= m; i++) { int l, r, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;v); // 输入边的信息：边连接的两个点l、r，和边的权值v edge[l][r] = v; // 表示从l到r这个点的权值是v /* 因为这个代码是有向图的最短路问题，如果是无向图的话应该再加上下面这行代码： edge[r][l] = v; 这个表示r到l的路径边权是v */ } scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;ss, \u0026amp;tt); // 输入ss（原点）和tt（终点），这个代码是输出从ss到tt的最短路径 for (int i = 1; i \u0026lt;= n; i++) dis[i].first = 1e9; // 初始化从原点到第i个点的路径全部为正无穷（这里只要数据够大就行了） fill(vis, vis + n + 1, 0); // 初始化所有的点都没被访问过 dis[ss].first = 0; // 从原点到原点的距离肯定是0 dis[ss].second = ss; // 默认原点和原点相连 for (int i = 1; i \u0026lt;= n; i++) { int tmp = -1; // 存储下标的临时变量 for (int j = 1; j \u0026lt;= n; j++) { if (!vis[j] \u0026amp;\u0026amp; (tmp == -1 || dis[j] \u0026lt; dis[tmp])) { // 只要 (j未被访问过) 并且只要达到 [(tmp未赋值) 或 (找到离i点有更近的点)] 的条件之一 tmp = j; // tmp就赋值为j } } vis[tmp] = 1; // 完事之后，备注tmp已经被访问过了，丢进**垃～圾～桶～**里 for (int j = 1; j \u0026lt;= n; j++) { if (dis[tmp].first + edge[tmp][j] \u0026lt; dis[j].first \u0026amp;\u0026amp; tmp != j \u0026amp;\u0026amp; edge[tmp][j]) { /* 如果 (到tmp的距离 + tmp到j的距离 \u0026lt; 原来到j的距离) 并且 (tmp和j不是同一个点) 并且 (tmp到j的距离不是0) 的话 */ dis[j].first = dis[tmp].first + edge[tmp][j]; dis[j].second = tmp; // 到j的距离重新赋值，与j相邻的点就变为tmp } } } printf(\u0026#34;%d\\n\u0026#34;, dis[tt].first); // 输出终点的距离 int temp = tt; while (dis[temp].second != ss) // 只要与temp这个临时变量相邻的不是起点，就进行 { ans.push_back(temp); // 把temp存储进ans数组里 temp = dis[temp].second; // temp就重新赋值 } ans.push_back(temp); // 最后一个点会跳出循环，所以要存储 ans.push_back(ss); // 把原点也放进去 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d \u0026#34;, ans[i]); // 倒过来输出就行了 } } 注意：\rDijkstra 采用的是贪心的策略，所以遇上有负边的图时，它就会陷入自环中。\nSPFA\r什么是 SPFA\r相对 Dijkstra 来讲，在随机生成数据中，会比Dijkstra会更快一点。\n它是基于邻接表的基础写的。\n理解邻接表\r在一张连通图中，一个点并不总是只连着一个点。\n举个粒子：\n小 A 家处于十字路口，可以从小 A 家到小 B 家、小 C 家、小 D 家等多个 good friends 的家。\n而对于小 A 家的邻接表就是： $B\\to C\\to D$\n代码实现\r题目：给一堆数据，输出 $1$ 到 $n$ 的最短路 Input\n1 2 3 4 5 6 7 8 4 7 1 2 68 1 3 19 1 4 66 2 3 23 3 4 65 3 2 57 4 1 68 Output\n1 66 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; struct edge { int s, e, val; }; int maxx = INT_MIN; int step; vector\u0026lt;edge\u0026gt; b[5005]; queue\u0026lt;int\u0026gt; q; int dis[5005]; bool vis[5005]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x, y, v; edge ee; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v); ee.s = x, ee.e = y, ee.val = v; b[x].push_back(ee); // 存储x的邻接表 } fill(dis, dis + n + 1, 1e9); // 初始化路径全部为正无穷（数据足够大就行） q.push(1); dis[1] = 0; vis[1] = 1; while (!q.empty()) { // STL宽搜 step++; if (step \u0026gt; m) { // 出现负环，直接退出 printf(\u0026#34;No Solution\u0026#34;); return 0; } int u = q.front(); q.pop(); for (int i = 0; i \u0026lt; b[u].size(); i++) { // 对于当前这个u点的邻接点 int vv = b[u][i].val; int en = b[u][i].e; if (dis[u] + vv \u0026lt; dis[en]) { // 如果 (到u点距离) + (从u点到它的邻接点的距离) \u0026lt; (原来的到en的距离) dis[en] = dis[u] + vv; if (!vis[en]) { // 在压入队列之前进行标记，否则会陷入死循环 vis[en] = 1; q.push(en); } } } vis[u] = 0; // 标记这个点《 免 费 》了（free这个点） } printf(\u0026#34;%d\u0026#34;, dis[n]); } Floyd\r什么是 Floyd\r就是运用枚举中间点进行松弛（专业术语，指令这个点距离最小）每个点的距离。\n理解枚举中间点\r还是举个梨子：\n小 A 和小 B 有一定的亲密度，为了使他们的亲密度更近，需要一个中介来帮忙。通过中介的帮忙，他们是否能提升之间的亲密度呢？所以我们就枚举一下。\n代码实现\rCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k) { if (dis[i][k] + dis[k][j] \u0026lt; dis[i][j]) { dis[i][j] = dis[i][k] + dis[k][j]; // 这样写的话，无论是有向图还是无向图都成立 } } } } } 但是这个时间复杂度是\n$O(n^3)$\n《没 逝 ， 就 慢 了 亿 点 点》\n堆优化Dijkstra\r思想\r因为Dijkstra类似于贪心的策略，每次都选择边权最小的边。如果我们用小根堆来维护呢？\n是的，所以堆优化 Dijkstra 用到了优先队列优化。\n因为曾有“关于 SPFA ——他死了”的一说，所以这个就很吃香。更好的是，这个和 SPFA 代码实现很像，所以直接入手是很容易的。\n代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN=500+5,MAXM=500+5,INF=0x3f3f3f3f3f3f3f3f; int n,m; int dis[MAXN]; bool vis[MAXN]; int su,en[MAXM\u0026lt;\u0026lt;1],vl[MAXM\u0026lt;\u0026lt;1],hd[MAXN],lt[MAXM\u0026lt;\u0026lt;1]; struct node { int id,dis; bool operator\u0026gt;(const node \u0026amp;T)const { return dis\u0026gt;T.dis; } }; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } int Dij() { priority_queue\u0026lt;node,vector\u0026lt;node\u0026gt;,greater\u0026lt;node\u0026gt;\u0026gt; q; memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); dis[1]=0,vis[1]=1; q.push({1,0}); while(!q.empty()) { int u=q.top().id;q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i],w=vl[i]; if(dis[v]\u0026gt;dis[u]+w) { dis[v]=dis[u]+w; if(!vis[v]) { vis[v]=1; q.push({v,dis[v]}); } } } vis[u]=0; } if(dis[n]==INF) return -1; return dis[n]; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++) { int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w),add(v,u,w); } printf(\u0026#34;%lld\\n\u0026#34;,Dij()); return 0; } 时间复杂度讨论\r堆优化 Dij：$O(m\\log m)$\n朴素 Dij：$O(n^2)$ SPFA：$O(nm)$（最坏情况） Floyd：$O(n^3)$\n一般来说，无负边权就选择 Dij，对于是否采用堆优化，取决于图的稀疏程度。\n关于 SPFA…… ","date":"2022-06-02T20:32:00+08:00","image":"https://werchange.github.io/img/%E6%9C%80%E7%9F%AD%E8%B7%AF/spfa.png","permalink":"https://werchange.github.io/p/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","title":"图论——最短路径问题"}]